"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/graphql/version.js
var require_version = __commonJS({
  "node_modules/graphql/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionInfo = exports2.version = void 0;
    var version = "16.7.1";
    exports2.version = version;
    var versionInfo3 = Object.freeze({
      major: 16,
      minor: 7,
      patch: 1,
      preReleaseTag: null
    });
    exports2.versionInfo = versionInfo3;
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/graphql/jsutils/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPromise = isPromise2;
    function isPromise2(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isObjectLike = isObjectLike2;
    function isObjectLike2(value) {
      return typeof value == "object" && value !== null;
    }
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.invariant = invariant2;
    function invariant2(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(
          message != null ? message : "Unexpected invariant triggered."
        );
      }
    }
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    var _invariant = require_invariant();
    var LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
      let lastLineStart = 0;
      let line = 1;
      for (const match of source.body.matchAll(LineRegExp)) {
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
          break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
      }
      return {
        line,
        column: position + 1 - lastLineStart
      };
    }
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(
        location.source,
        (0, _location.getLocation)(location.source, location.start)
      );
    }
    function printSourceLocation(source, sourceLocation) {
      const firstLineColumnOffset = source.locationOffset.column - 1;
      const body = "".padStart(firstLineColumnOffset) + source.body;
      const lineIndex = sourceLocation.line - 1;
      const lineOffset = source.locationOffset.line - 1;
      const lineNum = sourceLocation.line + lineOffset;
      const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      const columnNum = sourceLocation.column + columnOffset;
      const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
      const lines = body.split(/\r\n|[\n\r]/g);
      const locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for (let i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
          [`${lineNum} |`, subLines[0]],
          ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
          ["|", "^".padStart(subLineColumnNum)],
          ["|", subLines[subLineIndex + 1]]
        ]);
      }
      return locationStr + printPrefixedLines([
        // Lines specified like this: ["prefix", "string"],
        [`${lineNum - 1} |`, lines[lineIndex - 1]],
        [`${lineNum} |`, locationLine],
        ["|", "^".padStart(columnNum)],
        [`${lineNum + 1} |`, lines[lineIndex + 1]]
      ]);
    }
    function printPrefixedLines(lines) {
      const existingLines = lines.filter(([_2, line]) => line !== void 0);
      const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
      return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
    }
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLError = void 0;
    exports2.formatError = formatError2;
    exports2.printError = printError;
    var _isObjectLike = require_isObjectLike();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function toNormalizedOptions(args) {
      const firstArg = args[0];
      if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
          nodes: firstArg,
          source: args[1],
          positions: args[2],
          path: args[3],
          originalError: args[4],
          extensions: args[5]
        };
      }
      return firstArg;
    }
    var GraphQLError11 = class _GraphQLError extends Error {
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
          (loc) => (0, _location.getLocation)(loc.source, loc.start)
        );
        const originalExtensions = (0, _isObjectLike.isObjectLike)(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
    exports2.GraphQLError = GraphQLError11;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    function printError(error) {
      return error.toString();
    }
    function formatError2(error) {
      return error.toJSON();
    }
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [position]
      });
    }
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
    exports2.isNode = isNode;
    var Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    exports2.Location = Location;
    var Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    exports2.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports2.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    var OperationTypeNode;
    exports2.OperationTypeNode = OperationTypeNode;
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (exports2.OperationTypeNode = OperationTypeNode = {}));
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation2;
    exports2.DirectiveLocation = DirectiveLocation2;
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation2 || (exports2.DirectiveLocation = DirectiveLocation2 = {}));
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind25;
    exports2.Kind = Kind25;
    (function(Kind26) {
      Kind26["NAME"] = "Name";
      Kind26["DOCUMENT"] = "Document";
      Kind26["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind26["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind26["SELECTION_SET"] = "SelectionSet";
      Kind26["FIELD"] = "Field";
      Kind26["ARGUMENT"] = "Argument";
      Kind26["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind26["INLINE_FRAGMENT"] = "InlineFragment";
      Kind26["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind26["VARIABLE"] = "Variable";
      Kind26["INT"] = "IntValue";
      Kind26["FLOAT"] = "FloatValue";
      Kind26["STRING"] = "StringValue";
      Kind26["BOOLEAN"] = "BooleanValue";
      Kind26["NULL"] = "NullValue";
      Kind26["ENUM"] = "EnumValue";
      Kind26["LIST"] = "ListValue";
      Kind26["OBJECT"] = "ObjectValue";
      Kind26["OBJECT_FIELD"] = "ObjectField";
      Kind26["DIRECTIVE"] = "Directive";
      Kind26["NAMED_TYPE"] = "NamedType";
      Kind26["LIST_TYPE"] = "ListType";
      Kind26["NON_NULL_TYPE"] = "NonNullType";
      Kind26["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind26["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind26["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind26["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind26["FIELD_DEFINITION"] = "FieldDefinition";
      Kind26["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind26["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind26["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind26["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind26["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind26["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind26["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind26["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind26["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind26["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind26["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind26["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind26["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind26["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind25 || (exports2.Kind = Kind25 = {}));
  }
});

// node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "node_modules/graphql/language/characterClasses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isDigit = isDigit;
    exports2.isLetter = isLetter;
    exports2.isNameContinue = isNameContinue;
    exports2.isNameStart = isNameStart;
    exports2.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isLetter(code) {
      return code >= 97 && code <= 122 || // A-Z
      code >= 65 && code <= 90;
    }
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringLines = dedentBlockStringLines;
    exports2.isPrintableAsBlockString = isPrintableAsBlockString;
    exports2.printBlockString = printBlockString2;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent2 = leadingWhitespace2(line);
        if (indent2 === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent2 < commonIndent) {
          commonIndent = indent2;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
        (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
        lastNonEmptyLine + 1
      );
    }
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          case 13:
            return false;
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    function printBlockString2(value, options) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
        (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
      );
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
      (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind2;
    exports2.TokenKind = TokenKind2;
    (function(TokenKind3) {
      TokenKind3["SOF"] = "<SOF>";
      TokenKind3["EOF"] = "<EOF>";
      TokenKind3["BANG"] = "!";
      TokenKind3["DOLLAR"] = "$";
      TokenKind3["AMP"] = "&";
      TokenKind3["PAREN_L"] = "(";
      TokenKind3["PAREN_R"] = ")";
      TokenKind3["SPREAD"] = "...";
      TokenKind3["COLON"] = ":";
      TokenKind3["EQUALS"] = "=";
      TokenKind3["AT"] = "@";
      TokenKind3["BRACKET_L"] = "[";
      TokenKind3["BRACKET_R"] = "]";
      TokenKind3["BRACE_L"] = "{";
      TokenKind3["PIPE"] = "|";
      TokenKind3["BRACE_R"] = "}";
      TokenKind3["NAME"] = "Name";
      TokenKind3["INT"] = "Int";
      TokenKind3["FLOAT"] = "Float";
      TokenKind3["STRING"] = "String";
      TokenKind3["BLOCK_STRING"] = "BlockString";
      TokenKind3["COMMENT"] = "Comment";
    })(TokenKind2 || (exports2.TokenKind = TokenKind2 = {}));
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Lexer = void 0;
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _blockString = require_blockString();
    var _characterClasses = require_characterClasses();
    var _tokenKind = require_tokenKind();
    var Lexer = class {
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new _ast.Token(
          _tokenKind.TokenKind.SOF,
          0,
          0,
          0,
          0
        );
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      }
    };
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    function isUnicodeScalarValue(code) {
      return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
    }
    function isSupplementaryCodePoint(body, location) {
      return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
    }
    function isLeadingSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    function isTrailingSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    function printCodePointAt(lexer, location) {
      const code = lexer.source.body.codePointAt(location);
      if (code === void 0) {
        return _tokenKind.TokenKind.EOF;
      } else if (code >= 32 && code <= 126) {
        const char = String.fromCodePoint(code);
        return char === '"' ? `'"'` : `"${char}"`;
      }
      return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
    }
    function createToken(lexer, kind, start, end, value) {
      const line = lexer.line;
      const col = 1 + start - lexer.lineStart;
      return new _ast.Token(kind, start, end, line, col, value);
    }
    function readNextToken(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++position;
            continue;
          case 10:
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 13:
            if (body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 35:
            return readComment(lexer, position);
          case 33:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BANG,
              position,
              position + 1
            );
          case 36:
            return createToken(
              lexer,
              _tokenKind.TokenKind.DOLLAR,
              position,
              position + 1
            );
          case 38:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AMP,
              position,
              position + 1
            );
          case 40:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_L,
              position,
              position + 1
            );
          case 41:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_R,
              position,
              position + 1
            );
          case 46:
            if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
              return createToken(
                lexer,
                _tokenKind.TokenKind.SPREAD,
                position,
                position + 3
              );
            }
            break;
          case 58:
            return createToken(
              lexer,
              _tokenKind.TokenKind.COLON,
              position,
              position + 1
            );
          case 61:
            return createToken(
              lexer,
              _tokenKind.TokenKind.EQUALS,
              position,
              position + 1
            );
          case 64:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AT,
              position,
              position + 1
            );
          case 91:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_L,
              position,
              position + 1
            );
          case 93:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_R,
              position,
              position + 1
            );
          case 123:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_L,
              position,
              position + 1
            );
          case 124:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PIPE,
              position,
              position + 1
            );
          case 125:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_R,
              position,
              position + 1
            );
          case 34:
            if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              return readBlockString(lexer, position);
            }
            return readString(lexer, position);
        }
        if ((0, _characterClasses.isDigit)(code) || code === 45) {
          return readNumber(lexer, position, code);
        }
        if ((0, _characterClasses.isNameStart)(code)) {
          return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
        );
      }
      return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
    }
    function readComment(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.COMMENT,
        start,
        position,
        body.slice(start + 1, position)
      );
    }
    function readNumber(lexer, start, firstCode) {
      const body = lexer.source.body;
      let position = start;
      let code = firstCode;
      let isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, unexpected digit after 0: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
      return createToken(
        lexer,
        isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
        start,
        position,
        body.slice(start, position)
      );
    }
    function readDigits(lexer, start, firstCode) {
      if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          start,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            start
          )}.`
        );
      }
      const body = lexer.source.body;
      let position = start + 1;
      while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
        ++position;
      }
      return position;
    }
    function readString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      let chunkStart = position;
      let value = "";
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return createToken(
            lexer,
            _tokenKind.TokenKind.STRING,
            start,
            position + 1,
            value
          );
        }
        if (code === 92) {
          value += body.slice(chunkStart, position);
          const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
          value += escape2.value;
          position += escape2.size;
          chunkStart = position;
          continue;
        }
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    function readEscapedUnicodeVariableWidth(lexer, position) {
      const body = lexer.source.body;
      let point = 0;
      let size = 3;
      while (size < 12) {
        const code = body.charCodeAt(position + size++);
        if (code === 125) {
          if (size < 5 || !isUnicodeScalarValue(point)) {
            break;
          }
          return {
            value: String.fromCodePoint(point),
            size
          };
        }
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
          break;
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(
          position,
          position + size
        )}".`
      );
    }
    function readEscapedUnicodeFixedWidth(lexer, position) {
      const body = lexer.source.body;
      const code = read16BitHexCode(body, position + 2);
      if (isUnicodeScalarValue(code)) {
        return {
          value: String.fromCodePoint(code),
          size: 6
        };
      }
      if (isLeadingSurrogate(code)) {
        if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
          const trailingCode = read16BitHexCode(body, position + 8);
          if (isTrailingSurrogate(trailingCode)) {
            return {
              value: String.fromCodePoint(code, trailingCode),
              size: 12
            };
          }
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
      );
    }
    function read16BitHexCode(body, position) {
      return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
    }
    function readHexDigit(code) {
      return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
    }
    function readEscapedCharacter(lexer, position) {
      const body = lexer.source.body;
      const code = body.charCodeAt(position + 1);
      switch (code) {
        case 34:
          return {
            value: '"',
            size: 2
          };
        case 92:
          return {
            value: "\\",
            size: 2
          };
        case 47:
          return {
            value: "/",
            size: 2
          };
        case 98:
          return {
            value: "\b",
            size: 2
          };
        case 102:
          return {
            value: "\f",
            size: 2
          };
        case 110:
          return {
            value: "\n",
            size: 2
          };
        case 114:
          return {
            value: "\r",
            size: 2
          };
        case 116:
          return {
            value: "	",
            size: 2
          };
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid character escape sequence: "${body.slice(
          position,
          position + 2
        )}".`
      );
    }
    function readBlockString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let lineStart = lexer.lineStart;
      let position = start + 3;
      let chunkStart = position;
      let currentLine = "";
      const blockLines = [];
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          const token = createToken(
            lexer,
            _tokenKind.TokenKind.BLOCK_STRING,
            start,
            position + 3,
            // Return a string of the lines joined with U+000A.
            (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
          );
          lexer.line += blockLines.length - 1;
          lexer.lineStart = lineStart;
          return token;
        }
        if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          currentLine += body.slice(chunkStart, position);
          chunkStart = position + 1;
          position += 4;
          continue;
        }
        if (code === 10 || code === 13) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          if (code === 13 && body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          currentLine = "";
          chunkStart = position;
          lineStart = position;
          continue;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    function readName(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
          ++position;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.NAME,
        start,
        position,
        body.slice(start, position)
      );
    }
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.inspect = inspect2;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH2 = 2;
    function inspect2(value) {
      return formatValue2(value, []);
    }
    function formatValue2(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray2(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(
        ([key, value]) => key + ": " + formatValue2(value, seenValues)
      );
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray2(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue2(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceOf = void 0;
    var _inspect = require_inspect();
    var instanceOf = (
      /* c8 ignore next 6 */
      // FIXME: https://github.com/graphql/graphql-js/issues/2317
      globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
      } : function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = (
            // We still need to support constructor's name to detect conflicts with older versions of this library.
            Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
          );
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      }
    );
    exports2.instanceOf = instanceOf;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Source = void 0;
    exports2.isSource = isSource;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var Source2 = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || (0, _devAssert.devAssert)(
          false,
          `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
        );
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
    exports2.Source = Source2;
    function isSource(source) {
      return (0, _instanceOf.instanceOf)(source, Source2);
    }
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    exports2.parse = parse4;
    exports2.parseConstValue = parseConstValue;
    exports2.parseType = parseType;
    exports2.parseValue = parseValue;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function parse4(source, options) {
      const parser = new Parser(source, options);
      return parser.parseDocument();
    }
    function parseValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseConstValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseConstValueLiteral();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseType(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    var Parser = class {
      constructor(source, options = {}) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
          kind: _kinds.Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(
            _tokenKind.TokenKind.SOF,
            this.parseDefinition,
            _tokenKind.TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: _ast.OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return _ast.OperationTypeNode.QUERY;
          case "mutation":
            return _ast.OperationTypeNode.MUTATION;
          case "subscription":
            return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseVariableDefinition,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseSelection,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          item,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.INT,
              value: token.value
            });
          case _tokenKind.TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.FLOAT,
              value: token.value
            });
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: _kinds.Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: _kinds.Kind.ENUM,
                  value: token.value
                });
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw (0, _syntaxError.syntaxError)(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.LIST,
          values: this.any(
            _tokenKind.TokenKind.BRACKET_L,
            item,
            _tokenKind.TokenKind.BRACKET_R
          )
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(
            _tokenKind.TokenKind.BRACE_L,
            item,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: _kinds.Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return this.node(start, {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseFieldDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(
          _tokenKind.TokenKind.PIPE,
          this.parseDirectiveLocation
        );
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(
          _directiveLocation.DirectiveLocation,
          name.value
        )) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new _ast.Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
    exports2.Parser = Parser;
    function getTokenDesc(token) {
      const value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
    }
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
    }
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/graphql/jsutils/didYouMean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.didYouMean = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
      let message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      const suggestions = suggestionsArg.map((x) => `"${x}"`);
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      const selected = suggestions.slice(0, MAX_SUGGESTIONS);
      const lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/graphql/jsutils/identityFunc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.identityFunc = identityFunc;
    function identityFunc(x) {
      return x;
    }
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/graphql/jsutils/keyMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyMap = keyMap;
    function keyMap(list, keyFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = item;
      }
      return result;
    }
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/graphql/jsutils/keyValMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyValMap = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = valFn(item);
      }
      return result;
    }
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/graphql/jsutils/mapValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapValue = mapValue;
    function mapValue(map, fn2) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map)) {
        result[key] = fn2(map[key], key);
      }
      return result;
    }
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.naturalCompare = naturalCompare;
    function naturalCompare(aStr, bStr) {
      let aIndex = 0;
      let bIndex = 0;
      while (aIndex < aStr.length && bIndex < bStr.length) {
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
          let aNum = 0;
          do {
            ++aIndex;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIndex);
          } while (isDigit(aChar) && aNum > 0);
          let bNum = 0;
          do {
            ++bIndex;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIndex);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIndex;
          ++bIndex;
        }
      }
      return aStr.length - bStr.length;
    }
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/graphql/jsutils/suggestionList.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.suggestionList = suggestionList;
    var _naturalCompare = require_naturalCompare();
    function suggestionList(input, options) {
      const optionsByDistance = /* @__PURE__ */ Object.create(null);
      const lexicalDistance = new LexicalDistance(input);
      const threshold = Math.floor(input.length * 0.4) + 1;
      for (const option of options) {
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort((a, b2) => {
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b2];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b2);
      });
    }
    var LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b2 = this._inputArray;
        if (a.length < b2.length) {
          const tmp = a;
          a = b2;
          b2 = tmp;
        }
        const aLength = a.length;
        const bLength = b2.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j2 = 0; j2 <= bLength; j2++) {
          rows[0][j2] = j2;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j2 = 1; j2 <= bLength; j2++) {
            const cost = a[i - 1] === b2[j2 - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j2] + 1,
              // delete
              currentRow[j2 - 1] + 1,
              // insert
              upRow[j2 - 1] + cost
              // substitute
            );
            if (i > 1 && j2 > 1 && a[i - 1] === b2[j2 - 2] && a[i - 2] === b2[j2 - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j2 - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j2] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
    function stringToArray(str) {
      const strLength = str.length;
      const array = new Array(strLength);
      for (let i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/graphql/jsutils/toObjMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toObjMap = toObjMap;
    function toObjMap(obj) {
      if (obj == null) {
        return /* @__PURE__ */ Object.create(null);
      }
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      const map = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        map[key] = value;
      }
      return map;
    }
  }
});

// node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "node_modules/graphql/language/printString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/graphql/language/visitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BREAK = void 0;
    exports2.getEnterLeaveForKind = getEnterLeaveForKind;
    exports2.getVisitFn = getVisitFn;
    exports2.visit = visit2;
    exports2.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var BREAK = Object.freeze({});
    exports2.BREAK = BREAK;
    function visit2(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = Object.defineProperties(
                {},
                Object.getOwnPropertyDescriptors(node)
              );
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
            false,
            `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
          );
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/graphql/language/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.print = print6;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print6(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer2);
    }
    var MAX_LINE_LENGTH2 = 80;
    var printDocASTReducer2 = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join3(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap2("(", join3(node.variableDefinitions, ", "), ")");
          const prefix = join3(
            [
              node.operation,
              join3([node.name, varDefs]),
              join3(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join3(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block2(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join3(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join3(args, "\n")), "\n)");
          }
          return join3([argsLine, join3(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join3(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join3(
          [
            "...",
            wrap2("on ", typeCondition),
            join3(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap2("(", join3(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join3(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join3(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join3(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join3(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join3(["schema", join3(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join3(["scalar", name, join3(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join3(
          [
            "type",
            name,
            wrap2("implements ", join3(interfaces, " & ")),
            join3(directives, " "),
            block2(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + ": " + type + wrap2(" ", join3(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap2("", description, "\n") + join3(
          [name + ": " + type, wrap2("= ", defaultValue), join3(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join3(
          [
            "interface",
            name,
            wrap2("implements ", join3(interfaces, " & ")),
            join3(directives, " "),
            block2(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap2("", description, "\n") + join3(
          ["union", name, join3(directives, " "), wrap2("= ", join3(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap2("", description, "\n") + join3(["enum", name, join3(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap2("", description, "\n") + join3([name, join3(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap2("", description, "\n") + join3(["input", name, join3(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join3(args, "\n")), "\n)") : wrap2("(", join3(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join3(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join3(
          ["extend schema", join3(directives, " "), block2(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join3(["extend scalar", name, join3(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join3(
          [
            "extend type",
            name,
            wrap2("implements ", join3(interfaces, " & ")),
            join3(directives, " "),
            block2(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join3(
          [
            "extend interface",
            name,
            wrap2("implements ", join3(interfaces, " & ")),
            join3(directives, " "),
            block2(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join3(
          [
            "extend union",
            name,
            join3(directives, " "),
            wrap2("= ", join3(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join3(["extend enum", name, join3(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join3(["extend input", name, join3(directives, " "), block2(fields)], " ")
      }
    };
    function join3(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    function block2(array) {
      return wrap2("{\n", indent2(join3(array, "\n")), "\n}");
    }
    function wrap2(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    function indent2(str) {
      return wrap2("  ", str.replace(/\n/g, "\n  "));
    }
    function hasMultilineItems2(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromASTUntyped = valueFromASTUntyped;
    var _keyValMap = require_keyValMap();
    var _kinds = require_kinds();
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(
            (node) => valueFromASTUntyped(node, variables)
          );
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.keyValMap)(
            valueNode.fields,
            (field) => field.name.value,
            (field) => valueFromASTUntyped(field.value, variables)
          );
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
    }
  }
});

// node_modules/graphql/type/assertName.js
var require_assertName = __commonJS({
  "node_modules/graphql/type/assertName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertEnumValueName = assertEnumValueName;
    exports2.assertName = assertName;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _characterClasses = require_characterClasses();
    function assertName(name) {
      name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.length === 0) {
        throw new _GraphQLError.GraphQLError(
          "Expected name to be a non-empty string."
        );
      }
      for (let i = 1; i < name.length; ++i) {
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
          throw new _GraphQLError.GraphQLError(
            `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
          );
        }
      }
      if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(
          `Names must start with [_a-zA-Z] but "${name}" does not.`
        );
      }
      return name;
    }
    function assertEnumValueName(name) {
      if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(
          `Enum values cannot be named: ${name}`
        );
      }
      return assertName(name);
    }
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/graphql/type/definition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
    exports2.argsToArgsConfig = argsToArgsConfig;
    exports2.assertAbstractType = assertAbstractType;
    exports2.assertCompositeType = assertCompositeType;
    exports2.assertEnumType = assertEnumType;
    exports2.assertInputObjectType = assertInputObjectType;
    exports2.assertInputType = assertInputType;
    exports2.assertInterfaceType = assertInterfaceType;
    exports2.assertLeafType = assertLeafType;
    exports2.assertListType = assertListType;
    exports2.assertNamedType = assertNamedType;
    exports2.assertNonNullType = assertNonNullType;
    exports2.assertNullableType = assertNullableType;
    exports2.assertObjectType = assertObjectType;
    exports2.assertOutputType = assertOutputType;
    exports2.assertScalarType = assertScalarType;
    exports2.assertType = assertType;
    exports2.assertUnionType = assertUnionType;
    exports2.assertWrappingType = assertWrappingType;
    exports2.defineArguments = defineArguments;
    exports2.getNamedType = getNamedType6;
    exports2.getNullableType = getNullableType3;
    exports2.isAbstractType = isAbstractType3;
    exports2.isCompositeType = isCompositeType;
    exports2.isEnumType = isEnumType9;
    exports2.isInputObjectType = isInputObjectType13;
    exports2.isInputType = isInputType2;
    exports2.isInterfaceType = isInterfaceType10;
    exports2.isLeafType = isLeafType9;
    exports2.isListType = isListType12;
    exports2.isNamedType = isNamedType7;
    exports2.isNonNullType = isNonNullType12;
    exports2.isNullableType = isNullableType;
    exports2.isObjectType = isObjectType17;
    exports2.isOutputType = isOutputType;
    exports2.isRequiredArgument = isRequiredArgument;
    exports2.isRequiredInputField = isRequiredInputField;
    exports2.isScalarType = isScalarType9;
    exports2.isType = isType;
    exports2.isUnionType = isUnionType10;
    exports2.isWrappingType = isWrappingType;
    exports2.resolveObjMapThunk = resolveObjMapThunk;
    exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var _devAssert = require_devAssert();
    var _didYouMean = require_didYouMean();
    var _identityFunc = require_identityFunc();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _keyMap = require_keyMap();
    var _keyValMap = require_keyValMap();
    var _mapValue = require_mapValue();
    var _suggestionList = require_suggestionList();
    var _toObjMap = require_toObjMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _assertName = require_assertName();
    function isType(type) {
      return isScalarType9(type) || isObjectType17(type) || isInterfaceType10(type) || isUnionType10(type) || isEnumType9(type) || isInputObjectType13(type) || isListType12(type) || isNonNullType12(type);
    }
    function assertType(type) {
      if (!isType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`
        );
      }
      return type;
    }
    function isScalarType9(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLScalarType6);
    }
    function assertScalarType(type) {
      if (!isScalarType9(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`
        );
      }
      return type;
    }
    function isObjectType17(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLObjectType10);
    }
    function assertObjectType(type) {
      if (!isObjectType17(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`
        );
      }
      return type;
    }
    function isInterfaceType10(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType10);
    }
    function assertInterfaceType(type) {
      if (!isInterfaceType10(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`
        );
      }
      return type;
    }
    function isUnionType10(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLUnionType5);
    }
    function assertUnionType(type) {
      if (!isUnionType10(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`
        );
      }
      return type;
    }
    function isEnumType9(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLEnumType7);
    }
    function assertEnumType(type) {
      if (!isEnumType9(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`
        );
      }
      return type;
    }
    function isInputObjectType13(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType7);
    }
    function assertInputObjectType(type) {
      if (!isInputObjectType13(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(
            type
          )} to be a GraphQL Input Object type.`
        );
      }
      return type;
    }
    function isListType12(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLList9);
    }
    function assertListType(type) {
      if (!isListType12(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`
        );
      }
      return type;
    }
    function isNonNullType12(type) {
      return (0, _instanceOf.instanceOf)(type, GraphQLNonNull10);
    }
    function assertNonNullType(type) {
      if (!isNonNullType12(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`
        );
      }
      return type;
    }
    function isInputType2(type) {
      return isScalarType9(type) || isEnumType9(type) || isInputObjectType13(type) || isWrappingType(type) && isInputType2(type.ofType);
    }
    function assertInputType(type) {
      if (!isInputType2(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`
        );
      }
      return type;
    }
    function isOutputType(type) {
      return isScalarType9(type) || isObjectType17(type) || isInterfaceType10(type) || isUnionType10(type) || isEnumType9(type) || isWrappingType(type) && isOutputType(type.ofType);
    }
    function assertOutputType(type) {
      if (!isOutputType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`
        );
      }
      return type;
    }
    function isLeafType9(type) {
      return isScalarType9(type) || isEnumType9(type);
    }
    function assertLeafType(type) {
      if (!isLeafType9(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`
        );
      }
      return type;
    }
    function isCompositeType(type) {
      return isObjectType17(type) || isInterfaceType10(type) || isUnionType10(type);
    }
    function assertCompositeType(type) {
      if (!isCompositeType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`
        );
      }
      return type;
    }
    function isAbstractType3(type) {
      return isInterfaceType10(type) || isUnionType10(type);
    }
    function assertAbstractType(type) {
      if (!isAbstractType3(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`
        );
      }
      return type;
    }
    var GraphQLList9 = class {
      constructor(ofType) {
        isType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLList = GraphQLList9;
    var GraphQLNonNull10 = class {
      constructor(ofType) {
        isNullableType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(
            ofType
          )} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLNonNull = GraphQLNonNull10;
    function isWrappingType(type) {
      return isListType12(type) || isNonNullType12(type);
    }
    function assertWrappingType(type) {
      if (!isWrappingType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`
        );
      }
      return type;
    }
    function isNullableType(type) {
      return isType(type) && !isNonNullType12(type);
    }
    function assertNullableType(type) {
      if (!isNullableType(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`
        );
      }
      return type;
    }
    function getNullableType3(type) {
      if (type) {
        return isNonNullType12(type) ? type.ofType : type;
      }
    }
    function isNamedType7(type) {
      return isScalarType9(type) || isObjectType17(type) || isInterfaceType10(type) || isUnionType10(type) || isEnumType9(type) || isInputObjectType13(type);
    }
    function assertNamedType(type) {
      if (!isNamedType7(type)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`
        );
      }
      return type;
    }
    function getNamedType6(type) {
      if (type) {
        let unwrappedType = type;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    function resolveReadonlyArrayThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    function resolveObjMapThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    var GraphQLScalarType6 = class {
      constructor(config2) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.specifiedByURL = config2.specifiedByURL;
        this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(
          (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
        );
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config2.specifiedByURL)}.`
        );
        config2.serialize == null || typeof config2.serialize === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config2.parseLiteral) {
          typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLScalarType = GraphQLScalarType6;
    var GraphQLObjectType10 = class {
      constructor(config2) {
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.isTypeOf = config2.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config2);
        this._interfaces = () => defineInterfaces(config2);
        config2.isTypeOf == null || typeof config2.isTypeOf === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config2.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLObjectType = GraphQLObjectType10;
    function defineInterfaces(config2) {
      var _config$interfaces;
      const interfaces = resolveReadonlyArrayThunk(
        (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
      );
      Array.isArray(interfaces) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} interfaces must be an Array or a function which returns an Array.`
      );
      return interfaces;
    }
    function defineFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field config must be an object.`
        );
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
        );
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} args must be an object with argument names as keys.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function defineArguments(config2) {
      return Object.entries(config2).map(([argName, argConfig]) => ({
        name: (0, _assertName.assertName)(argName),
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
        astNode: argConfig.astNode
      }));
    }
    function isPlainObj(obj) {
      return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
    }
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.mapValue)(fields, (field) => ({
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
    }
    function argsToArgsConfig(args) {
      return (0, _keyValMap.keyValMap)(
        args,
        (arg) => arg.name,
        (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        })
      );
    }
    function isRequiredArgument(arg) {
      return isNonNullType12(arg.type) && arg.defaultValue === void 0;
    }
    var GraphQLInterfaceType10 = class {
      constructor(config2) {
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config2);
        this._interfaces = defineInterfaces.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInterfaceType = GraphQLInterfaceType10;
    var GraphQLUnionType5 = class {
      constructor(config2) {
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLUnionType = GraphQLUnionType5;
    function defineTypes(config2) {
      const types = resolveReadonlyArrayThunk(config2.types);
      Array.isArray(types) || (0, _devAssert.devAssert)(
        false,
        `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
      );
      return types;
    }
    var GraphQLEnumType7 = class {
      /* <T> */
      constructor(config2) {
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config2.values);
        this._valueLookup = new Map(
          this._values.map((enumValue) => [enumValue.value, enumValue])
        );
        this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
              outputValue
            )}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = (0, _inspect.inspect)(inputValue);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = (0, _keyValMap.keyValMap)(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLEnumType = GraphQLEnumType7;
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      const allNames = enumType.getValues().map((value) => value.name);
      const suggestedValues = (0, _suggestionList.suggestionList)(
        unknownValueStr,
        allNames
      );
      return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
    }
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.devAssert)(
        false,
        `${typeName} values must be an object with value names as keys.`
      );
      return Object.entries(valueMap).map(([valueName, valueConfig]) => {
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
          false,
          `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
            valueConfig
          )}.`
        );
        return {
          name: (0, _assertName.assertEnumValueName)(valueName),
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          deprecationReason: valueConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    var GraphQLInputObjectType7 = class {
      constructor(config2) {
        var _config$extensionASTN6;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config2);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInputObjectType = GraphQLInputObjectType7;
    function defineInputFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isRequiredInputField(field) {
      return isNonNullType12(field.type) && field.defaultValue === void 0;
    }
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/graphql/utilities/typeComparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doTypesOverlap = doTypesOverlap;
    exports2.isEqualType = isEqualType;
    exports2.isTypeSubTypeOf = isTypeSubTypeOf;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    function isTypeSubTypeOf(schema2, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema2.isSubType(superType, maybeSubType);
    }
    function doTypesOverlap(schema2, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema2.getPossibleTypes(typeA).some((type) => schema2.isSubType(typeB, type));
        }
        return schema2.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema2.isSubType(typeB, typeA);
      }
      return false;
    }
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/graphql/type/scalars.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
    exports2.isSpecifiedScalarType = isSpecifiedScalarType6;
    exports2.specifiedScalarTypes = void 0;
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var GRAPHQL_MAX_INT = 2147483647;
    exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
    var GRAPHQL_MIN_INT = -2147483648;
    exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
    var GraphQLInt4 = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    exports2.GraphQLInt = GraphQLInt4;
    var GraphQLFloat3 = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _printer.print)(
              valueNode
            )}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    exports2.GraphQLFloat = GraphQLFloat3;
    var GraphQLString4 = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLString = GraphQLString4;
    var GraphQLBoolean4 = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
            coercedValue
          )}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLBoolean = GraphQLBoolean4;
    var GraphQLID3 = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
        );
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLID = GraphQLID3;
    var specifiedScalarTypes = Object.freeze([
      GraphQLString4,
      GraphQLInt4,
      GraphQLFloat3,
      GraphQLBoolean4,
      GraphQLID3
    ]);
    exports2.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType6(type) {
      return specifiedScalarTypes.some(({ name }) => type.name === name);
    }
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          const valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/graphql/type/directives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
    exports2.assertDirective = assertDirective;
    exports2.isDirective = isDirective;
    exports2.isSpecifiedDirective = isSpecifiedDirective4;
    exports2.specifiedDirectives = void 0;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _directiveLocation = require_directiveLocation();
    var _assertName = require_assertName();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function isDirective(directive) {
      return (0, _instanceOf.instanceOf)(directive, GraphQLDirective4);
    }
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
        );
      }
      return directive;
    }
    var GraphQLDirective4 = class {
      constructor(config2) {
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.locations = config2.locations;
        this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        Array.isArray(config2.locations) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} locations must be an Array.`
        );
        const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} args must be an object with argument names as keys.`
        );
        this.args = (0, _definition.defineArguments)(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLDirective = GraphQLDirective4;
    var GraphQLIncludeDirective2 = new GraphQLDirective4({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports2.GraphQLIncludeDirective = GraphQLIncludeDirective2;
    var GraphQLSkipDirective2 = new GraphQLDirective4({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports2.GraphQLSkipDirective = GraphQLSkipDirective2;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective2 = new GraphQLDirective4({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective2;
    var GraphQLSpecifiedByDirective = new GraphQLDirective4({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective2,
      GraphQLSkipDirective2,
      GraphQLDeprecatedDirective2,
      GraphQLSpecifiedByDirective
    ]);
    exports2.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective4(directive) {
      return specifiedDirectives.some(({ name }) => name === directive.name);
    }
  }
});

// node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS({
  "node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableObject = isIterableObject2;
    function isIterableObject2(maybeIterable) {
      return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
    }
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/graphql/utilities/astFromValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.astFromValue = astFromValue2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function astFromValue2(value, type) {
      if ((0, _definition.isNonNullType)(type)) {
        const astValue = astFromValue2(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValue2(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue2(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
          return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type.getFields())) {
          const fieldValue = astFromValue2(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type)) {
        const serialized = type.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
          const stringNum = String(serialized);
          return integerStringRegExp3.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type === _scalars.GraphQLID && integerStringRegExp3.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError(
          `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
        );
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
    var integerStringRegExp3 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/graphql/type/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
    exports2.isIntrospectionType = isIntrospectionType3;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _directiveLocation = require_directiveLocation();
    var _printer = require_printer();
    var _astFromValue = require_astFromValue();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: _scalars.GraphQLString,
          resolve: (schema2) => schema2.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
          ),
          resolve(schema2) {
            return Object.values(schema2.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (schema2) => schema2.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema2) => schema2.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema2) => schema2.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Directive)
            )
          ),
          resolve: (schema2) => schema2.getDirectives()
        }
      })
    });
    exports2.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__DirectiveLocation)
            )
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    exports2.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports2.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve(type) {
            if ((0, _definition.isScalarType)(type)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.invariant)(
              false,
              `Unexpected type: "${(0, _inspect.inspect)(type)}".`
            );
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (type) => (
            /* c8 ignore next */
            "description" in type ? type.description : void 0
          )
        },
        specifiedByURL: {
          type: _scalars.GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__Field)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type) {
            if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema: schema2 }) {
            if ((0, _definition.isAbstractType)(type)) {
              return schema2.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__EnumValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isEnumType)(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__InputValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if ((0, _definition.isInputObjectType)(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    exports2.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    exports2.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    exports2.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    exports2.__EnumValue = __EnumValue;
    var TypeKind;
    exports2.TypeKind = TypeKind;
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (exports2.TypeKind = TypeKind = {}));
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports2.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef2 = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema: schema2 }) => schema2,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.SchemaMetaFieldDef = SchemaMetaFieldDef2;
    var TypeMetaFieldDef2 = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema: schema2 }) => schema2.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeMetaFieldDef = TypeMetaFieldDef2;
    var TypeNameMetaFieldDef2 = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef2;
    var introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
    exports2.introspectionTypes = introspectionTypes;
    function isIntrospectionType3(type) {
      return introspectionTypes.some(({ name }) => type.name === name);
    }
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/graphql/type/schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSchema = void 0;
    exports2.assertSchema = assertSchema;
    exports2.isSchema = isSchema5;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _ast = require_ast();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    function isSchema5(schema2) {
      return (0, _instanceOf.instanceOf)(schema2, GraphQLSchema3);
    }
    function assertSchema(schema2) {
      if (!isSchema5(schema2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(schema2)} to be a GraphQL schema.`
        );
      }
      return schema2;
    }
    var GraphQLSchema3 = class {
      // Used as a cache for validateSchema().
      constructor(config2) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config2.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.isObjectLike)(config2) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config2.types || Array.isArray(config2.types) || (0, _devAssert.devAssert)(
          false,
          `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
            config2.types
          )}.`
        );
        !config2.directives || Array.isArray(config2.directives) || (0, _devAssert.devAssert)(
          false,
          `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config2.directives)}.`
        );
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config2.query;
        this._mutationType = config2.mutation;
        this._subscriptionType = config2.subscription;
        this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        const allReferencedTypes = new Set(config2.types);
        if (config2.types != null) {
          for (const type of config2.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if ((0, _directives.isDirective)(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || (0, _devAssert.devAssert)(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return this.getQueryType();
          case _ast.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
    exports2.GraphQLSchema = GraphQLSchema3;
    function collectReferencedTypes(type, typeSet) {
      const namedType = (0, _definition.getNamedType)(type);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (const memberType of namedType.getTypes()) {
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (const interfaceType of namedType.getInterfaces()) {
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
            for (const arg of field.args) {
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/graphql/type/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSchema = assertValidSchema2;
    exports2.validateSchema = validateSchema;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _typeComparators = require_typeComparators();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function validateSchema(schema2) {
      (0, _schema.assertSchema)(schema2);
      if (schema2.__validationErrors) {
        return schema2.__validationErrors;
      }
      const context = new SchemaValidationContext(schema2);
      validateRootTypes(context);
      validateDirectives(context);
      validateTypes(context);
      const errors = context.getErrors();
      schema2.__validationErrors = errors;
      return errors;
    }
    function assertValidSchema2(schema2) {
      const errors = validateSchema(schema2);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
    var SchemaValidationContext = class {
      constructor(schema2) {
        this._errors = [];
        this.schema = schema2;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
    function validateRootTypes(context) {
      const schema2 = context.schema;
      const queryType = schema2.getQueryType();
      if (!queryType) {
        context.reportError("Query root type must be provided.", schema2.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError(
          `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
          (_getOperationTypeNode = getOperationTypeNode(
            schema2,
            _ast.OperationTypeNode.QUERY
          )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
        );
      }
      const mutationType = schema2.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError(
          `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
          (_getOperationTypeNode2 = getOperationTypeNode(
            schema2,
            _ast.OperationTypeNode.MUTATION
          )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
        );
      }
      const subscriptionType = schema2.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError(
          `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
          (_getOperationTypeNode3 = getOperationTypeNode(
            schema2,
            _ast.OperationTypeNode.SUBSCRIPTION
          )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
        );
      }
    }
    function getOperationTypeNode(schema2, operation) {
      var _flatMap$find;
      return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (schemaNode) => {
          var _schemaNode$operation;
          return (
            /* c8 ignore next */
            (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
          );
        }
      ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    function validateDirectives(context) {
      for (const directive of context.schema.getDirectives()) {
        if (!(0, _directives.isDirective)(directive)) {
          context.reportError(
            `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
            directive === null || directive === void 0 ? void 0 : directive.astNode
          );
          continue;
        }
        validateName(context, directive);
        for (const arg of directive.args) {
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context.reportError(
              `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              arg.astNode
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context.reportError(
              `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]
            );
          }
        }
      }
    }
    function validateName(context, node) {
      if (node.name.startsWith("__")) {
        context.reportError(
          `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
          node.astNode
        );
      }
    }
    function validateTypes(context) {
      const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
      const typeMap = context.schema.getTypeMap();
      for (const type of Object.values(typeMap)) {
        if (!(0, _definition.isNamedType)(type)) {
          context.reportError(
            `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,
            type.astNode
          );
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type)) {
          validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
          validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
          validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
          validateInputFields(context, type);
          validateInputObjectCircularRefs(type);
        }
      }
    }
    function validateFields(context, type) {
      const fields = Object.values(type.getFields());
      if (fields.length === 0) {
        context.reportError(`Type ${type.name} must define one or more fields.`, [
          type.astNode,
          ...type.extensionASTNodes
        ]);
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context.reportError(
            `The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
          );
        }
        for (const arg of field.args) {
          const argName = arg.name;
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context.reportError(
              `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context.reportError(
              `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]
            );
          }
        }
      }
    }
    function validateInterfaces(context, type) {
      const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (const iface of type.getInterfaces()) {
        if (!(0, _definition.isInterfaceType)(iface)) {
          context.reportError(
            `Type ${(0, _inspect.inspect)(
              type
            )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        if (type === iface) {
          context.reportError(
            `Type ${type.name} cannot implement itself because it would create a circular reference.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context.reportError(
            `Type ${type.name} can only implement ${iface.name} once.`,
            getAllImplementsInterfaceNodes(type, iface)
          );
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
      }
    }
    function validateTypeImplementsInterface(context, type, iface) {
      const typeFieldMap = type.getFields();
      for (const ifaceField of Object.values(iface.getFields())) {
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context.reportError(
            `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
            [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
          );
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(
          context.schema,
          typeField.type,
          ifaceField.type
        )) {
          var _ifaceField$astNode, _typeField$astNode;
          context.reportError(
            `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
            [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]
          );
        }
        for (const ifaceArg of ifaceField.args) {
          const argName = ifaceArg.name;
          const typeArg = typeField.args.find((arg) => arg.name === argName);
          if (!typeArg) {
            context.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
              [ifaceArg.astNode, typeField.astNode]
            );
            continue;
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
              [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]
            );
          }
        }
        for (const typeArg of typeField.args) {
          const argName = typeArg.name;
          const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context.reportError(
              `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
              [typeArg.astNode, ifaceField.astNode]
            );
          }
        }
      }
    }
    function validateTypeImplementsAncestors(context, type, iface) {
      const ifaceInterfaces = type.getInterfaces();
      for (const transitive of iface.getInterfaces()) {
        if (!ifaceInterfaces.includes(transitive)) {
          context.reportError(
            transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
            [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type, iface)
            ]
          );
        }
      }
    }
    function validateUnionMembers(context, union) {
      const memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context.reportError(
          `Union type ${union.name} must define one or more member types.`,
          [union.astNode, ...union.extensionASTNodes]
        );
      }
      const includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (const memberType of memberTypes) {
        if (includedTypeNames[memberType.name]) {
          context.reportError(
            `Union type ${union.name} can only include type ${memberType.name} once.`,
            getUnionMemberTypeNodes(union, memberType.name)
          );
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context.reportError(
            `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
            getUnionMemberTypeNodes(union, String(memberType))
          );
        }
      }
    }
    function validateEnumValues(context, enumType) {
      const enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context.reportError(
          `Enum type ${enumType.name} must define one or more values.`,
          [enumType.astNode, ...enumType.extensionASTNodes]
        );
      }
      for (const enumValue of enumValues) {
        validateName(context, enumValue);
      }
    }
    function validateInputFields(context, inputObj) {
      const fields = Object.values(inputObj.getFields());
      if (fields.length === 0) {
        context.reportError(
          `Input Object type ${inputObj.name} must define one or more fields.`,
          [inputObj.astNode, ...inputObj.extensionASTNodes]
        );
      }
      for (const field of fields) {
        validateName(context, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context.reportError(
            `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
          );
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context.reportError(
            `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]
          );
        }
      }
    }
    function createInputObjectCircularRefsValidator(context) {
      const visitedTypes = /* @__PURE__ */ Object.create(null);
      const fieldPath = [];
      const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields) {
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            const fieldType = field.type.ofType;
            const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              const cyclePath = fieldPath.slice(cycleIndex);
              const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
              context.reportError(
                `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                cyclePath.map((fieldObj) => fieldObj.astNode)
              );
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
    }
    function getAllImplementsInterfaceNodes(type, iface) {
      const { astNode, extensionASTNodes } = type;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((typeNode) => {
        var _typeNode$interfaces;
        return (
          /* c8 ignore next */
          (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
        );
      }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
    }
    function getUnionMemberTypeNodes(union, typeName) {
      const { astNode, extensionASTNodes } = union;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((unionNode) => {
        var _unionNode$types;
        return (
          /* c8 ignore next */
          (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
        );
      }).filter((typeNode) => typeNode.name.value === typeName);
    }
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
        (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
      );
    }
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/graphql/utilities/typeFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeFromAST = typeFromAST3;
    var _kinds = require_kinds();
    var _definition = require_definition();
    function typeFromAST3(schema2, typeNode) {
      switch (typeNode.kind) {
        case _kinds.Kind.LIST_TYPE: {
          const innerType = typeFromAST3(schema2, typeNode.type);
          return innerType && new _definition.GraphQLList(innerType);
        }
        case _kinds.Kind.NON_NULL_TYPE: {
          const innerType = typeFromAST3(schema2, typeNode.type);
          return innerType && new _definition.GraphQLNonNull(innerType);
        }
        case _kinds.Kind.NAMED_TYPE:
          return schema2.getType(typeNode.name.value);
      }
    }
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/graphql/utilities/TypeInfo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TypeInfo = void 0;
    exports2.visitWithTypeInfo = visitWithTypeInfo;
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    var TypeInfo = class {
      constructor(schema2, initialType, getFieldDefFn) {
        this._schema = schema2;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef2;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema2 = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            const namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push(
              (0, _definition.isCompositeType)(namedType) ? namedType : void 0
            );
            break;
          }
          case _kinds.Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema2, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(
              (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
            );
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema2.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            const rootType = schema2.getRootType(node.operation);
            this._typeStack.push(
              (0, _definition.isObjectType)(rootType) ? rootType : void 0
            );
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema2, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push(
              (0, _definition.isOutputType)(outputType) ? outputType : void 0
            );
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            const inputType = (0, _typeFromAST.typeFromAST)(schema2, node.type);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputType) ? inputType : void 0
            );
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(argType) ? argType : void 0
            );
            break;
          }
          case _kinds.Kind.LIST: {
            const listType = (0, _definition.getNullableType)(this.getInputType());
            const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(itemType) ? itemType : void 0
            );
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            const objectType = (0, _definition.getNamedType)(this.getInputType());
            let inputFieldType;
            let inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case _kinds.Kind.ENUM: {
            const enumType = (0, _definition.getNamedType)(this.getInputType());
            let enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
    exports2.TypeInfo = TypeInfo;
    function getFieldDef2(schema2, parentType, fieldNode) {
      const name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter(...args) {
          const node = args[0];
          typeInfo.enter(node);
          const fn2 = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
          if (fn2) {
            const result = fn2.apply(visitor, args);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave(...args) {
          const node = args[0];
          const fn2 = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
          let result;
          if (fn2) {
            result = fn2.apply(visitor, args);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/graphql/language/predicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isConstValueNode = isConstValueNode;
    exports2.isDefinitionNode = isDefinitionNode2;
    exports2.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports2.isSelectionNode = isSelectionNode;
    exports2.isTypeDefinitionNode = isTypeDefinitionNode;
    exports2.isTypeExtensionNode = isTypeExtensionNode;
    exports2.isTypeNode = isTypeNode;
    exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports2.isValueNode = isValueNode;
    var _kinds = require_kinds();
    function isDefinitionNode2(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    function isConstValueNode(node) {
      return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
    }
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context) {
      return {
        Document(node) {
          for (const definition of node.definitions) {
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `The ${defName} definition is not executable.`,
                  {
                    nodes: definition
                  }
                )
              );
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _naturalCompare = require_naturalCompare();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function FieldsOnCorrectTypeRule(context) {
      return {
        Field(node) {
          const type = context.getParentType();
          if (type) {
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              const schema2 = context.getSchema();
              const fieldName = node.name.value;
              let suggestion = (0, _didYouMean.didYouMean)(
                "to use an inline fragment on",
                getSuggestedTypeNames(schema2, type, fieldName)
              );
              if (suggestion === "") {
                suggestion = (0, _didYouMean.didYouMean)(
                  getSuggestedFieldNames(type, fieldName)
                );
              }
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    function getSuggestedTypeNames(schema2, type, fieldName) {
      if (!(0, _definition.isAbstractType)(type)) {
        return [];
      }
      const suggestedTypes = /* @__PURE__ */ new Set();
      const usageCount = /* @__PURE__ */ Object.create(null);
      for (const possibleType of schema2.getPossibleTypes(type)) {
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()) {
          var _usageCount$possibleI;
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return [...suggestedTypes].sort((typeA, typeB) => {
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema2.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema2.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
      }).map((x) => x.name);
    }
    function getSuggestedFieldNames(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        const possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
      }
      return [];
    }
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context) {
      return {
        InlineFragment(node) {
          const typeCondition = node.typeCondition;
          if (typeCondition) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              typeCondition
            );
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(typeCondition);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: typeCondition
                  }
                )
              );
            }
          }
        },
        FragmentDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            node.typeCondition
          );
          if (type && !(0, _definition.isCompositeType)(type)) {
            const typeStr = (0, _printer.print)(node.typeCondition);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: node.typeCondition
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    exports2.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownArgumentNamesRule(context) {
      return {
        // eslint-disable-next-line new-cap
        ...KnownArgumentNamesOnDirectivesRule(context),
        Argument(argNode) {
          const argDef = context.getArgument();
          const fieldDef = context.getFieldDef();
          const parentType = context.getParentType();
          if (!argDef && fieldDef && parentType) {
            const argName = argNode.name.value;
            const knownArgsNames = fieldDef.args.map((arg) => arg.name);
            const suggestions = (0, _suggestionList.suggestionList)(
              argName,
              knownArgsNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      };
    }
    function KnownArgumentNamesOnDirectivesRule(context) {
      const directiveArgs = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      const definedDirectives = schema2 ? schema2.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
        }
      }
      return {
        Directive(directiveNode) {
          const directiveName = directiveNode.name.value;
          const knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (const argNode of directiveNode.arguments) {
              const argName = argNode.name.value;
              if (!knownArgs.includes(argName)) {
                const suggestions = (0, _suggestionList.suggestionList)(
                  argName,
                  knownArgs
                );
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                    {
                      nodes: argNode
                    }
                  )
                );
              }
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownDirectivesRule(context) {
      const locationsMap = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      const definedDirectives = schema2 ? schema2.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        locationsMap[directive.name] = directive.locations;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map((name) => name.value);
        }
      }
      return {
        Directive(node, _key, _parent, _path, ancestors) {
          const name = node.name.value;
          const locations = locationsMap[name];
          if (!locations) {
            context.reportError(
              new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              })
            );
            return;
          }
          const candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && !locations.includes(candidateLocation)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${name}" may not be used on ${candidateLocation}.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    function getDirectiveLocationForASTPath(ancestors) {
      const appliedTo = ancestors[ancestors.length - 1];
      "kind" in appliedTo || (0, _invariant.invariant)(false);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          const parentNode = ancestors[ancestors.length - 3];
          "kind" in parentNode || (0, _invariant.invariant)(false);
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
          );
      }
    }
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
          return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
    }
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context) {
      return {
        FragmentSpread(node) {
          const fragmentName = node.name.value;
          const fragment = context.getFragment(fragmentName);
          if (!fragment) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown fragment "${fragmentName}".`,
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    function KnownTypeNamesRule(context) {
      const schema2 = context.getSchema();
      const existingTypesMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
      ];
      return {
        NamedType(node, _1, parent, _2, ancestors) {
          const typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            const isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && standardTypeNames.includes(typeName)) {
              return;
            }
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              isSDL ? standardTypeNames.concat(typeNames) : typeNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    var standardTypeNames = [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ].map((type) => type.name);
    function isSDLNode(value) {
      return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context) {
      let operationCount = 0;
      return {
        Document(node) {
          operationCount = node.definitions.filter(
            (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
          ).length;
        },
        OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "This anonymous operation must be the only defined operation.",
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context) {
      var _ref, _ref2, _oldSchema$astNode;
      const oldSchema = context.getSchema();
      const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      let schemaDefinitionsCount = 0;
      return {
        SchemaDefinition(node) {
          if (alreadyDefined) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "Cannot define a new schema within a schema extension.",
                {
                  nodes: node
                }
              )
            );
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                "Must provide only one schema definition.",
                {
                  nodes: node
                }
              )
            );
          }
          ++schemaDefinitionsCount;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context) {
      const visitedFrags = /* @__PURE__ */ Object.create(null);
      const spreadPath = [];
      const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes) {
          const spreadName = spreadNode.name.value;
          const cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            const spreadFragment = context.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            const cyclePath = spreadPath.slice(cycleIndex);
            const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                {
                  nodes: cyclePath
                }
              )
            );
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
    }
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context) {
      let variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              const varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                    {
                      nodes: [node, operation]
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context) {
      const operationDefs = [];
      const fragmentDefs = [];
      return {
        OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave() {
            const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (const operation of operationDefs) {
              for (const fragment of context.getRecursivelyReferencedFragments(
                operation
              )) {
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (const fragmentDef of fragmentDefs) {
              const fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment "${fragName}" is never used.`,
                    {
                      nodes: fragmentDef
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context) {
      let variableDefs = [];
      return {
        OperationDefinition: {
          enter() {
            variableDefs = [];
          },
          leave(operation) {
            const variableNameUsed = /* @__PURE__ */ Object.create(null);
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              variableNameUsed[node.name.value] = true;
            }
            for (const variableDef of variableDefs) {
              const variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                    {
                      nodes: variableDef
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
  }
});

// node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS({
  "node_modules/graphql/utilities/sortValueNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sortValueNode = sortValueNode;
    var _naturalCompare = require_naturalCompare();
    var _kinds = require_kinds();
    function sortValueNode(valueNode) {
      switch (valueNode.kind) {
        case _kinds.Kind.OBJECT:
          return { ...valueNode, fields: sortFields(valueNode.fields) };
        case _kinds.Kind.LIST:
          return { ...valueNode, values: valueNode.values.map(sortValueNode) };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
          return valueNode;
      }
    }
    function sortFields(fields) {
      return fields.map((fieldNode) => ({
        ...fieldNode,
        value: sortValueNode(fieldNode.value)
      })).sort(
        (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
      );
    }
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _sortValueNode = require_sortValueNode();
    var _typeFromAST = require_typeFromAST();
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(
          ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
        ).join(" and ");
      }
      return reason;
    }
    function OverlappingFieldsCanBeMergedRule(context) {
      const comparedFragmentPairs = new PairSet();
      const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet(selectionSet) {
          const conflicts = findConflictsWithinSelectionSet(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            context.getParentType(),
            selectionSet
          );
          for (const [[responseName, reason], fields1, fields2] of conflicts) {
            const reasonMsg = reasonMessage(reason);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                {
                  nodes: fields1.concat(fields2)
                }
              )
            );
          }
        }
      };
    }
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
      const conflicts = [];
      const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType,
        selectionSet
      );
      collectConflictsWithin(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        fieldMap
      );
      if (fragmentNames.length !== 0) {
        for (let i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            fieldMap,
            fragmentNames[i]
          );
          for (let j2 = i + 1; j2 < fragmentNames.length; j2++) {
            collectConflictsBetweenFragments(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              false,
              fragmentNames[i],
              fragmentNames[j2]
            );
          }
        }
      }
      return conflicts;
    }
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment
      );
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        fieldMap2
      );
      for (const referencedFragmentName of referencedFragmentNames) {
        if (comparedFragmentPairs.has(
          referencedFragmentName,
          fragmentName,
          areMutuallyExclusive
        )) {
          continue;
        }
        comparedFragmentPairs.add(
          referencedFragmentName,
          fragmentName,
          areMutuallyExclusive
        );
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          referencedFragmentName
        );
      }
    }
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(
        fragmentName1,
        fragmentName2,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      const fragment1 = context.getFragment(fragmentName1);
      const fragment2 = context.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment1
      );
      const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragment2
      );
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const referencedFragmentName2 of referencedFragmentNames2) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          referencedFragmentName2
        );
      }
      for (const referencedFragmentName1 of referencedFragmentNames1) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          referencedFragmentName1,
          fragmentName2
        );
      }
    }
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      const conflicts = [];
      const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType1,
        selectionSet1
      );
      const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        parentType2,
        selectionSet2
      );
      collectConflictsBetween(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fragmentName2
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap2,
          fragmentName1
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            fragmentName2
          );
        }
      }
      return conflicts;
    }
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
      for (const [responseName, fields] of Object.entries(fieldMap)) {
        if (fields.length > 1) {
          for (let i = 0; i < fields.length; i++) {
            for (let j2 = i + 1; j2 < fields.length; j2++) {
              const conflict = findConflict(
                context,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                false,
                // within one collection is never mutually exclusive
                responseName,
                fields[i],
                fields[j2]
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (const [responseName, fields1] of Object.entries(fieldMap1)) {
        const fields2 = fieldMap2[responseName];
        if (fields2) {
          for (const field1 of fields1) {
            for (const field2 of fields2) {
              const conflict = findConflict(
                context,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                parentFieldsAreMutuallyExclusive,
                responseName,
                field1,
                field2
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      const [parentType1, node1, def1] = field1;
      const [parentType2, node2, def2] = field2;
      const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
          return [
            [responseName, `"${name1}" and "${name2}" are different fields`],
            [node1],
            [node2]
          ];
        }
        if (stringifyArguments(node1) !== stringifyArguments(node2)) {
          return [
            [responseName, "they have differing arguments"],
            [node1],
            [node2]
          ];
        }
      }
      const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
          [
            responseName,
            `they return conflicting types "${(0, _inspect.inspect)(
              type1
            )}" and "${(0, _inspect.inspect)(type2)}"`
          ],
          [node1],
          [node2]
        ];
      }
      const selectionSet1 = node1.selectionSet;
      const selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(
          context,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          (0, _definition.getNamedType)(type1),
          selectionSet1,
          (0, _definition.getNamedType)(type2),
          selectionSet2
        );
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    function stringifyArguments(fieldNode) {
      var _fieldNode$arguments;
      const args = (
        /* c8 ignore next */
        (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
      );
      const inputObjectWithArgs = {
        kind: _kinds.Kind.OBJECT,
        fields: args.map((argNode) => ({
          kind: _kinds.Kind.OBJECT_FIELD,
          name: argNode.name,
          value: argNode.value
        }))
      };
      return (0, _printer.print)(
        (0, _sortValueNode.sortValueNode)(inputObjectWithArgs)
      );
    }
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      const cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (cached) {
        return cached;
      }
      const nodeAndDefs = /* @__PURE__ */ Object.create(null);
      const fragmentNames = /* @__PURE__ */ Object.create(null);
      _collectFieldsAndFragmentNames(
        context,
        parentType,
        selectionSet,
        nodeAndDefs,
        fragmentNames
      );
      const result = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, result);
      return result;
    }
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
      const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      const fragmentType = (0, _typeFromAST.typeFromAST)(
        context.getSchema(),
        fragment.typeCondition
      );
      return getFieldsAndFragmentNames(
        context,
        cachedFieldsAndFragmentNames,
        fragmentType,
        fragment.selectionSet
      );
    }
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            const fieldName = selection.name.value;
            let fieldDef;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            const responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            const typeCondition = selection.typeCondition;
            const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(
              context,
              inlineFragmentType,
              selection.selectionSet,
              nodeAndDefs,
              fragmentNames
            );
            break;
          }
        }
      }
    }
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [
          [responseName, conflicts.map(([reason]) => reason)],
          [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
          [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
        ];
      }
    }
    var PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b2, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b2 ? [a, b2] : [b2, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b2, areMutuallyExclusive) {
        const [key1, key2] = a < b2 ? [a, b2] : [b2, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function PossibleFragmentSpreadsRule(context) {
      return {
        InlineFragment(node) {
          const fragType = context.getType();
          const parentType = context.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
            context.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        FragmentSpread(node) {
          const fragName = node.name.value;
          const fragType = getFragmentType(context, fragName);
          const parentType = context.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
            context.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    function getFragmentType(context, name) {
      const frag = context.getFragment(name);
      if (frag) {
        const type = (0, _typeFromAST.typeFromAST)(
          context.getSchema(),
          frag.typeCondition
        );
        if ((0, _definition.isCompositeType)(type)) {
          return type;
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    function PossibleTypeExtensionsRule(context) {
      const schema2 = context.getSchema();
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema2 === null || schema2 === void 0 ? void 0 : schema2.getType(typeName);
        let expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            const kindStr = extensionKindToTypeName(node.kind);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend non-${kindStr} type "${typeName}".`,
                {
                  nodes: defNode ? [defNode, node] : node
                }
              )
            );
          }
        } else {
          const allTypeNames = Object.keys({
            ...definedTypes,
            ...schema2 === null || schema2 === void 0 ? void 0 : schema2.getTypeMap()
          });
          const suggestedTypes = (0, _suggestionList.suggestionList)(
            typeName,
            allTypeNames
          );
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
              {
                nodes: node.name
              }
            )
          );
        }
      }
    }
    var defKindToExtKind = {
      [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
      [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
      [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type) {
      if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(kind)
          );
      }
    }
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    function ProvidedRequiredArgumentsRule(context) {
      return {
        // eslint-disable-next-line new-cap
        ...ProvidedRequiredArgumentsOnDirectivesRule(context),
        Field: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(fieldNode) {
            var _fieldNode$arguments;
            const fieldDef = context.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            const providedArgs = new Set(
              // FIXME: https://github.com/graphql/graphql-js/issues/2203
              /* c8 ignore next */
              (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
            );
            for (const argDef of fieldDef.args) {
              if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                const argTypeStr = (0, _inspect.inspect)(argDef.type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                    {
                      nodes: fieldNode
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
      var _schema$getDirectives;
      const requiredArgsMap = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === void 0 ? void 0 : schema2.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
          directive.args.filter(_definition.isRequiredArgument),
          (arg) => arg.name
        );
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
            argNodes.filter(isRequiredArgumentNode),
            (arg) => arg.name.value
          );
        }
      }
      return {
        Directive: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(directiveNode) {
            const directiveName = directiveNode.name.value;
            const requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
              for (const [argName, argDef] of Object.entries(requiredArgs)) {
                if (!argNodeMap.has(argName)) {
                  const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                      {
                        nodes: directiveNode
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function ScalarLeafsRule(context) {
      return {
        Field(node) {
          const type = context.getType();
          const selectionSet = node.selectionSet;
          if (type) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
              if (selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                    {
                      nodes: selectionSet
                    }
                  )
                );
              }
            } else if (!selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/graphql/jsutils/printPathArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printPathArray = printPathArray2;
    function printPathArray2(path) {
      return path.map(
        (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
      ).join("");
    }
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/graphql/jsutils/Path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addPath = addPath2;
    exports2.pathToArray = pathToArray2;
    function addPath2(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    function pathToArray2(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.coerceInputValue = coerceInputValue2;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _Path = require_Path();
    var _printPathArray = require_printPathArray();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function coerceInputValue2(inputValue, type, onError = defaultOnError) {
      return coerceInputValueImpl(inputValue, type, onError, void 0);
    }
    function defaultOnError(path, invalidValue, error) {
      let errorPrefix2 = "Invalid value " + (0, _inspect.inspect)(invalidValue);
      if (path.length > 0) {
        errorPrefix2 += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
      }
      error.message = errorPrefix2 + ": " + error.message;
      throw error;
    }
    function coerceInputValueImpl(inputValue, type, onError, path) {
      if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError(
          (0, _Path.pathToArray)(path),
          inputValue,
          new _GraphQLError.GraphQLError(
            `Expected non-nullable type "${(0, _inspect.inspect)(
              type
            )}" not to be null.`
          )
        );
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
          return Array.from(inputValue, (itemValue, index) => {
            const itemPath = (0, _Path.addPath)(path, index, void 0);
            return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
          });
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected type "${type.name}" to be an object.`
            )
          );
          return;
        }
        const coercedValue = {};
        const fieldDefs = type.getFields();
        for (const field of Object.values(fieldDefs)) {
          const fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              const typeStr = (0, _inspect.inspect)(field.type);
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${field.name}" of required type "${typeStr}" was not provided.`
                )
              );
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(
            fieldValue,
            field.type,
            onError,
            (0, _Path.addPath)(path, field.name, type.name)
          );
        }
        for (const fieldName of Object.keys(inputValue)) {
          if (!fieldDefs[fieldName]) {
            const suggestions = (0, _suggestionList.suggestionList)(
              fieldName,
              Object.keys(type.getFields())
            );
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)
              )
            );
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type)) {
        let parseResult;
        try {
          parseResult = type.parseValue(inputValue);
        } catch (error) {
          if (error instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error);
          } else {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type.name}". ` + error.message,
                {
                  originalError: error
                }
              )
            );
          }
          return;
        }
        if (parseResult === void 0) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(`Expected type "${type.name}".`)
          );
        }
        return parseResult;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/graphql/utilities/valueFromAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromAST = valueFromAST3;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _kinds = require_kinds();
    var _definition = require_definition();
    function valueFromAST3(valueNode, type, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST3(valueNode, type.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        const itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          const coercedValues = [];
          for (const itemNode of valueNode.values) {
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              const itemValue = valueFromAST3(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        const coercedValue = valueFromAST3(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        const coercedObj = /* @__PURE__ */ Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(
          valueNode.fields,
          (field) => field.name.value
        );
        for (const field of Object.values(type.getFields())) {
          const fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          const fieldValue = valueFromAST3(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type)) {
        let result;
        try {
          result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type)
      );
    }
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/graphql/execution/values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getArgumentValues = getArgumentValues2;
    exports2.getDirectiveValues = getDirectiveValues3;
    exports2.getVariableValues = getVariableValues2;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _printPathArray = require_printPathArray();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _coerceInputValue = require_coerceInputValue();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    function getVariableValues2(schema2, varDefNodes, inputs, options) {
      const errors = [];
      const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
      try {
        const coerced = coerceVariableValues2(
          schema2,
          varDefNodes,
          inputs,
          (error) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError(
                "Too many errors processing variables, error limit reached. Execution aborted."
              );
            }
            errors.push(error);
          }
        );
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error) {
        errors.push(error);
      }
      return {
        errors
      };
    }
    function coerceVariableValues2(schema2, varDefNodes, inputs, onError) {
      const coercedValues = {};
      for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema2, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          const varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
              {
                nodes: varDefNode.type
              }
            )
          );
          continue;
        }
        if (!hasOwnProperty2(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
              varDefNode.defaultValue,
              varType
            );
          } else if ((0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                {
                  nodes: varDefNode
                }
              )
            );
          }
          continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
              {
                nodes: varDefNode
              }
            )
          );
          continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
          value,
          varType,
          (path, invalidValue, error) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                path
              )}"`;
            }
            onError(
              new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                nodes: varDefNode,
                originalError: error
              })
            );
          }
        );
      }
      return coercedValues;
    }
    function getArgumentValues2(def, node, variableValues) {
      var _node$arguments;
      const coercedValues = {};
      const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      const argNodeMap = (0, _keyMap.keyMap)(
        argumentNodes,
        (arg) => arg.name.value
      );
      for (const argDef of def.args) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of required type "${(0, _inspect.inspect)(
                argType
              )}" was not provided.`,
              {
                nodes: node
              }
            );
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                {
                  nodes: valueNode
                }
              );
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
              argType
            )}" must not be null.`,
            {
              nodes: valueNode
            }
          );
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(
          valueNode,
          argType,
          variableValues
        );
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" has invalid value ${(0, _printer.print)(
              valueNode
            )}.`,
            {
              nodes: valueNode
            }
          );
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    function getDirectiveValues3(directiveDef, node, variableValues) {
      var _node$directives;
      const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
        (directive) => directive.name.value === directiveDef.name
      );
      if (directiveNode) {
        return getArgumentValues2(directiveDef, directiveNode, variableValues);
      }
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/graphql/execution/collectFields.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.collectFields = collectFields2;
    exports2.collectSubfields = collectSubfields3;
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _directives = require_directives();
    var _typeFromAST = require_typeFromAST();
    var _values = require_values();
    function collectFields2(schema2, fragments, variableValues, runtimeType, selectionSet) {
      const fields = /* @__PURE__ */ new Map();
      collectFieldsImpl2(
        schema2,
        fragments,
        variableValues,
        runtimeType,
        selectionSet,
        fields,
        /* @__PURE__ */ new Set()
      );
      return fields;
    }
    function collectSubfields3(schema2, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl2(
            schema2,
            fragments,
            variableValues,
            returnType,
            node.selectionSet,
            subFieldNodes,
            visitedFragmentNames
          );
        }
      }
      return subFieldNodes;
    }
    function collectFieldsImpl2(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey2(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema2, selection, runtimeType)) {
              continue;
            }
            collectFieldsImpl2(
              schema2,
              fragments,
              variableValues,
              runtimeType,
              selection.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema2, fragment, runtimeType)) {
              continue;
            }
            collectFieldsImpl2(
              schema2,
              fragments,
              variableValues,
              runtimeType,
              fragment.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
        }
      }
    }
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, _values.getDirectiveValues)(
        _directives.GraphQLSkipDirective,
        node,
        variableValues
      );
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      const include = (0, _values.getDirectiveValues)(
        _directives.GraphQLIncludeDirective,
        node,
        variableValues
      );
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch2(schema2, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, _typeFromAST.typeFromAST)(
        schema2,
        typeConditionNode
      );
      if (conditionalType === type) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema2.isSubType(conditionalType, type);
      }
      return false;
    }
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _collectFields = require_collectFields();
    function SingleFieldSubscriptionsRule(context) {
      return {
        OperationDefinition(node) {
          if (node.operation === "subscription") {
            const schema2 = context.getSchema();
            const subscriptionType = schema2.getSubscriptionType();
            if (subscriptionType) {
              const operationName = node.name ? node.name.value : null;
              const variableValues = /* @__PURE__ */ Object.create(null);
              const document2 = context.getDocument();
              const fragments = /* @__PURE__ */ Object.create(null);
              for (const definition of document2.definitions) {
                if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                  fragments[definition.name.value] = definition;
                }
              }
              const fields = (0, _collectFields.collectFields)(
                schema2,
                fragments,
                variableValues,
                subscriptionType,
                node.selectionSet
              );
              if (fields.size > 1) {
                const fieldSelectionLists = [...fields.values()];
                const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                const extraFieldSelections = extraFieldSelectionLists.flat();
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                    {
                      nodes: extraFieldSelections
                    }
                  )
                );
              }
              for (const fieldNodes of fields.values()) {
                const field = fieldNodes[0];
                const fieldName = field.name.value;
                if (fieldName.startsWith("__")) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                      {
                        nodes: fieldNodes
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/graphql/jsutils/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.groupBy = groupBy;
    function groupBy(list, keyFn) {
      const result = /* @__PURE__ */ new Map();
      for (const item of list) {
        const key = keyFn(item);
        const group = result.get(key);
        if (group === void 0) {
          result.set(key, [item]);
        } else {
          group.push(item);
        }
      }
      return result;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentDefinitionNamesRule(context) {
      return {
        DirectiveDefinition(directiveNode) {
          var _directiveNode$argume;
          const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
      };
      function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value;
        const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes) {
          var _fieldDef$arguments;
          const fieldName = fieldDef.name.value;
          const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
          checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
      }
      function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Argument "${parentName}(${argName}:)" can only be defined once.`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context) {
      return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
      };
      function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one argument named "${argName}".`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context) {
      const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      return {
        DirectiveDefinition(node) {
          const directiveName = node.name.value;
          if (schema2 !== null && schema2 !== void 0 && schema2.getDirective(directiveName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one directive named "@${directiveName}".`,
                {
                  nodes: [knownDirectiveNames[directiveName], node.name]
                }
              )
            );
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context) {
      const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      const definedDirectives = schema2 ? schema2.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      const astDefinitions = context.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      const schemaDirectives = /* @__PURE__ */ Object.create(null);
      const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter(node) {
          if (!("directives" in node) || !node.directives) {
            return;
          }
          let seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            const typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `The directive "@${directiveName}" can only be used once at this location.`,
                    {
                      nodes: [seenDirectives[directiveName], directive]
                    }
                  )
                );
              } else {
                seenDirectives[directiveName] = directive;
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context) {
      const schema2 = context.getSchema();
      const existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes) {
          const valueName = valueDef.name.value;
          const existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: valueDef.name
                }
              )
            );
          } else if (valueNames[valueName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" can only be defined once.`,
                {
                  nodes: [valueNames[valueName], valueDef.name]
                }
              )
            );
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context) {
      const schema2 = context.getSchema();
      const existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes) {
          const fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: fieldDef.name
                }
              )
            );
          } else if (fieldNames[fieldName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" can only be defined once.`,
                {
                  nodes: [fieldNames[fieldName], fieldDef.name]
                }
              )
            );
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
    }
    function hasField(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context) {
      const knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(node) {
          const fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one fragment named "${fragmentName}".`,
                {
                  nodes: [knownFragmentNames[fragmentName], node.name]
                }
              )
            );
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context) {
      const knownNameStack = [];
      let knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave() {
            const prevKnownNames = knownNameStack.pop();
            prevKnownNames || (0, _invariant.invariant)(false);
            knownNames = prevKnownNames;
          }
        },
        ObjectField(node) {
          const fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one input field named "${fieldName}".`,
                {
                  nodes: [knownNames[fieldName], node.name]
                }
              )
            );
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context) {
      const knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition(node) {
          const operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one operation named "${operationName.value}".`,
                  {
                    nodes: [
                      knownOperationNames[operationName.value],
                      operationName
                    ]
                  }
                )
              );
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: () => false
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context) {
      const schema2 = context.getSchema();
      const definedOperationTypes = /* @__PURE__ */ Object.create(null);
      const existingOperationTypes = schema2 ? {
        query: schema2.getQueryType(),
        mutation: schema2.getMutationType(),
        subscription: schema2.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          const operation = operationType.operation;
          const alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                {
                  nodes: operationType
                }
              )
            );
          } else if (alreadyDefinedOperationType) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one ${operation} type in schema.`,
                {
                  nodes: [alreadyDefinedOperationType, operationType]
                }
              )
            );
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context) {
      const knownTypeNames = /* @__PURE__ */ Object.create(null);
      const schema2 = context.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema2 !== null && schema2 !== void 0 && schema2.getType(typeName)) {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownTypeNames[typeName]) {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `There can be only one type named "${typeName}".`,
              {
                nodes: [knownTypeNames[typeName], node.name]
              }
            )
          );
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context) {
      return {
        OperationDefinition(operationNode) {
          var _operationNode$variab;
          const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
          const seenVariableDefinitions = (0, _groupBy.groupBy)(
            variableDefinitions,
            (node) => node.variable.name.value
          );
          for (const [variableName, variableNodes] of seenVariableDefinitions) {
            if (variableNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one variable named "$${variableName}".`,
                  {
                    nodes: variableNodes.map((node) => node.variable.name)
                  }
                )
              );
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    function ValuesOfCorrectTypeRule(context) {
      return {
        ListValue(node) {
          const type = (0, _definition.getNullableType)(
            context.getParentInputType()
          );
          if (!(0, _definition.isListType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
        },
        ObjectValue(node) {
          const type = (0, _definition.getNamedType)(context.getInputType());
          if (!(0, _definition.isInputObjectType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
          const fieldNodeMap = (0, _keyMap.keyMap)(
            node.fields,
            (field) => field.name.value
          );
          for (const fieldDef of Object.values(type.getFields())) {
            const fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              const typeStr = (0, _inspect.inspect)(fieldDef.type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        ObjectField(node) {
          const parentType = (0, _definition.getNamedType)(
            context.getParentInputType()
          );
          const fieldType = context.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            const suggestions = (0, _suggestionList.suggestionList)(
              node.name.value,
              Object.keys(parentType.getFields())
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: node
                }
              )
            );
          }
        },
        NullValue(node) {
          const type = context.getInputType();
          if ((0, _definition.isNonNullType)(type)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${(0, _inspect.inspect)(
                  type
                )}", found ${(0, _printer.print)(node)}.`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        EnumValue: (node) => isValidValueNode(context, node),
        IntValue: (node) => isValidValueNode(context, node),
        FloatValue: (node) => isValidValueNode(context, node),
        StringValue: (node) => isValidValueNode(context, node),
        BooleanValue: (node) => isValidValueNode(context, node)
      };
    }
    function isValidValueNode(context, node) {
      const locationType = context.getInputType();
      if (!locationType) {
        return;
      }
      const type = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context.reportError(
          new _GraphQLError.GraphQLError(
            `Expected value of type "${typeStr}", found ${(0, _printer.print)(
              node
            )}.`,
            {
              nodes: node
            }
          )
        );
        return;
      }
      try {
        const parseResult = type.parseLiteral(
          node,
          void 0
          /* variables */
        );
        if (parseResult === void 0) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
        }
      } catch (error) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error instanceof _GraphQLError.GraphQLError) {
          context.reportError(error);
        } else {
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}; ` + error.message,
              {
                nodes: node,
                originalError: error
              }
            )
          );
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context) {
      return {
        VariableDefinition(node) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            node.type
          );
          if (type !== void 0 && !(0, _definition.isInputType)(type)) {
            const variableName = node.variable.name.value;
            const typeName = (0, _printer.print)(node.type);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                {
                  nodes: node.type
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function VariablesInAllowedPositionRule(context) {
      let varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context.getRecursiveVariableUsages(operation);
            for (const { node, type, defaultValue } of usages) {
              const varName = node.name.value;
              const varDef = varDefMap[varName];
              if (varDef && type) {
                const schema2 = context.getSchema();
                const varType = (0, _typeFromAST.typeFromAST)(schema2, varDef.type);
                if (varType && !allowedVariableUsage(
                  schema2,
                  varType,
                  varDef.defaultValue,
                  type,
                  defaultValue
                )) {
                  const varTypeStr = (0, _inspect.inspect)(varType);
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
              }
            }
          }
        },
        VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    function allowedVariableUsage(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(
          schema2,
          varType,
          nullableLocationType
        );
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema2, varType, locationType);
    }
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/graphql/validation/specifiedRules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.specifiedSDLRules = exports2.specifiedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var specifiedRules2 = Object.freeze([
      _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
      _UniqueOperationNamesRule.UniqueOperationNamesRule,
      _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
      _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
      _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
      _ScalarLeafsRule.ScalarLeafsRule,
      _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
      _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
      _KnownFragmentNamesRule.KnownFragmentNamesRule,
      _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
      _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
      _NoFragmentCyclesRule.NoFragmentCyclesRule,
      _UniqueVariableNamesRule.UniqueVariableNamesRule,
      _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
      _NoUnusedVariablesRule.NoUnusedVariablesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _KnownArgumentNamesRule.KnownArgumentNamesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
      _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
      _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
    ]);
    exports2.specifiedRules = specifiedRules2;
    var specifiedSDLRules = Object.freeze([
      _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
      _UniqueOperationTypesRule.UniqueOperationTypesRule,
      _UniqueTypeNamesRule.UniqueTypeNamesRule,
      _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
      _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
      _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
      _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
      _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    exports2.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/graphql/validation/ValidationContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    var ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    exports2.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema2, onError) {
        super(ast, onError);
        this._schema = schema2;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    exports2.SDLValidationContext = SDLValidationContext;
    var ValidationContext = class extends ASTValidationContext {
      constructor(schema2, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema2;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(
            node,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
    exports2.ValidationContext = ValidationContext;
  }
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/graphql/validation/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSDL = assertValidSDL;
    exports2.assertValidSDLExtension = assertValidSDLExtension;
    exports2.validate = validate2;
    exports2.validateSDL = validateSDL;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function validate2(schema2, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema2)) {
      var _options$maxErrors;
      const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
      documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema2);
      const abortObj = Object.freeze({});
      const errors = [];
      const context = new _ValidationContext.ValidationContext(
        schema2,
        documentAST,
        typeInfo,
        (error) => {
          if (errors.length >= maxErrors) {
            errors.push(
              new _GraphQLError.GraphQLError(
                "Too many validation errors, error limit reached. Validation aborted."
              )
            );
            throw abortObj;
          }
          errors.push(error);
        }
      );
      const visitor = (0, _visitor.visitInParallel)(
        rules.map((rule) => rule(context))
      );
      try {
        (0, _visitor.visit)(
          documentAST,
          (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
        );
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
      const errors = [];
      const context = new _ValidationContext.SDLValidationContext(
        documentAST,
        schemaToExtend,
        (error) => {
          errors.push(error);
        }
      );
      const visitors = rules.map((rule) => rule(context));
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    function assertValidSDL(documentAST) {
      const errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
    function assertValidSDLExtension(documentAST, schema2) {
      const errors = validateSDL(documentAST, schema2);
      if (errors.length !== 0) {
        throw new Error(errors.map((error) => error.message).join("\n\n"));
      }
    }
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/graphql/jsutils/memoize3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.memoize3 = memoize32;
    function memoize32(fn2) {
      let cache0;
      return function memoized(a1, a2, a3) {
        if (cache0 === void 0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === void 0) {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === void 0) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === void 0) {
          fnResult = fn2(a1, a2, a3);
          cache2.set(a3, fnResult);
        }
        return fnResult;
      };
    }
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/graphql/jsutils/promiseForObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseForObject = promiseForObject2;
    function promiseForObject2(object) {
      return Promise.all(Object.values(object)).then((resolvedValues) => {
        const resolvedObject = /* @__PURE__ */ Object.create(null);
        for (const [i, key] of Object.keys(object).entries()) {
          resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
      });
    }
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/graphql/jsutils/promiseReduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseReduce = promiseReduce2;
    var _isPromise = require_isPromise();
    function promiseReduce2(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
  }
});

// node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS({
  "node_modules/graphql/jsutils/toError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toError = toError;
    var _inspect = require_inspect();
    function toError(thrownValue) {
      return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    var NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/graphql/error/locatedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatedError = locatedError2;
    var _toError = require_toError();
    var _GraphQLError = require_GraphQLError();
    function locatedError2(rawOriginalError, nodes, path) {
      var _nodes;
      const originalError = (0, _toError.toError)(rawOriginalError);
      if (isLocatedGraphQLError(originalError)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
      });
    }
    function isLocatedGraphQLError(error) {
      return Array.isArray(error.path);
    }
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/graphql/execution/execute.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidExecutionArguments = assertValidExecutionArguments;
    exports2.buildExecutionContext = buildExecutionContext2;
    exports2.buildResolveInfo = buildResolveInfo2;
    exports2.defaultTypeResolver = exports2.defaultFieldResolver = void 0;
    exports2.execute = execute2;
    exports2.executeSync = executeSync;
    exports2.getFieldDef = getFieldDef2;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _isPromise = require_isPromise();
    var _memoize = require_memoize3();
    var _Path = require_Path();
    var _promiseForObject = require_promiseForObject();
    var _promiseReduce = require_promiseReduce();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _collectFields = require_collectFields();
    var _values = require_values();
    var collectSubfields3 = (0, _memoize.memoize3)(
      (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    function execute2(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const { schema: schema2, document: document2, variableValues, rootValue } = args;
      assertValidExecutionArguments(schema2, document2, variableValues);
      const exeContext = buildExecutionContext2(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const { operation } = exeContext;
        const result = executeOperation2(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
          return result.then(
            (data) => buildResponse2(data, exeContext.errors),
            (error) => {
              exeContext.errors.push(error);
              return buildResponse2(null, exeContext.errors);
            }
          );
        }
        return buildResponse2(result, exeContext.errors);
      } catch (error) {
        exeContext.errors.push(error);
        return buildResponse2(null, exeContext.errors);
      }
    }
    function executeSync(args) {
      const result = execute2(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function buildResponse2(data, errors) {
      return errors.length === 0 ? {
        data
      } : {
        errors,
        data
      };
    }
    function assertValidExecutionArguments(schema2, document2, rawVariableValues) {
      document2 || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema2);
      rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
        false,
        "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
      );
    }
    function buildExecutionContext2(args) {
      var _definition$name, _operation$variableDe;
      const {
        schema: schema2,
        document: document2,
        rootValue,
        contextValue,
        variableValues: rawVariableValues,
        operationName,
        fieldResolver,
        typeResolver,
        subscribeFieldResolver
      } = args;
      let operation;
      const fragments = /* @__PURE__ */ Object.create(null);
      for (const definition of document2.definitions) {
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [
                  new _GraphQLError.GraphQLError(
                    "Must provide operation name if query contains multiple operations."
                  )
                ];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
          default:
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [
            new _GraphQLError.GraphQLError(
              `Unknown operation named "${operationName}".`
            )
          ];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      const coercedVariableValues = (0, _values.getVariableValues)(
        schema2,
        variableDefinitions,
        rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
        {
          maxErrors: 50
        }
      );
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema: schema2,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver3,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver2,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver3,
        errors: []
      };
    }
    function executeOperation2(exeContext, operation, rootValue) {
      const rootType = exeContext.schema.getRootType(operation.operation);
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          `Schema is not configured to execute ${operation.operation} operation.`,
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        rootType,
        operation.selectionSet
      );
      const path = void 0;
      switch (operation.operation) {
        case _ast.OperationTypeNode.QUERY:
          return executeFields2(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
          return executeFieldsSerially2(
            exeContext,
            rootType,
            rootValue,
            path,
            rootFields
          );
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return executeFields2(exeContext, rootType, rootValue, path, rootFields);
      }
    }
    function executeFieldsSerially2(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.promiseReduce)(
        fields.entries(),
        (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField2(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        },
        /* @__PURE__ */ Object.create(null)
      );
    }
    function executeFields2(exeContext, parentType, sourceValue, path, fields) {
      const results = /* @__PURE__ */ Object.create(null);
      let containsPromise = false;
      try {
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField2(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
      } catch (error) {
        if (containsPromise) {
          return (0, _promiseForObject.promiseForObject)(results).finally(() => {
            throw error;
          });
        }
        throw error;
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.promiseForObject)(results);
    }
    function executeField2(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
      if (!fieldDef) {
        return;
      }
      const returnType = fieldDef.type;
      const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      const info = buildResolveInfo2(
        exeContext,
        fieldDef,
        fieldNodes,
        parentType,
        path
      );
      try {
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          exeContext.variableValues
        );
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
          completed = result.then(
            (resolved) => completeValue2(exeContext, returnType, fieldNodes, info, path, resolved)
          );
        } else {
          completed = completeValue2(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          );
        }
        if ((0, _isPromise.isPromise)(completed)) {
          return completed.then(void 0, (rawError) => {
            const error = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(path)
            );
            return handleFieldError2(error, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        const error = (0, _locatedError.locatedError)(
          rawError,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
        return handleFieldError2(error, returnType, exeContext);
      }
    }
    function buildResolveInfo2(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    function handleFieldError2(error, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error;
      }
      exeContext.errors.push(error);
      return null;
    }
    function completeValue2(exeContext, returnType, fieldNodes, info, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue2(
          exeContext,
          returnType.ofType,
          fieldNodes,
          info,
          path,
          result
        );
        if (completed === null) {
          throw new Error(
            `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
          );
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue2(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue2(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue2(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue2(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      (0, _invariant.invariant)(
        false,
        "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
      );
    }
    function completeListValue2(exeContext, returnType, fieldNodes, info, path, result) {
      if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(
          `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
        );
      }
      const itemType = returnType.ofType;
      let containsPromise = false;
      const completedResults = Array.from(result, (item, index) => {
        const itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          let completedItem;
          if ((0, _isPromise.isPromise)(item)) {
            completedItem = item.then(
              (resolved) => completeValue2(
                exeContext,
                itemType,
                fieldNodes,
                info,
                itemPath,
                resolved
              )
            );
          } else {
            completedItem = completeValue2(
              exeContext,
              itemType,
              fieldNodes,
              info,
              itemPath,
              item
            );
          }
          if ((0, _isPromise.isPromise)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, (rawError) => {
              const error = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(itemPath)
              );
              return handleFieldError2(error, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          const error = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(itemPath)
          );
          return handleFieldError2(error, itemType, exeContext);
        }
      });
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    function completeLeafValue2(returnType, result) {
      const serializedResult = returnType.serialize(result);
      if (serializedResult == null) {
        throw new Error(
          `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
            serializedResult
          )}`
        );
      }
      return serializedResult;
    }
    function completeAbstractValue2(exeContext, returnType, fieldNodes, info, path, result) {
      var _returnType$resolveTy;
      const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      const contextValue = exeContext.contextValue;
      const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
      if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then(
          (resolvedRuntimeType) => completeObjectValue2(
            exeContext,
            ensureValidRuntimeType2(
              resolvedRuntimeType,
              exeContext,
              returnType,
              fieldNodes,
              info,
              result
            ),
            fieldNodes,
            info,
            path,
            result
          )
        );
      }
      return completeObjectValue2(
        exeContext,
        ensureValidRuntimeType2(
          runtimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      );
    }
    function ensureValidRuntimeType2(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
      if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
          fieldNodes
        );
      }
      if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError(
          "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
        );
      }
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
        );
      }
      const runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      return runtimeType;
    }
    function completeObjectValue2(exeContext, returnType, fieldNodes, info, path, result) {
      const subFieldNodes = collectSubfields3(exeContext, returnType, fieldNodes);
      if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
          return isTypeOf.then((resolvedIsTypeOf) => {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError2(returnType, result, fieldNodes);
            }
            return executeFields2(
              exeContext,
              returnType,
              result,
              path,
              subFieldNodes
            );
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError2(returnType, result, fieldNodes);
        }
      }
      return executeFields2(exeContext, returnType, result, path, subFieldNodes);
    }
    function invalidReturnTypeError2(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError(
        `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
        {
          nodes: fieldNodes
        }
      );
    }
    var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
      if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if ((0, _isPromise.isPromise)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    exports2.defaultTypeResolver = defaultTypeResolver2;
    var defaultFieldResolver3 = function(source, args, contextValue, info) {
      if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
    exports2.defaultFieldResolver = defaultFieldResolver3;
    function getFieldDef2(schema2, parentType, fieldNode) {
      const fieldName = fieldNode.name.value;
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "node_modules/graphql/graphql.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.graphql = graphql;
    exports2.graphqlSync = graphqlSync;
    var _devAssert = require_devAssert();
    var _isPromise = require_isPromise();
    var _parser = require_parser();
    var _validate = require_validate();
    var _validate2 = require_validate2();
    var _execute = require_execute();
    function graphql(args) {
      return new Promise((resolve) => resolve(graphqlImpl(args)));
    }
    function graphqlSync(args) {
      const result = graphqlImpl(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function graphqlImpl(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const {
        schema: schema2,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      } = args;
      const schemaValidationErrors = (0, _validate.validateSchema)(schema2);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      let document2;
      try {
        document2 = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      const validationErrors = (0, _validate2.validate)(schema2, document2);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema: schema2,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS({
  "node_modules/graphql/type/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function() {
        return _scalars.GRAPHQL_MAX_INT;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function() {
        return _scalars.GRAPHQL_MIN_INT;
      }
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLFloat;
      }
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLID;
      }
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLInt;
      }
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLList;
      }
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: function() {
        return _schema.GraphQLSchema;
      }
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function() {
        return _directives.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: function() {
        return _scalars.GraphQLString;
      }
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: function() {
        return _definition.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: function() {
        return _introspection.TypeKind;
      }
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _introspection.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: function() {
        return _introspection.__Directive;
      }
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _introspection.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: function() {
        return _introspection.__EnumValue;
      }
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: function() {
        return _introspection.__Field;
      }
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: function() {
        return _introspection.__InputValue;
      }
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: function() {
        return _introspection.__Schema;
      }
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: function() {
        return _introspection.__Type;
      }
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: function() {
        return _introspection.__TypeKind;
      }
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: function() {
        return _definition.assertAbstractType;
      }
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: function() {
        return _definition.assertCompositeType;
      }
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: function() {
        return _directives.assertDirective;
      }
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: function() {
        return _definition.assertEnumType;
      }
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: function() {
        return _assertName.assertEnumValueName;
      }
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.assertInputObjectType;
      }
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: function() {
        return _definition.assertInputType;
      }
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.assertInterfaceType;
      }
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: function() {
        return _definition.assertLeafType;
      }
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: function() {
        return _definition.assertListType;
      }
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: function() {
        return _assertName.assertName;
      }
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: function() {
        return _definition.assertNamedType;
      }
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: function() {
        return _definition.assertNonNullType;
      }
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: function() {
        return _definition.assertNullableType;
      }
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: function() {
        return _definition.assertObjectType;
      }
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: function() {
        return _definition.assertOutputType;
      }
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: function() {
        return _definition.assertScalarType;
      }
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: function() {
        return _schema.assertSchema;
      }
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: function() {
        return _definition.assertType;
      }
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: function() {
        return _definition.assertUnionType;
      }
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: function() {
        return _validate.assertValidSchema;
      }
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: function() {
        return _definition.assertWrappingType;
      }
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: function() {
        return _definition.getNamedType;
      }
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: function() {
        return _definition.getNullableType;
      }
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: function() {
        return _introspection.introspectionTypes;
      }
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: function() {
        return _definition.isAbstractType;
      }
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: function() {
        return _definition.isCompositeType;
      }
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: function() {
        return _directives.isDirective;
      }
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: function() {
        return _definition.isEnumType;
      }
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: function() {
        return _definition.isInputObjectType;
      }
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: function() {
        return _definition.isInputType;
      }
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: function() {
        return _definition.isInterfaceType;
      }
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: function() {
        return _introspection.isIntrospectionType;
      }
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: function() {
        return _definition.isLeafType;
      }
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: function() {
        return _definition.isListType;
      }
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: function() {
        return _definition.isNamedType;
      }
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: function() {
        return _definition.isNonNullType;
      }
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: function() {
        return _definition.isNullableType;
      }
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: function() {
        return _definition.isObjectType;
      }
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: function() {
        return _definition.isOutputType;
      }
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: function() {
        return _definition.isRequiredArgument;
      }
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: function() {
        return _definition.isRequiredInputField;
      }
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: function() {
        return _definition.isScalarType;
      }
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: function() {
        return _schema.isSchema;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: function() {
        return _directives.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: function() {
        return _scalars.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _definition.isType;
      }
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: function() {
        return _definition.isUnionType;
      }
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: function() {
        return _definition.isWrappingType;
      }
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: function() {
        return _definition.resolveObjMapThunk;
      }
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function() {
        return _definition.resolveReadonlyArrayThunk;
      }
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: function() {
        return _directives.specifiedDirectives;
      }
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: function() {
        return _scalars.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: function() {
        return _validate.validateSchema;
      }
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _assertName = require_assertName();
  }
});

// node_modules/graphql/language/index.js
var require_language = __commonJS({
  "node_modules/graphql/language/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: function() {
        return _visitor.BREAK;
      }
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _directiveLocation.DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: function() {
        return _kinds.Kind;
      }
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: function() {
        return _lexer.Lexer;
      }
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: function() {
        return _ast.Location;
      }
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: function() {
        return _ast.OperationTypeNode;
      }
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: function() {
        return _source.Source;
      }
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: function() {
        return _ast.Token;
      }
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: function() {
        return _tokenKind.TokenKind;
      }
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: function() {
        return _visitor.getEnterLeaveForKind;
      }
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: function() {
        return _location.getLocation;
      }
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: function() {
        return _visitor.getVisitFn;
      }
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: function() {
        return _predicates.isConstValueNode;
      }
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isSelectionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function() {
        return _predicates.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: function() {
        return _predicates.isValueNode;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parser.parse;
      }
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: function() {
        return _parser.parseConstValue;
      }
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: function() {
        return _parser.parseType;
      }
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: function() {
        return _parser.parseValue;
      }
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: function() {
        return _printer.print;
      }
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: function() {
        return _printLocation.printLocation;
      }
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: function() {
        return _printLocation.printSourceLocation;
      }
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: function() {
        return _visitor.visit;
      }
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: function() {
        return _visitor.visitInParallel;
      }
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/graphql/jsutils/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = isAsyncIterable4;
    function isAsyncIterable4(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
    }
  }
});

// node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/graphql/execution/mapAsyncIterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapAsyncIterator = mapAsyncIterator3;
    function mapAsyncIterator3(iterable, callback) {
      const iterator = iterable[Symbol.asyncIterator]();
      async function mapResult(result) {
        if (result.done) {
          return result;
        }
        try {
          return {
            value: await callback(result.value),
            done: false
          };
        } catch (error) {
          if (typeof iterator.return === "function") {
            try {
              await iterator.return();
            } catch (_e2) {
            }
          }
          throw error;
        }
      }
      return {
        async next() {
          return mapResult(await iterator.next());
        },
        async return() {
          return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
            value: void 0,
            done: true
          };
        },
        async throw(error) {
          if (typeof iterator.throw === "function") {
            return mapResult(await iterator.throw(error));
          }
          throw error;
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
  }
});

// node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/graphql/execution/subscribe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSourceEventStream = createSourceEventStream;
    exports2.subscribe = subscribe2;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isAsyncIterable = require_isAsyncIterable();
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _collectFields = require_collectFields();
    var _execute = require_execute();
    var _mapAsyncIterator = require_mapAsyncIterator();
    var _values = require_values();
    async function subscribe2(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const resultOrStream = await createSourceEventStream(args);
      if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
      }
      const mapSourceToResponse2 = (payload) => (0, _execute.execute)({ ...args, rootValue: payload });
      return (0, _mapAsyncIterator.mapAsyncIterator)(
        resultOrStream,
        mapSourceToResponse2
      );
    }
    function toNormalizedArgs(args) {
      const firstArg = args[0];
      if (firstArg && "document" in firstArg) {
        return firstArg;
      }
      return {
        schema: firstArg,
        // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        subscribeFieldResolver: args[6]
      };
    }
    async function createSourceEventStream(...rawArgs) {
      const args = toNormalizedArgs(rawArgs);
      const { schema: schema2, document: document2, variableValues } = args;
      (0, _execute.assertValidExecutionArguments)(schema2, document2, variableValues);
      const exeContext = (0, _execute.buildExecutionContext)(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const eventStream = await executeSubscription2(exeContext);
        if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
          throw new Error(
            `Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`
          );
        }
        return eventStream;
      } catch (error) {
        if (error instanceof _GraphQLError.GraphQLError) {
          return {
            errors: [error]
          };
        }
        throw error;
      }
    }
    async function executeSubscription2(exeContext) {
      const { schema: schema2, fragments, operation, variableValues, rootValue } = exeContext;
      const rootType = schema2.getSubscriptionType();
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          "Schema is not configured to execute subscription operation.",
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        schema2,
        fragments,
        variableValues,
        rootType,
        operation.selectionSet
      );
      const [responseName, fieldNodes] = [...rootFields.entries()][0];
      const fieldDef = (0, _execute.getFieldDef)(schema2, rootType, fieldNodes[0]);
      if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new _GraphQLError.GraphQLError(
          `The subscription field "${fieldName}" is not defined.`,
          {
            nodes: fieldNodes
          }
        );
      }
      const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
      const info = (0, _execute.buildResolveInfo)(
        exeContext,
        fieldDef,
        fieldNodes,
        rootType,
        path
      );
      try {
        var _fieldDef$subscribe;
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          variableValues
        );
        const contextValue = exeContext.contextValue;
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info);
        if (eventStream instanceof Error) {
          throw eventStream;
        }
        return eventStream;
      } catch (error) {
        throw (0, _locatedError.locatedError)(
          error,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
      }
    }
  }
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "node_modules/graphql/execution/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: function() {
        return _subscribe.createSourceEventStream;
      }
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: function() {
        return _execute.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: function() {
        return _execute.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: function() {
        return _execute.execute;
      }
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: function() {
        return _execute.executeSync;
      }
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: function() {
        return _values.getArgumentValues;
      }
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: function() {
        return _values.getDirectiveValues;
      }
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: function() {
        return _values.getVariableValues;
      }
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: function() {
        return _Path.pathToArray;
      }
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: function() {
        return _subscribe.subscribe;
      }
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _subscribe = require_subscribe();
    var _values = require_values();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function NoDeprecatedCustomRule(context) {
      return {
        Field(node) {
          const fieldDef = context.getFieldDef();
          const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            const parentType = context.getParentType();
            parentType != null || (0, _invariant.invariant)(false);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        Argument(node) {
          const argDef = context.getArgument();
          const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            const directiveDef = context.getDirective();
            if (directiveDef != null) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            } else {
              const parentType = context.getParentType();
              const fieldDef = context.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        ObjectField(node) {
          const inputObjectDef = (0, _definition.getNamedType)(
            context.getParentInputType()
          );
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            const inputFieldDef = inputObjectDef.getFields()[node.name.value];
            const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        EnumValue(node) {
          const enumValueDef = context.getEnumValue();
          const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            const enumTypeDef = (0, _definition.getNamedType)(
              context.getInputType()
            );
            enumTypeDef != null || (0, _invariant.invariant)(false);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context) {
      return {
        Field(node) {
          const type = (0, _definition.getNamedType)(context.getType());
          if (type && (0, _introspection.isIntrospectionType)(type)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "node_modules/graphql/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: function() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: function() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: function() {
        return _ValidationContext.ValidationContext;
      }
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: function() {
        return _specifiedRules.specifiedRules;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.validate;
      }
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/index.js
var require_error = __commonJS({
  "node_modules/graphql/error/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.GraphQLError;
      }
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.formatError;
      }
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: function() {
        return _locatedError.locatedError;
      }
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: function() {
        return _GraphQLError.printError;
      }
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: function() {
        return _syntaxError.syntaxError;
      }
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(options) {
      const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        ...options
      };
      const descriptions = optionsWithDefault.descriptions ? "description" : "";
      const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
      const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/graphql/utilities/getOperationAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationAST = getOperationAST4;
    var _kinds = require_kinds();
    function getOperationAST4(documentAST, operationName) {
      let operation = null;
      for (const definition of documentAST.definitions) {
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/graphql/utilities/getOperationRootType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema2, operation) {
      if (operation.operation === "query") {
        const queryType = schema2.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError(
            "Schema does not define the required query root type.",
            {
              nodes: operation
            }
          );
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        const mutationType = schema2.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for mutations.",
            {
              nodes: operation
            }
          );
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        const subscriptionType = schema2.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for subscriptions.",
            {
              nodes: operation
            }
          );
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError(
        "Can only have query, mutation and subscription operations.",
        {
          nodes: operation
        }
      );
    }
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/graphql/utilities/introspectionFromSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionFromSchema = introspectionFromSchema;
    var _invariant = require_invariant();
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function introspectionFromSchema(schema2, options) {
      const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        ...options
      };
      const document2 = (0, _parser.parse)(
        (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
      );
      const result = (0, _execute.executeSync)({
        schema: schema2,
        document: document2
      });
      !result.errors && result.data || (0, _invariant.invariant)(false);
      return result.data;
    }
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/graphql/utilities/buildClientSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildClientSchema = buildClientSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _keyValMap = require_keyValMap();
    var _parser = require_parser();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _valueFromAST = require_valueFromAST();
    function buildClientSchema(introspection, options) {
      (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
        false,
        `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
      );
      const schemaIntrospection = introspection.__schema;
      const typeMap = (0, _keyValMap.keyValMap)(
        schemaIntrospection.types,
        (typeIntrospection) => typeIntrospection.name,
        (typeIntrospection) => buildType(typeIntrospection)
      );
      for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ]) {
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          const itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          const nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull(
            (0, _definition.assertNullableType)(nullableType)
          );
        }
        return getNamedType6(typeRef);
      }
      function getNamedType6(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
          throw new Error(
            `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
          );
        }
        const type = typeMap[typeName];
        if (!type) {
          throw new Error(
            `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
          );
        }
        return type;
      }
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType6(typeRef));
      }
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType6(typeRef));
      }
      function buildType(type) {
        if (type != null && type.name != null && type.kind != null) {
          switch (type.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type);
          }
        }
        const typeStr = (0, _inspect.inspect)(type);
        throw new Error(
          `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
        );
      }
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByURL: scalarIntrospection.specifiedByURL
        });
      }
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          const implementingIntrospectionStr = (0, _inspect.inspect)(
            implementingIntrospection
          );
          throw new Error(
            `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
          );
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: () => buildImplementationsList(objectIntrospection),
          fields: () => buildFieldDefMap(objectIntrospection)
        });
      }
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: () => buildImplementationsList(interfaceIntrospection),
          fields: () => buildFieldDefMap(interfaceIntrospection)
        });
      }
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
          throw new Error(
            `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: () => unionIntrospection.possibleTypes.map(getObjectType)
        });
      }
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
          throw new Error(
            `Introspection result missing enumValues: ${enumIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.keyValMap)(
            enumIntrospection.enumValues,
            (valueIntrospection) => valueIntrospection.name,
            (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            })
          )
        });
      }
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          const inputObjectIntrospectionStr = (0, _inspect.inspect)(
            inputObjectIntrospection
          );
          throw new Error(
            `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
        });
      }
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error(
            `Introspection result missing fields: ${(0, _inspect.inspect)(
              typeIntrospection
            )}.`
          );
        }
        return (0, _keyValMap.keyValMap)(
          typeIntrospection.fields,
          (fieldIntrospection) => fieldIntrospection.name,
          buildField
        );
      }
      function buildField(fieldIntrospection) {
        const type = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Introspection must provide output type for fields, but received: ${typeStr}.`
          );
        }
        if (!fieldIntrospection.args) {
          const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
          throw new Error(
            `Introspection result missing field args: ${fieldIntrospectionStr}.`
          );
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(
          inputValueIntrospections,
          (inputValue) => inputValue.name,
          buildInputValue
        );
      }
      function buildInputValue(inputValueIntrospection) {
        const type = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
          const typeStr = (0, _inspect.inspect)(type);
          throw new Error(
            `Introspection must provide input type for arguments, but received: ${typeStr}.`
          );
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
          (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
          type
        ) : void 0;
        return {
          description: inputValueIntrospection.description,
          type,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive args: ${directiveIntrospectionStr}.`
          );
        }
        if (!directiveIntrospection.locations) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
          );
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
    }
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/graphql/utilities/extendSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSchema = extendSchema;
    exports2.extendSchemaImpl = extendSchemaImpl;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _mapValue = require_mapValue();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _values = require_values();
    var _valueFromAST = require_valueFromAST();
    function extendSchema(schema2, documentAST, options) {
      (0, _schema.assertSchema)(schema2);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema2);
      }
      const schemaConfig = schema2.toConfig();
      const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
      return schemaConfig === extendedConfig ? schema2 : new _schema.GraphQLSchema(extendedConfig);
    }
    function extendSchemaImpl(schemaConfig, documentAST, options) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      const typeDefs2 = [];
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directiveDefs = [];
      let schemaDef;
      const schemaExtensions = [];
      for (const def of documentAST.definitions) {
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs2.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          const extendedTypeName = def.name.value;
          const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs2.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      const typeMap = /* @__PURE__ */ Object.create(null);
      for (const existingType of schemaConfig.types) {
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (const typeNode of typeDefs2) {
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      const operationTypes = {
        // Get the extended root operation types.
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        // Then, incorporate schema definition and all schema extensions.
        ...schemaDef && getOperationTypes([schemaDef]),
        ...getOperationTypes(schemaExtensions)
      };
      return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
          ...schemaConfig.directives.map(replaceDirective),
          ...directiveDefs.map(buildDirective)
        ],
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      };
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          args: (0, _mapValue.mapValue)(config2.args, extendArg)
        });
      }
      function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
          return type;
        }
        if ((0, _definition.isScalarType)(type)) {
          return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return extendInputObjectType(type);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
          ...config2,
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, (field) => ({
              ...field,
              type: replaceType(field.type)
            })),
            ...buildInputFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
          ...config2,
          values: { ...config2.values, ...buildEnumValueMap(extensions) },
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config2.specifiedByURL;
        for (const extensionNode of extensions) {
          var _getSpecifiedByURL;
          specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
          ...config2,
          specifiedByURL,
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
          ...config2,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
          ...config2,
          interfaces: () => [
            ...type.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ],
          fields: () => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        const config2 = type.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
          ...config2,
          types: () => [
            ...type.getTypes().map(replaceNamedType),
            ...buildUnionTypes(extensions)
          ],
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      function extendField(field) {
        return {
          ...field,
          type: replaceType(field.type),
          args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
      }
      function extendArg(arg) {
        return { ...arg, type: replaceType(arg.type) };
      }
      function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes) {
          var _node$operationTypes;
          const operationTypesNodes = (
            /* c8 ignore next */
            (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
          );
          for (const operationType of operationTypesNodes) {
            opTypes[operationType.operation] = getNamedType6(operationType.type);
          }
        }
        return opTypes;
      }
      function getNamedType6(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type === void 0) {
          throw new Error(`Unknown type: "${name}".`);
        }
        return type;
      }
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType6(node);
      }
      function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
          // @ts-expect-error
          locations: node.locations.map(({ value }) => value),
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      function buildFieldMap(nodes) {
        const fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields;
          const nodeFields = (
            /* c8 ignore next */
            (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
          );
          for (const field of nodeFields) {
            var _field$description;
            fieldConfigMap[field.name.value] = {
              // Note: While this could make assertions to get the correctly typed
              // value, that would throw immediately while type system validation
              // with validateSchema() will produce more actionable results.
              type: getWrappedType(field.type),
              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      function buildArgumentMap(args) {
        const argsNodes = (
          /* c8 ignore next */
          args !== null && args !== void 0 ? args : []
        );
        const argConfigMap = /* @__PURE__ */ Object.create(null);
        for (const arg of argsNodes) {
          var _arg$description;
          const type = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type,
            description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      function buildInputFieldMap(nodes) {
        const inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields2;
          const fieldsNodes = (
            /* c8 ignore next */
            (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
          );
          for (const field of fieldsNodes) {
            var _field$description2;
            const type = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type,
              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(
                field.defaultValue,
                type
              ),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      function buildEnumValueMap(nodes) {
        const enumValueMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$values;
          const valuesNodes = (
            /* c8 ignore next */
            (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
          );
          for (const value of valuesNodes) {
            var _value$description;
            enumValueMap[value.name.value] = {
              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      function buildInterfaces(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$interfaces$map, _node$interfaces;
            return (
              /* c8 ignore next */
              (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType6)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
            );
          }
        );
      }
      function buildUnionTypes(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$types$map, _node$types;
            return (
              /* c8 ignore next */
              (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType6)) !== null && _node$types$map !== void 0 ? _node$types$map : []
            );
          }
        );
      }
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var _astNode$description;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLObjectType({
              name,
              description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _astNode$description2;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInterfaceType({
              name,
              description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
              interfaces: () => buildInterfaces(allNodes),
              fields: () => buildFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _astNode$description3;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLEnumType({
              name,
              description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
              values: buildEnumValueMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _astNode$description4;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLUnionType({
              name,
              description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
              types: () => buildUnionTypes(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _astNode$description5;
            return new _definition.GraphQLScalarType({
              name,
              description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
              specifiedByURL: getSpecifiedByURL(astNode),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _astNode$description6;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInputObjectType({
              name,
              description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
              fields: () => buildInputFieldMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
        }
      }
    }
    var stdTypeMap = (0, _keyMap.keyMap)(
      [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
      (type) => type.name
    );
    function getDeprecationReason(node) {
      const deprecated = (0, _values.getDirectiveValues)(
        _directives.GraphQLDeprecatedDirective,
        node
      );
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    function getSpecifiedByURL(node) {
      const specifiedBy = (0, _values.getDirectiveValues)(
        _directives.GraphQLSpecifiedByDirective,
        node
      );
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/graphql/utilities/buildASTSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildASTSchema = buildASTSchema2;
    exports2.buildSchema = buildSchema2;
    var _devAssert = require_devAssert();
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _directives = require_directives();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _extendSchema = require_extendSchema();
    function buildASTSchema2(documentAST, options) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      const emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: /* @__PURE__ */ Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
      };
      const config2 = (0, _extendSchema.extendSchemaImpl)(
        emptySchemaConfig,
        documentAST,
        options
      );
      if (config2.astNode == null) {
        for (const type of config2.types) {
          switch (type.name) {
            case "Query":
              config2.query = type;
              break;
            case "Mutation":
              config2.mutation = type;
              break;
            case "Subscription":
              config2.subscription = type;
              break;
          }
        }
      }
      const directives = [
        ...config2.directives,
        // If specified directives were not explicitly declared, add them.
        ..._directives.specifiedDirectives.filter(
          (stdDirective) => config2.directives.every(
            (directive) => directive.name !== stdDirective.name
          )
        )
      ];
      return new _schema.GraphQLSchema({ ...config2, directives });
    }
    function buildSchema2(source, options) {
      const document2 = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
      });
      return buildASTSchema2(document2, {
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
    }
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lexicographicSortSchema = lexicographicSortSchema;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyValMap = require_keyValMap();
    var _naturalCompare = require_naturalCompare();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function lexicographicSortSchema(schema2) {
      const schemaConfig = schema2.toConfig();
      const typeMap = (0, _keyValMap.keyValMap)(
        sortByName(schemaConfig.types),
        (type) => type.name,
        sortNamedType
      );
      return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      });
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      function sortDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          locations: sortBy(config2.locations, (x) => x),
          args: sortArgs(config2.args)
        });
      }
      function sortArgs(args) {
        return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
      }
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type),
          args: field.args && sortArgs(field.args)
        }));
      }
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type)
        }));
      }
      function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
      }
      function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
          return type;
        }
        if ((0, _definition.isObjectType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLObjectType({
            ...config2,
            interfaces: () => sortTypes(config2.interfaces),
            fields: () => sortFields(config2.fields)
          });
        }
        if ((0, _definition.isInterfaceType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLInterfaceType({
            ...config2,
            interfaces: () => sortTypes(config2.interfaces),
            fields: () => sortFields(config2.fields)
          });
        }
        if ((0, _definition.isUnionType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLUnionType({
            ...config2,
            types: () => sortTypes(config2.types)
          });
        }
        if ((0, _definition.isEnumType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLEnumType({
            ...config2,
            values: sortObjMap(config2.values, (value) => value)
          });
        }
        if ((0, _definition.isInputObjectType)(type)) {
          const config2 = type.toConfig();
          return new _definition.GraphQLInputObjectType({
            ...config2,
            fields: () => sortInputFields(config2.fields)
          });
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
    }
    function sortObjMap(map, sortValueFn) {
      const sortedMap = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
        sortedMap[key] = sortValueFn(map[key]);
      }
      return sortedMap;
    }
    function sortByName(array) {
      return sortBy(array, (obj) => obj.name);
    }
    function sortBy(array, mapToKey) {
      return array.slice().sort((obj1, obj2) => {
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
      });
    }
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/graphql/utilities/printSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIntrospectionSchema = printIntrospectionSchema;
    exports2.printSchema = printSchema;
    exports2.printType = printType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _blockString = require_blockString();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    function printSchema(schema2) {
      return printFilteredSchema(
        schema2,
        (n) => !(0, _directives.isSpecifiedDirective)(n),
        isDefinedType
      );
    }
    function printIntrospectionSchema(schema2) {
      return printFilteredSchema(
        schema2,
        _directives.isSpecifiedDirective,
        _introspection.isIntrospectionType
      );
    }
    function isDefinedType(type) {
      return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
    }
    function printFilteredSchema(schema2, directiveFilter, typeFilter) {
      const directives = schema2.getDirectives().filter(directiveFilter);
      const types = Object.values(schema2.getTypeMap()).filter(typeFilter);
      return [
        printSchemaDefinition(schema2),
        ...directives.map((directive) => printDirective(directive)),
        ...types.map((type) => printType(type))
      ].filter(Boolean).join("\n\n");
    }
    function printSchemaDefinition(schema2) {
      if (schema2.description == null && isSchemaOfCommonNames(schema2)) {
        return;
      }
      const operationTypes = [];
      const queryType = schema2.getQueryType();
      if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
      }
      const mutationType = schema2.getMutationType();
      if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
      }
      const subscriptionType = schema2.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
      }
      return printDescription(schema2) + `schema {
${operationTypes.join("\n")}
}`;
    }
    function isSchemaOfCommonNames(schema2) {
      const queryType = schema2.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      const mutationType = schema2.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      const subscriptionType = schema2.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    function printType(type) {
      if ((0, _definition.isScalarType)(type)) {
        return printScalar(type);
      }
      if ((0, _definition.isObjectType)(type)) {
        return printObject(type);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type);
      }
      if ((0, _definition.isUnionType)(type)) {
        return printUnion(type);
      }
      if ((0, _definition.isEnumType)(type)) {
        return printEnum(type);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type);
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    function printScalar(type) {
      return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
    }
    function printImplementedInterfaces(type) {
      const interfaces = type.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
    }
    function printObject(type) {
      return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    function printInterface(type) {
      return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
    }
    function printUnion(type) {
      const types = type.getTypes();
      const possibleTypes = types.length ? " = " + types.join(" | ") : "";
      return printDescription(type) + "union " + type.name + possibleTypes;
    }
    function printEnum(type) {
      const values = type.getValues().map(
        (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
      );
      return printDescription(type) + `enum ${type.name}` + printBlock(values);
    }
    function printInputObject(type) {
      const fields = Object.values(type.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
      );
      return printDescription(type) + `input ${type.name}` + printBlock(fields);
    }
    function printFields(type) {
      const fields = Object.values(type.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
      );
      return printBlock(fields);
    }
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    function printArgs(args, indentation = "") {
      if (args.length === 0) {
        return "";
      }
      if (args.every((arg) => !arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(
        (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
      ).join("\n") + "\n" + indentation + ")";
    }
    function printInputValue(arg) {
      const defaultAST = (0, _astFromValue.astFromValue)(
        arg.defaultValue,
        arg.type
      );
      let argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    function printDirective(directive) {
      return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
      }
      return " @deprecated";
    }
    function printSpecifiedByURL(scalar) {
      if (scalar.specifiedByURL == null) {
        return "";
      }
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
      });
      return ` @specifiedBy(url: ${astValue})`;
    }
    function printDescription(def, indentation = "", firstInBlock = true) {
      const { description } = def;
      if (description == null) {
        return "";
      }
      const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
      });
      const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/graphql/utilities/concatAST.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.concatAST = concatAST;
    var _kinds = require_kinds();
    function concatAST(documents) {
      const definitions = [];
      for (const doc of documents) {
        definitions.push(...doc.definitions);
      }
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
      };
    }
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/graphql/utilities/separateOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      const operations = [];
      const depGraph = /* @__PURE__ */ Object.create(null);
      for (const definitionNode of documentAST.definitions) {
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(
              definitionNode.selectionSet
            );
            break;
          default:
        }
      }
      const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      for (const operation of operations) {
        const dependencies = /* @__PURE__ */ new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)) {
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        const operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(
            (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
          )
        };
      }
      return separatedDocumentASTs;
    }
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (const toName of immediateDeps) {
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    function collectDependencies(selectionSet) {
      const dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stripIgnoredCharacters = stripIgnoredCharacters;
    var _blockString = require_blockString();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function stripIgnoredCharacters(source) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      const body = sourceObj.body;
      const lexer = new _lexer.Lexer(sourceObj);
      let strippedBody = "";
      let wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
          currentToken.kind
        );
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
            minimize: true
          });
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/graphql/utilities/assertValidName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidName = assertValidName;
    exports2.isValidNameError = isValidNameError;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _assertName = require_assertName();
    function assertValidName(name) {
      const error = isValidNameError(name);
      if (error) {
        throw error;
      }
      return name;
    }
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(
          `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
        );
      }
      try {
        (0, _assertName.assertName)(name);
      } catch (error) {
        return error;
      }
    }
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/graphql/utilities/findBreakingChanges.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DangerousChangeType = exports2.BreakingChangeType = void 0;
    exports2.findBreakingChanges = findBreakingChanges;
    exports2.findDangerousChanges = findDangerousChanges;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _printer = require_printer();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    var _sortValueNode = require_sortValueNode();
    var BreakingChangeType;
    exports2.BreakingChangeType = BreakingChangeType;
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(
      BreakingChangeType || (exports2.BreakingChangeType = BreakingChangeType = {})
    );
    var DangerousChangeType;
    exports2.DangerousChangeType = DangerousChangeType;
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(
      DangerousChangeType || (exports2.DangerousChangeType = DangerousChangeType = {})
    );
    function findBreakingChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in BreakingChangeType
      );
    }
    function findDangerousChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in DangerousChangeType
      );
    }
    function findSchemaChanges(oldSchema, newSchema) {
      return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
      ];
    }
    function findDirectiveChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const directivesDiff = diff(
        oldSchema.getDirectives(),
        newSchema.getDirectives()
      );
      for (const oldDirective of directivesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: `${oldDirective.name} was removed.`
        });
      }
      for (const [oldDirective, newDirective] of directivesDiff.persisted) {
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
            });
          }
        }
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: `${oldArg.name} was removed from ${oldDirective.name}.`
          });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: `Repeatable flag was removed from ${oldDirective.name}.`
          });
        }
        for (const location of oldDirective.locations) {
          if (!newDirective.locations.includes(location)) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: `${location} was removed from ${oldDirective.name}.`
            });
          }
        }
      }
      return schemaChanges;
    }
    function findTypeChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const typesDiff = diff(
        Object.values(oldSchema.getTypeMap()),
        Object.values(newSchema.getTypeMap())
      );
      for (const oldType of typesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
      }
      for (const [oldType, newType] of typesDiff.persisted) {
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if (oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findInputObjectTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const newField of fieldsDiff.added) {
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: `A required field ${newField.name} on input type ${oldType.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
          });
        }
      }
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findUnionTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (const newPossibleType of possibleTypesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
      }
      for (const oldPossibleType of possibleTypesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    function findEnumTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (const newValue of valuesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
      }
      for (const oldValue of valuesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    function findImplementedInterfacesChanges(oldType, newType) {
      const schemaChanges = [];
      const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (const newInterface of interfacesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
      }
      for (const oldInterface of interfacesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
      }
      return schemaChanges;
    }
    function findFieldChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    function findArgChanges(oldType, oldField, newField) {
      const schemaChanges = [];
      const argsDiff = diff(oldField.args, newField.args);
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
      }
      for (const [oldArg, newArg] of argsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldArg.type,
          newArg.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
          });
        } else if (oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
            });
          } else {
            const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
            const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
              });
            }
          }
        }
      }
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        }
      }
      return schemaChanges;
    }
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (
          // if they're both lists, make sure the underlying types are compatible
          (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
            oldType.ofType,
            newType.ofType
          ) || // moving from nullable to non-null of the same underlying type is safe
          (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
        );
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (
        // if they're both named types, see if their names are equivalent
        (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
        (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
      );
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (
          // if they're both non-null, make sure the underlying types are
          // compatible
          (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
            oldType.ofType,
            newType.ofType
          ) || // moving from non-null to nullable of the same underlying type is safe
          !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
        );
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    function typeKindName(type) {
      if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type)
      );
    }
    function stringifyValue(value, type) {
      const ast = (0, _astFromValue.astFromValue)(value, type);
      ast != null || (0, _invariant.invariant)(false);
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
    }
    function diff(oldArray, newArray) {
      const added = [];
      const removed = [];
      const persisted = [];
      const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
      const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
      for (const oldItem of oldArray) {
        const newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (const newItem of newArray) {
        if (oldMap[newItem.name] === void 0) {
          added.push(newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/graphql/utilities/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.BreakingChangeType;
      }
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.DangerousChangeType;
      }
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.TypeInfo;
      }
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: function() {
        return _assertValidName.assertValidName;
      }
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: function() {
        return _astFromValue.astFromValue;
      }
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildASTSchema;
      }
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: function() {
        return _buildClientSchema.buildClientSchema;
      }
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: function() {
        return _buildASTSchema.buildSchema;
      }
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: function() {
        return _coerceInputValue.coerceInputValue;
      }
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: function() {
        return _concatAST.concatAST;
      }
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: function() {
        return _typeComparators.doTypesOverlap;
      }
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: function() {
        return _extendSchema.extendSchema;
      }
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findBreakingChanges;
      }
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: function() {
        return _findBreakingChanges.findDangerousChanges;
      }
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: function() {
        return _getOperationAST.getOperationAST;
      }
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: function() {
        return _getOperationRootType.getOperationRootType;
      }
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: function() {
        return _introspectionFromSchema.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: function() {
        return _typeComparators.isEqualType;
      }
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: function() {
        return _typeComparators.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: function() {
        return _assertValidName.isValidNameError;
      }
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: function() {
        return _printSchema.printSchema;
      }
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: function() {
        return _printSchema.printType;
      }
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: function() {
        return _separateOperations.separateOperations;
      }
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: function() {
        return _typeFromAST.typeFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: function() {
        return _valueFromAST.valueFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: function() {
        return _TypeInfo.visitWithTypeInfo;
      }
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
  }
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "node_modules/graphql/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: function() {
        return _index2.BREAK;
      }
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: function() {
        return _index6.BreakingChangeType;
      }
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: function() {
        return _index6.DangerousChangeType;
      }
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _index2.DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function() {
        return _index4.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _index4.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function() {
        return _index.GRAPHQL_MAX_INT;
      }
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function() {
        return _index.GRAPHQL_MIN_INT;
      }
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: function() {
        return _index.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: function() {
        return _index5.GraphQLError;
      }
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: function() {
        return _index.GraphQLFloat;
      }
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: function() {
        return _index.GraphQLID;
      }
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInt;
      }
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: function() {
        return _index.GraphQLList;
      }
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: function() {
        return _index.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSchema;
      }
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function() {
        return _index.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: function() {
        return _index.GraphQLString;
      }
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: function() {
        return _index.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: function() {
        return _index2.Kind;
      }
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: function() {
        return _index2.Lexer;
      }
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: function() {
        return _index2.Location;
      }
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function() {
        return _index4.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function() {
        return _index4.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function() {
        return _index4.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function() {
        return _index4.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function() {
        return _index4.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: function() {
        return _index2.OperationTypeNode;
      }
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function() {
        return _index4.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function() {
        return _index4.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function() {
        return _index4.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function() {
        return _index4.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: function() {
        return _index4.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function() {
        return _index4.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: function() {
        return _index2.Source;
      }
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: function() {
        return _index2.Token;
      }
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: function() {
        return _index2.TokenKind;
      }
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: function() {
        return _index6.TypeInfo;
      }
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: function() {
        return _index.TypeKind;
      }
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function() {
        return _index.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueArgumentDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function() {
        return _index4.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: function() {
        return _index4.ValidationContext;
      }
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function() {
        return _index4.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function() {
        return _index4.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function() {
        return _index4.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: function() {
        return _index.__Directive;
      }
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: function() {
        return _index.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: function() {
        return _index.__EnumValue;
      }
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: function() {
        return _index.__Field;
      }
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: function() {
        return _index.__InputValue;
      }
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: function() {
        return _index.__Schema;
      }
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: function() {
        return _index.__Type;
      }
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: function() {
        return _index.__TypeKind;
      }
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: function() {
        return _index.assertAbstractType;
      }
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: function() {
        return _index.assertCompositeType;
      }
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: function() {
        return _index.assertDirective;
      }
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: function() {
        return _index.assertEnumType;
      }
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: function() {
        return _index.assertEnumValueName;
      }
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.assertInputObjectType;
      }
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: function() {
        return _index.assertInputType;
      }
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.assertInterfaceType;
      }
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: function() {
        return _index.assertLeafType;
      }
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: function() {
        return _index.assertListType;
      }
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: function() {
        return _index.assertName;
      }
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: function() {
        return _index.assertNamedType;
      }
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: function() {
        return _index.assertNonNullType;
      }
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: function() {
        return _index.assertNullableType;
      }
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: function() {
        return _index.assertObjectType;
      }
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: function() {
        return _index.assertOutputType;
      }
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: function() {
        return _index.assertScalarType;
      }
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: function() {
        return _index.assertSchema;
      }
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: function() {
        return _index.assertType;
      }
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: function() {
        return _index.assertUnionType;
      }
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: function() {
        return _index6.assertValidName;
      }
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: function() {
        return _index.assertValidSchema;
      }
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: function() {
        return _index.assertWrappingType;
      }
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: function() {
        return _index6.astFromValue;
      }
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildASTSchema;
      }
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildClientSchema;
      }
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: function() {
        return _index6.buildSchema;
      }
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: function() {
        return _index6.coerceInputValue;
      }
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: function() {
        return _index6.concatAST;
      }
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: function() {
        return _index3.createSourceEventStream;
      }
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: function() {
        return _index3.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: function() {
        return _index3.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: function() {
        return _index6.doTypesOverlap;
      }
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: function() {
        return _index3.execute;
      }
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: function() {
        return _index3.executeSync;
      }
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: function() {
        return _index6.extendSchema;
      }
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: function() {
        return _index6.findBreakingChanges;
      }
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: function() {
        return _index6.findDangerousChanges;
      }
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: function() {
        return _index5.formatError;
      }
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: function() {
        return _index3.getArgumentValues;
      }
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: function() {
        return _index3.getDirectiveValues;
      }
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: function() {
        return _index2.getEnterLeaveForKind;
      }
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: function() {
        return _index6.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: function() {
        return _index2.getLocation;
      }
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: function() {
        return _index.getNamedType;
      }
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: function() {
        return _index.getNullableType;
      }
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: function() {
        return _index6.getOperationAST;
      }
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: function() {
        return _index6.getOperationRootType;
      }
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: function() {
        return _index3.getVariableValues;
      }
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: function() {
        return _index2.getVisitFn;
      }
    });
    Object.defineProperty(exports2, "graphql", {
      enumerable: true,
      get: function() {
        return _graphql.graphql;
      }
    });
    Object.defineProperty(exports2, "graphqlSync", {
      enumerable: true,
      get: function() {
        return _graphql.graphqlSync;
      }
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: function() {
        return _index6.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: function() {
        return _index.introspectionTypes;
      }
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: function() {
        return _index.isAbstractType;
      }
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: function() {
        return _index.isCompositeType;
      }
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: function() {
        return _index2.isConstValueNode;
      }
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: function() {
        return _index.isDirective;
      }
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: function() {
        return _index.isEnumType;
      }
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: function() {
        return _index6.isEqualType;
      }
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: function() {
        return _index.isInputObjectType;
      }
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: function() {
        return _index.isInputType;
      }
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: function() {
        return _index.isInterfaceType;
      }
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: function() {
        return _index.isIntrospectionType;
      }
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: function() {
        return _index.isLeafType;
      }
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: function() {
        return _index.isListType;
      }
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: function() {
        return _index.isNamedType;
      }
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: function() {
        return _index.isNonNullType;
      }
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: function() {
        return _index.isNullableType;
      }
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: function() {
        return _index.isObjectType;
      }
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: function() {
        return _index.isOutputType;
      }
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: function() {
        return _index.isRequiredArgument;
      }
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: function() {
        return _index.isRequiredInputField;
      }
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: function() {
        return _index.isScalarType;
      }
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: function() {
        return _index.isSchema;
      }
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: function() {
        return _index2.isSelectionNode;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: function() {
        return _index.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: function() {
        return _index.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _index.isType;
      }
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: function() {
        return _index6.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function() {
        return _index2.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: function() {
        return _index.isUnionType;
      }
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: function() {
        return _index6.isValidNameError;
      }
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: function() {
        return _index2.isValueNode;
      }
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: function() {
        return _index.isWrappingType;
      }
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: function() {
        return _index6.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: function() {
        return _index5.locatedError;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _index2.parse;
      }
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: function() {
        return _index2.parseConstValue;
      }
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: function() {
        return _index2.parseType;
      }
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: function() {
        return _index2.parseValue;
      }
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: function() {
        return _index2.print;
      }
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: function() {
        return _index5.printError;
      }
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: function() {
        return _index6.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: function() {
        return _index2.printLocation;
      }
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: function() {
        return _index6.printSchema;
      }
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: function() {
        return _index2.printSourceLocation;
      }
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: function() {
        return _index6.printType;
      }
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: function() {
        return _index.resolveObjMapThunk;
      }
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function() {
        return _index.resolveReadonlyArrayThunk;
      }
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: function() {
        return _index3.responsePathAsArray;
      }
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: function() {
        return _index6.separateOperations;
      }
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: function() {
        return _index.specifiedDirectives;
      }
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: function() {
        return _index4.specifiedRules;
      }
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: function() {
        return _index.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: function() {
        return _index6.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: function() {
        return _index3.subscribe;
      }
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: function() {
        return _index5.syntaxError;
      }
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: function() {
        return _index6.typeFromAST;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _index4.validate;
      }
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: function() {
        return _index.validateSchema;
      }
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: function() {
        return _index6.valueFromAST;
      }
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: function() {
        return _index6.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.version;
      }
    });
    Object.defineProperty(exports2, "versionInfo", {
      enumerable: true,
      get: function() {
        return _version.versionInfo;
      }
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: function() {
        return _index2.visit;
      }
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: function() {
        return _index2.visitInParallel;
      }
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: function() {
        return _index6.visitWithTypeInfo;
      }
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_validation();
    var _index5 = require_error();
    var _index6 = require_utilities();
  }
});

// node_modules/value-or-promise/build/main/ValueOrPromise.js
var require_ValueOrPromise = __commonJS({
  "node_modules/value-or-promise/build/main/ValueOrPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueOrPromise = void 0;
    function isPromiseLike(object) {
      return object != null && typeof object.then === "function";
    }
    var defaultOnRejectedFn = (reason) => {
      throw reason;
    };
    var ValueOrPromise3 = class _ValueOrPromise {
      constructor(executor) {
        let value;
        try {
          value = executor();
        } catch (reason) {
          this.state = { status: "rejected", value: reason };
          return;
        }
        if (isPromiseLike(value)) {
          this.state = { status: "pending", value };
          return;
        }
        this.state = { status: "fulfilled", value };
      }
      then(onFulfilled, onRejected) {
        const state = this.state;
        if (state.status === "pending") {
          return new _ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
        }
        const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
        if (state.status === "rejected") {
          return new _ValueOrPromise(() => onRejectedFn(state.value));
        }
        try {
          const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : void 0;
          return onFulfilledFn === void 0 ? new _ValueOrPromise(() => state.value) : new _ValueOrPromise(() => onFulfilledFn(state.value));
        } catch (e) {
          return new _ValueOrPromise(() => onRejectedFn(e));
        }
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      resolve() {
        const state = this.state;
        if (state.status === "pending") {
          return Promise.resolve(state.value);
        }
        if (state.status === "rejected") {
          throw state.value;
        }
        return state.value;
      }
      static all(valueOrPromises) {
        let rejected = false;
        let reason;
        let containsPromise = false;
        const values = [];
        for (const valueOrPromise of valueOrPromises) {
          const state = valueOrPromise.state;
          if (state.status === "rejected") {
            if (rejected) {
              continue;
            }
            rejected = true;
            reason = state.value;
            continue;
          }
          if (state.status === "pending") {
            containsPromise = true;
          }
          values.push(state.value);
        }
        if (containsPromise) {
          if (rejected) {
            Promise.all(values).catch(() => {
            });
            return new _ValueOrPromise(() => {
              throw reason;
            });
          }
          return new _ValueOrPromise(() => Promise.all(values));
        }
        return new _ValueOrPromise(() => values);
      }
    };
    exports2.ValueOrPromise = ValueOrPromise3;
  }
});

// node_modules/value-or-promise/build/main/index.js
var require_main = __commonJS({
  "node_modules/value-or-promise/build/main/index.js"(exports2) {
    "use strict";
    var __createBinding3 = exports2 && exports2.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar3 = exports2 && exports2.__exportStar || function(m2, exports3) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding3(exports3, m2, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar3(require_ValueOrPromise(), exports2);
  }
});

// node_modules/graphql-yoga/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS({
  "node_modules/graphql-yoga/node_modules/urlpattern-polyfill/dist/urlpattern.cjs"(exports2, module2) {
    "use strict";
    var M2 = Object.defineProperty;
    var Se2 = Object.getOwnPropertyDescriptor;
    var ke2 = Object.getOwnPropertyNames;
    var Ee2 = Object.prototype.hasOwnProperty;
    var Re2 = (e, t) => {
      for (var r in t)
        M2(e, r, { get: t[r], enumerable: true });
    };
    var ye2 = (e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let a of ke2(t))
          !Ee2.call(e, a) && a !== r && M2(e, a, { get: () => t[a], enumerable: !(n = Se2(t, a)) || n.enumerable });
      return e;
    };
    var Oe2 = (e) => ye2(M2({}, "__esModule", { value: true }), e);
    var Ne2 = {};
    Re2(Ne2, { URLPattern: () => Y });
    module2.exports = Oe2(Ne2);
    var k2 = class {
      type = 3;
      name = "";
      prefix = "";
      value = "";
      suffix = "";
      modifier = 3;
      constructor(t, r, n, a, c, l) {
        this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
      }
      hasCustomName() {
        return this.name !== "" && typeof this.name != "number";
      }
    };
    var Te = /[$_\p{ID_Start}]/u;
    var Ae2 = /[$_\u200C\u200D\p{ID_Continue}]/u;
    var v2 = ".*";
    function we2(e, t) {
      return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
    }
    function D2(e, t = false) {
      let r = [], n = 0;
      for (; n < e.length; ) {
        let a = e[n], c = function(l) {
          if (!t)
            throw new TypeError(l);
          r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
        };
        if (a === "*") {
          r.push({ type: "ASTERISK", index: n, value: e[n++] });
          continue;
        }
        if (a === "+" || a === "?") {
          r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
          continue;
        }
        if (a === "\\") {
          r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
          continue;
        }
        if (a === "{") {
          r.push({ type: "OPEN", index: n, value: e[n++] });
          continue;
        }
        if (a === "}") {
          r.push({ type: "CLOSE", index: n, value: e[n++] });
          continue;
        }
        if (a === ":") {
          let l = "", s = n + 1;
          for (; s < e.length; ) {
            let i = e.substr(s, 1);
            if (s === n + 1 && Te.test(i) || s !== n + 1 && Ae2.test(i)) {
              l += e[s++];
              continue;
            }
            break;
          }
          if (!l) {
            c(`Missing parameter name at ${n}`);
            continue;
          }
          r.push({ type: "NAME", index: n, value: l }), n = s;
          continue;
        }
        if (a === "(") {
          let l = 1, s = "", i = n + 1, o = false;
          if (e[i] === "?") {
            c(`Pattern cannot start with "?" at ${i}`);
            continue;
          }
          for (; i < e.length; ) {
            if (!we2(e[i], false)) {
              c(`Invalid character '${e[i]}' at ${i}.`), o = true;
              break;
            }
            if (e[i] === "\\") {
              s += e[i++] + e[i++];
              continue;
            }
            if (e[i] === ")") {
              if (l--, l === 0) {
                i++;
                break;
              }
            } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
              c(`Capturing groups are not allowed at ${i}`), o = true;
              break;
            }
            s += e[i++];
          }
          if (o)
            continue;
          if (l) {
            c(`Unbalanced pattern at ${n}`);
            continue;
          }
          if (!s) {
            c(`Missing pattern at ${n}`);
            continue;
          }
          r.push({ type: "REGEX", index: n, value: s }), n = i;
          continue;
        }
        r.push({ type: "CHAR", index: n, value: e[n++] });
      }
      return r.push({ type: "END", index: n, value: "" }), r;
    }
    function F(e, t = {}) {
      let r = D2(e);
      t.delimiter ??= "/#?", t.prefixes ??= "./";
      let n = `[^${x(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = /* @__PURE__ */ new Set(), o = (f) => {
        if (l < r.length && r[l].type === f)
          return r[l++].value;
      }, h2 = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), p = (f) => {
        let u = o(f);
        if (u !== void 0)
          return u;
        let { type: d, index: T } = r[l];
        throw new TypeError(`Unexpected ${d} at ${T}, expected ${f}`);
      }, O2 = () => {
        let f = "", u;
        for (; u = o("CHAR") ?? o("ESCAPED_CHAR"); )
          f += u;
        return f;
      }, be2 = (f) => f, L2 = t.encodePart || be2, I = "", H = (f) => {
        I += f;
      }, $ = () => {
        I.length && (a.push(new k2(3, "", "", L2(I), "", 3)), I = "");
      }, X2 = (f, u, d, T, Z) => {
        let g = 3;
        switch (Z) {
          case "?":
            g = 1;
            break;
          case "*":
            g = 0;
            break;
          case "+":
            g = 2;
            break;
        }
        if (!u && !d && g === 3) {
          H(f);
          return;
        }
        if ($(), !u && !d) {
          if (!f)
            return;
          a.push(new k2(3, "", "", L2(f), "", g));
          return;
        }
        let m2;
        d ? d === "*" ? m2 = v2 : m2 = d : m2 = n;
        let R = 2;
        m2 === n ? (R = 1, m2 = "") : m2 === v2 && (R = 0, m2 = "");
        let S2;
        if (u ? S2 = u : d && (S2 = c++), i.has(S2))
          throw new TypeError(`Duplicate name '${S2}'.`);
        i.add(S2), a.push(new k2(R, S2, L2(f), m2, L2(T), g));
      };
      for (; l < r.length; ) {
        let f = o("CHAR"), u = o("NAME"), d = o("REGEX");
        if (!u && !d && (d = o("ASTERISK")), u || d) {
          let g = f ?? "";
          t.prefixes.indexOf(g) === -1 && (H(g), g = ""), $();
          let m2 = h2();
          X2(g, u, d, "", m2);
          continue;
        }
        let T = f ?? o("ESCAPED_CHAR");
        if (T) {
          H(T);
          continue;
        }
        if (o("OPEN")) {
          let g = O2(), m2 = o("NAME"), R = o("REGEX");
          !m2 && !R && (R = o("ASTERISK"));
          let S2 = O2();
          p("CLOSE");
          let Pe2 = h2();
          X2(g, m2, R, S2, Pe2);
          continue;
        }
        $(), p("END");
      }
      return a;
    }
    function x(e) {
      return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
    }
    function B(e) {
      return e && e.ignoreCase ? "ui" : "u";
    }
    function q2(e, t, r) {
      return W2(F(e, r), t, r);
    }
    function y(e) {
      switch (e) {
        case 0:
          return "*";
        case 1:
          return "?";
        case 2:
          return "+";
        case 3:
          return "";
      }
    }
    function W2(e, t, r = {}) {
      r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
      let n = r.start ? "^" : "";
      for (let s of e) {
        if (s.type === 3) {
          s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${y(s.modifier)}`;
          continue;
        }
        t && t.push(s.name);
        let i = `[^${x(r.delimiter)}]+?`, o = s.value;
        if (s.type === 1 ? o = i : s.type === 0 && (o = v2), !s.prefix.length && !s.suffix.length) {
          s.modifier === 3 || s.modifier === 1 ? n += `(${o})${y(s.modifier)}` : n += `((?:${o})${y(s.modifier)})`;
          continue;
        }
        if (s.modifier === 3 || s.modifier === 1) {
          n += `(?:${x(s.prefix)}(${o})${x(s.suffix)})`, n += y(s.modifier);
          continue;
        }
        n += `(?:${x(s.prefix)}`, n += `((?:${o})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${o}))*)${x(s.suffix)})`, s.modifier === 0 && (n += "?");
      }
      let a = `[${x(r.endsWith)}]|$`, c = `[${x(r.delimiter)}]`;
      if (r.end)
        return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
      r.strict || (n += `(?:${c}(?=${a}))?`);
      let l = false;
      if (e.length) {
        let s = e[e.length - 1];
        s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
      }
      return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
    }
    var b2 = { delimiter: "", prefixes: "", sensitive: true, strict: true };
    var J2 = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
    var Q2 = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
    function ee2(e, t) {
      return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
    }
    function te2(e, t) {
      return e.startsWith(t) ? e.substring(t.length, e.length) : e;
    }
    function Ce2(e, t) {
      return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
    }
    function _2(e) {
      return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
    }
    var re2 = ["ftp", "file", "http", "https", "ws", "wss"];
    function N2(e) {
      if (!e)
        return true;
      for (let t of re2)
        if (e.test(t))
          return true;
      return false;
    }
    function ne2(e, t) {
      if (e = te2(e, "#"), t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
    }
    function se2(e, t) {
      if (e = te2(e, "?"), t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
    }
    function ie2(e, t) {
      return t || e === "" ? e : _2(e) ? K2(e) : j2(e);
    }
    function ae2(e, t) {
      if (t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.password = e, r.password;
    }
    function oe2(e, t) {
      if (t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.username = e, r.username;
    }
    function ce(e, t, r) {
      if (r || e === "")
        return e;
      if (t && !re2.includes(t))
        return new URL(`${t}:${e}`).pathname;
      let n = e[0] == "/";
      return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
    }
    function le(e, t, r) {
      return z(t) === e && (e = ""), r || e === "" ? e : V2(e);
    }
    function he2(e, t) {
      return e = Ce2(e, ":"), t || e === "" ? e : A(e);
    }
    function z(e) {
      switch (e) {
        case "ws":
        case "http":
          return "80";
        case "wws":
        case "https":
          return "443";
        case "ftp":
          return "21";
        default:
          return "";
      }
    }
    function A(e) {
      if (e === "")
        return e;
      if (/^[-+.A-Za-z0-9]*$/.test(e))
        return e.toLowerCase();
      throw new TypeError(`Invalid protocol '${e}'.`);
    }
    function fe2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.username = e, t.username;
    }
    function ue2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.password = e, t.password;
    }
    function j2(e) {
      if (e === "")
        return e;
      if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
        throw new TypeError(`Invalid hostname '${e}'`);
      let t = new URL("https://example.com");
      return t.hostname = e, t.hostname;
    }
    function K2(e) {
      if (e === "")
        return e;
      if (/[^0-9a-fA-F[\]:]/g.test(e))
        throw new TypeError(`Invalid IPv6 hostname '${e}'`);
      return e.toLowerCase();
    }
    function V2(e) {
      if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
        return e;
      throw new TypeError(`Invalid port '${e}'.`);
    }
    function pe2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
    }
    function de(e) {
      return e === "" ? e : new URL(`data:${e}`).pathname;
    }
    function ge2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.search = e, t.search.substring(1, t.search.length);
    }
    function me3(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.hash = e, t.hash.substring(1, t.hash.length);
    }
    var U2 = class {
      #i;
      #n = [];
      #t = {};
      #e = 0;
      #s = 1;
      #u = 0;
      #c = 0;
      #p = 0;
      #d = 0;
      #g = false;
      constructor(t) {
        this.#i = t;
      }
      get result() {
        return this.#t;
      }
      parse() {
        for (this.#n = D2(this.#i, true); this.#e < this.#n.length; this.#e += this.#s) {
          if (this.#s = 1, this.#n[this.#e].type === "END") {
            if (this.#c === 0) {
              this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
              continue;
            } else if (this.#c === 2) {
              this.#f(5);
              continue;
            }
            this.#r(10, 0);
            break;
          }
          if (this.#p > 0)
            if (this.#T())
              this.#p -= 1;
            else
              continue;
          if (this.#O()) {
            this.#p += 1;
            continue;
          }
          switch (this.#c) {
            case 0:
              this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
              break;
            case 1:
              if (this.#S()) {
                this.#C();
                let t = 7, r = 1;
                this.#g && (this.#t.pathname = "/"), this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
              }
              break;
            case 2:
              this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
              break;
            case 3:
              this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
              break;
            case 4:
              this.#x() && this.#r(5, 1);
              break;
            case 5:
              this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 6:
              this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 7:
              this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 8:
              this.#l() && this.#r(9, 1);
              break;
            case 9:
              break;
            case 10:
              break;
          }
        }
      }
      #r(t, r) {
        switch (this.#c) {
          case 0:
            break;
          case 1:
            this.#t.protocol = this.#o();
            break;
          case 2:
            break;
          case 3:
            this.#t.username = this.#o();
            break;
          case 4:
            this.#t.password = this.#o();
            break;
          case 5:
            this.#t.hostname = this.#o();
            break;
          case 6:
            this.#t.port = this.#o();
            break;
          case 7:
            this.#t.pathname = this.#o();
            break;
          case 8:
            this.#t.search = this.#o();
            break;
          case 9:
            this.#t.hash = this.#o();
            break;
          case 10:
            break;
        }
        this.#k(t, r);
      }
      #k(t, r) {
        this.#c = t, this.#u = this.#e + r, this.#e += r, this.#s = 0;
      }
      #P() {
        this.#e = this.#u, this.#s = 0;
      }
      #f(t) {
        this.#P(), this.#c = t;
      }
      #m(t) {
        return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
      }
      #a(t, r) {
        let n = this.#m(t);
        return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
      }
      #S() {
        return this.#a(this.#e, ":");
      }
      #E() {
        return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
      }
      #x() {
        return this.#a(this.#e, "@");
      }
      #R() {
        return this.#a(this.#e, ":");
      }
      #y() {
        return this.#a(this.#e, ":");
      }
      #b() {
        return this.#a(this.#e, "/");
      }
      #h() {
        if (this.#a(this.#e, "?"))
          return true;
        if (this.#n[this.#e].value !== "?")
          return false;
        let t = this.#m(this.#e - 1);
        return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
      }
      #l() {
        return this.#a(this.#e, "#");
      }
      #O() {
        return this.#n[this.#e].type == "OPEN";
      }
      #T() {
        return this.#n[this.#e].type == "CLOSE";
      }
      #A() {
        return this.#a(this.#e, "[");
      }
      #w() {
        return this.#a(this.#e, "]");
      }
      #o() {
        let t = this.#n[this.#e], r = this.#m(this.#u).index;
        return this.#i.substring(r, t.index);
      }
      #C() {
        let t = {};
        Object.assign(t, b2), t.encodePart = A;
        let r = q2(this.#o(), void 0, t);
        this.#g = N2(r);
      }
    };
    var G = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
    var E2 = "*";
    function xe2(e, t) {
      if (typeof e != "string")
        throw new TypeError("parameter 1 is not of type 'string'.");
      let r = new URL(e, t);
      return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : void 0, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : void 0 };
    }
    function P(e, t) {
      return t ? C(e) : e;
    }
    function w2(e, t, r) {
      let n;
      if (typeof t.baseURL == "string")
        try {
          n = new URL(t.baseURL), e.protocol = P(n.protocol.substring(0, n.protocol.length - 1), r), e.username = P(n.username, r), e.password = P(n.password, r), e.hostname = P(n.hostname, r), e.port = P(n.port, r), e.pathname = P(n.pathname, r), e.search = P(n.search.substring(1, n.search.length), r), e.hash = P(n.hash.substring(1, n.hash.length), r);
        } catch {
          throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
        }
      if (typeof t.protocol == "string" && (e.protocol = he2(t.protocol, r)), typeof t.username == "string" && (e.username = oe2(t.username, r)), typeof t.password == "string" && (e.password = ae2(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie2(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
        if (e.pathname = t.pathname, n && !ee2(e.pathname, r)) {
          let a = n.pathname.lastIndexOf("/");
          a >= 0 && (e.pathname = P(n.pathname.substring(0, a + 1), r) + e.pathname);
        }
        e.pathname = ce(e.pathname, e.protocol, r);
      }
      return typeof t.search == "string" && (e.search = se2(t.search, r)), typeof t.hash == "string" && (e.hash = ne2(t.hash, r)), e;
    }
    function C(e) {
      return e.replace(/([+*?:{}()\\])/g, "\\$1");
    }
    function Le2(e) {
      return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
    }
    function Ie2(e, t) {
      t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
      let r = ".*", n = `[^${Le2(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
      for (let l = 0; l < e.length; ++l) {
        let s = e[l];
        if (s.type === 3) {
          if (s.modifier === 3) {
            c += C(s.value);
            continue;
          }
          c += `{${C(s.value)}}${y(s.modifier)}`;
          continue;
        }
        let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h2 = l > 0 ? e[l - 1] : null, p = l < e.length - 1 ? e[l + 1] : null;
        if (!o && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)
          if (p.type === 3) {
            let O2 = p.value.length > 0 ? p.value[0] : "";
            o = a.test(O2);
          } else
            o = !p.hasCustomName();
        if (!o && !s.prefix.length && h2 && h2.type === 3) {
          let O2 = h2.value[h2.value.length - 1];
          o = t.prefixes.includes(O2);
        }
        o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!h2 || h2.type === 3 || h2.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += y(s.modifier));
      }
      return c;
    }
    var Y = class {
      #i;
      #n = {};
      #t = {};
      #e = {};
      #s = {};
      constructor(t = {}, r, n) {
        try {
          let a;
          if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
            let i = new U2(t);
            if (i.parse(), t = i.result, a === void 0 && typeof t.protocol != "string")
              throw new TypeError("A base URL must be provided for a relative constructor string.");
            t.baseURL = a;
          } else {
            if (!t || typeof t != "object")
              throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
            if (a)
              throw new TypeError("parameter 1 is not of type 'string'.");
          }
          typeof n > "u" && (n = { ignoreCase: false });
          let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E2, protocol: E2, username: E2, password: E2, hostname: E2, port: E2, search: E2, hash: E2 };
          this.#i = w2(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
          let s;
          for (s of G) {
            if (!(s in this.#i))
              continue;
            let i = {}, o = this.#i[s];
            switch (this.#t[s] = [], s) {
              case "protocol":
                Object.assign(i, b2), i.encodePart = A;
                break;
              case "username":
                Object.assign(i, b2), i.encodePart = fe2;
                break;
              case "password":
                Object.assign(i, b2), i.encodePart = ue2;
                break;
              case "hostname":
                Object.assign(i, J2), _2(o) ? i.encodePart = K2 : i.encodePart = j2;
                break;
              case "port":
                Object.assign(i, b2), i.encodePart = V2;
                break;
              case "pathname":
                N2(this.#n.protocol) ? (Object.assign(i, Q2, c), i.encodePart = pe2) : (Object.assign(i, b2, c), i.encodePart = de);
                break;
              case "search":
                Object.assign(i, b2, c), i.encodePart = ge2;
                break;
              case "hash":
                Object.assign(i, b2, c), i.encodePart = me3;
                break;
            }
            try {
              this.#s[s] = F(o, i), this.#n[s] = W2(this.#s[s], this.#t[s], i), this.#e[s] = Ie2(this.#s[s], i);
            } catch {
              throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
            }
          }
        } catch (a) {
          throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
        }
      }
      test(t = {}, r) {
        let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
        if (typeof t != "string" && r)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (typeof t > "u")
          return false;
        try {
          typeof t == "object" ? n = w2(n, t, false) : n = w2(n, xe2(t, r), false);
        } catch {
          return false;
        }
        let a;
        for (a of G)
          if (!this.#n[a].exec(n[a]))
            return false;
        return true;
      }
      exec(t = {}, r) {
        let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
        if (typeof t != "string" && r)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (typeof t > "u")
          return;
        try {
          typeof t == "object" ? n = w2(n, t, false) : n = w2(n, xe2(t, r), false);
        } catch {
          return null;
        }
        let a = {};
        r ? a.inputs = [t, r] : a.inputs = [t];
        let c;
        for (c of G) {
          let l = this.#n[c].exec(n[c]);
          if (!l)
            return null;
          let s = {};
          for (let [i, o] of this.#t[c].entries())
            if (typeof o == "string" || typeof o == "number") {
              let h2 = l[i + 1];
              s[o] = h2;
            }
          a[c] = { input: n[c] ?? "", groups: s };
        }
        return a;
      }
      static compareComponent(t, r, n) {
        let a = (i, o) => {
          for (let h2 of ["type", "modifier", "prefix", "value", "suffix"]) {
            if (i[h2] < o[h2])
              return -1;
            if (i[h2] === o[h2])
              continue;
            return 1;
          }
          return 0;
        }, c = new k2(3, "", "", "", "", 3), l = new k2(0, "", "", "", "", 3), s = (i, o) => {
          let h2 = 0;
          for (; h2 < Math.min(i.length, o.length); ++h2) {
            let p = a(i[h2], o[h2]);
            if (p)
              return p;
          }
          return i.length === o.length ? 0 : a(i[h2] ?? c, o[h2] ?? c);
        };
        return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
      }
      get protocol() {
        return this.#e.protocol;
      }
      get username() {
        return this.#e.username;
      }
      get password() {
        return this.#e.password;
      }
      get hostname() {
        return this.#e.hostname;
      }
      get port() {
        return this.#e.port;
      }
      get pathname() {
        return this.#e.pathname;
      }
      get search() {
        return this.#e.search;
      }
      get hash() {
        return this.#e.hash;
      }
    };
  }
});

// node_modules/graphql-yoga/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS({
  "node_modules/graphql-yoga/node_modules/urlpattern-polyfill/index.cjs"(exports2, module2) {
    var { URLPattern } = require_urlpattern();
    module2.exports = { URLPattern };
    if (!globalThis.URLPattern) {
      globalThis.URLPattern = URLPattern;
    }
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillReadableStream = void 0;
    var stream_1 = require("stream");
    function createController(desiredSize, readable) {
      let chunks = [];
      let _closed = false;
      let flushed = false;
      return {
        desiredSize,
        enqueue(chunk) {
          const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
          if (!flushed) {
            chunks.push(buf);
          } else {
            readable.push(buf);
          }
        },
        close() {
          if (chunks.length > 0) {
            this._flush();
          }
          readable.push(null);
          _closed = true;
        },
        error(error) {
          if (chunks.length > 0) {
            this._flush();
          }
          readable.destroy(error);
        },
        get _closed() {
          return _closed;
        },
        _flush() {
          flushed = true;
          if (chunks.length > 0) {
            const concatenated = Buffer.concat(chunks);
            readable.push(concatenated);
            chunks = [];
          }
        }
      };
    }
    var PonyfillReadableStream = class _PonyfillReadableStream {
      constructor(underlyingSource) {
        this.locked = false;
        if (underlyingSource instanceof _PonyfillReadableStream) {
          this.readable = underlyingSource.readable;
        } else if (underlyingSource && "read" in underlyingSource) {
          this.readable = underlyingSource;
        } else if (underlyingSource && "getReader" in underlyingSource) {
          let reader;
          let started = false;
          this.readable = new stream_1.Readable({
            read() {
              if (!started) {
                started = true;
                reader = underlyingSource.getReader();
              }
              reader.read().then(({ value, done }) => {
                if (done) {
                  this.push(null);
                } else {
                  this.push(value);
                }
              }).catch((err) => {
                this.destroy(err);
              });
            },
            destroy(err, callback) {
              reader.cancel(err).then(() => callback(err), callback);
            }
          });
        } else {
          let started = false;
          let ongoing = false;
          this.readable = new stream_1.Readable({
            read(desiredSize) {
              if (ongoing) {
                return;
              }
              ongoing = true;
              return Promise.resolve().then(async () => {
                if (!started) {
                  const controller2 = createController(desiredSize, this);
                  started = true;
                  await underlyingSource?.start?.(controller2);
                  controller2._flush();
                  if (controller2._closed) {
                    return;
                  }
                }
                const controller = createController(desiredSize, this);
                await underlyingSource?.pull?.(controller);
                controller._flush();
                ongoing = false;
              });
            },
            async destroy(err, callback) {
              try {
                await underlyingSource?.cancel?.(err);
                callback(null);
              } catch (err2) {
                callback(err2);
              }
            }
          });
        }
      }
      cancel(reason) {
        this.readable.destroy(reason);
        return Promise.resolve();
      }
      getReader(_options) {
        const iterator = this.readable[Symbol.asyncIterator]();
        this.locked = true;
        return {
          read() {
            return iterator.next();
          },
          releaseLock: () => {
            iterator.return?.();
            this.locked = false;
          },
          cancel: async (reason) => {
            await iterator.return?.(reason);
            this.locked = false;
          },
          closed: new Promise((resolve, reject) => {
            this.readable.once("end", resolve);
            this.readable.once("error", reject);
          })
        };
      }
      [Symbol.asyncIterator]() {
        return this.readable[Symbol.asyncIterator]();
      }
      tee() {
        throw new Error("Not implemented");
      }
      async pipeTo(destination) {
        const writer = destination.getWriter();
        await writer.ready;
        for await (const chunk of this.readable) {
          await writer.write(chunk);
        }
        await writer.ready;
        return writer.close();
      }
      pipeThrough({ writable, readable }) {
        this.pipeTo(writable);
        return readable;
      }
      static [Symbol.hasInstance](instance) {
        return instance != null && typeof instance === "object" && "getReader" in instance;
      }
    };
    exports2.PonyfillReadableStream = PonyfillReadableStream;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultHeadersSerializer = exports2.uint8ArrayToArrayBuffer = exports2.getHeadersObj = void 0;
    function getHeadersObj(headers) {
      if (headers == null || !("forEach" in headers)) {
        return headers;
      }
      const obj = {};
      headers.forEach((value, key) => {
        obj[key] = value;
      });
      return obj;
    }
    exports2.getHeadersObj = getHeadersObj;
    function uint8ArrayToArrayBuffer(uint8array) {
      return uint8array.buffer.slice(uint8array.byteOffset, uint8array.byteOffset + uint8array.byteLength);
    }
    exports2.uint8ArrayToArrayBuffer = uint8ArrayToArrayBuffer;
    function defaultHeadersSerializer(headers, onContentLength) {
      const headerArray = [];
      headers.forEach((value, key) => {
        if (onContentLength && key === "content-length") {
          onContentLength(value);
        }
        headerArray.push(`${key}: ${value}`);
      });
      return headerArray;
    }
    exports2.defaultHeadersSerializer = defaultHeadersSerializer;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Blob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBlob = void 0;
    var ReadableStream_js_1 = require_ReadableStream();
    var utils_js_1 = require_utils();
    function getBlobPartAsBuffer(blobPart) {
      if (typeof blobPart === "string") {
        return Buffer.from(blobPart);
      } else if (Buffer.isBuffer(blobPart)) {
        return blobPart;
      } else if (blobPart instanceof Uint8Array) {
        return Buffer.from(blobPart);
      } else if ("buffer" in blobPart) {
        return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
      } else {
        return Buffer.from(blobPart);
      }
    }
    function isBlob(obj) {
      return obj != null && typeof obj === "object" && obj.arrayBuffer != null;
    }
    var PonyfillBlob = class {
      constructor(blobParts, options) {
        this.blobParts = blobParts;
        this.type = options?.type || "application/octet-stream";
        this.encoding = options?.encoding || "utf8";
      }
      async buffer() {
        const bufferChunks = [];
        for (const blobPart of this.blobParts) {
          if (isBlob(blobPart)) {
            const arrayBuf = await blobPart.arrayBuffer();
            const buf = Buffer.from(arrayBuf, void 0, blobPart.size);
            bufferChunks.push(buf);
          } else {
            const buf = getBlobPartAsBuffer(blobPart);
            bufferChunks.push(buf);
          }
        }
        return Buffer.concat(bufferChunks);
      }
      async arrayBuffer() {
        const buffer = await this.buffer();
        return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
      }
      async text() {
        let text = "";
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            text += blobPart;
          } else if ("text" in blobPart) {
            text += await blobPart.text();
          } else {
            const buf = getBlobPartAsBuffer(blobPart);
            text += buf.toString(this.encoding);
          }
        }
        return text;
      }
      get size() {
        let size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            size += blobPart.size;
          } else if ("length" in blobPart) {
            size += blobPart.length;
          } else if ("byteLength" in blobPart) {
            size += blobPart.byteLength;
          }
        }
        return size;
      }
      stream() {
        let partQueue = [];
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            partQueue = [...this.blobParts];
            if (partQueue.length === 0) {
              controller.close();
            }
          },
          pull: async (controller) => {
            const blobPart = partQueue.pop();
            if (blobPart) {
              if (isBlob(blobPart)) {
                const arrayBuffer = await blobPart.arrayBuffer();
                const buf = Buffer.from(arrayBuffer, void 0, blobPart.size);
                controller.enqueue(buf);
              } else {
                const buf = getBlobPartAsBuffer(blobPart);
                controller.enqueue(buf);
              }
            } else {
              controller.close();
            }
          }
        });
      }
      slice() {
        throw new Error("Not implemented");
      }
    };
    exports2.PonyfillBlob = PonyfillBlob;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.push(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.push(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m2, o) {
  for (var p in m2)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m2, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i = 0; i < arguments.length; i++)
    ar2 = ar2.concat(__read(arguments[i]));
  return ar2;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k2++)
      r[k2] = a[j2];
  return r;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar2; i < l; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n, v2, a, b2]) > 1 || resume(n, v2);
        });
      };
  }
  function resume(n, v2) {
    try {
      step(g[n](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v2) {
    if (f(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v2) {
      return (p = !p) ? { value: __await(o[n](v2)), done: false } : f ? f(v2) : v2;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw2) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw2 });
  } else {
    cooked.raw = raw2;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
var extendStatics, __assign, __createBinding, __setModuleDefault;
var init_tslib_es6 = __esm({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    };
    __setModuleDefault = Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    };
  }
});

// node_modules/busboy/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/busboy/lib/utils.js"(exports2, module2) {
    "use strict";
    function parseContentType(str) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 47 || i === 0)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      const type = str.slice(0, i).toLowerCase();
      const subtypeStart = ++i;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (i === subtypeStart)
            return;
          if (parseContentTypeParams(str, i, params) === void 0)
            return;
          break;
        }
      }
      if (i === subtypeStart)
        return;
      const subtype = str.slice(subtypeStart, i).toLowerCase();
      return { type, subtype, params };
    }
    function parseContentTypeParams(str, i, params) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code !== 61)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        name = str.slice(nameStart, i);
        ++i;
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function parseDisposition(str, defDecoder) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (parseDispositionParams(str, i, params, defDecoder) === void 0)
            return;
          break;
        }
      }
      const type = str.slice(0, i).toLowerCase();
      return { type, params };
    }
    function parseDispositionParams(str, i, params, defDecoder) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code === 61)
              break;
            return;
          }
        }
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        let charset;
        name = str.slice(nameStart, i);
        if (name.charCodeAt(name.length - 1) === 42) {
          const charsetStart = ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (CHARSET[code] !== 1) {
              if (code !== 39)
                return;
              break;
            }
          }
          if (i === str.length)
            return;
          charset = str.slice(charsetStart, i);
          ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 39)
              break;
          }
          if (i === str.length)
            return;
          ++i;
          if (i === str.length)
            return;
          valueStart = i;
          let encode = 0;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (EXTENDED_VALUE[code] !== 1) {
              if (code === 37) {
                let hexUpper;
                let hexLower;
                if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                  const byteVal = (hexUpper << 4) + hexLower;
                  value += str.slice(valueStart, i);
                  value += String.fromCharCode(byteVal);
                  i += 2;
                  valueStart = i + 1;
                  if (byteVal >= 128)
                    encode = 2;
                  else if (encode === 0)
                    encode = 1;
                  continue;
                }
                return;
              }
              break;
            }
          }
          value += str.slice(valueStart, i);
          value = convertToUTF8(value, charset, encode);
          if (value === void 0)
            return;
        } else {
          ++i;
          if (i === str.length)
            return;
          if (str.charCodeAt(i) === 34) {
            valueStart = ++i;
            let escaping = false;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code === 92) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                } else {
                  value += str.slice(valueStart, i);
                  escaping = true;
                }
                continue;
              }
              if (code === 34) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                  continue;
                }
                value += str.slice(valueStart, i);
                break;
              }
              if (escaping) {
                valueStart = i - 1;
                escaping = false;
              }
              if (QDTEXT[code] !== 1)
                return;
            }
            if (i === str.length)
              return;
            ++i;
          } else {
            valueStart = i;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (TOKEN[code] !== 1) {
                if (i === valueStart)
                  return;
                break;
              }
            }
            value = str.slice(valueStart, i);
          }
          value = defDecoder(value, 2);
          if (value === void 0)
            return;
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function getDecoder(charset) {
      let lc2;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc2 === void 0) {
              lc2 = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string") {
          if (hint < 2)
            return data;
          data = Buffer.from(data, "latin1");
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          return data;
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.base64Slice(0, data.length);
      },
      other: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        try {
          const decoder = new TextDecoder(exports2);
          return decoder.decode(data);
        } catch {
        }
      }
    };
    function convertToUTF8(data, charset, hint) {
      const decode = getDecoder(charset);
      if (decode)
        return decode(data, hint);
    }
    function basename(path) {
      if (typeof path !== "string")
        return "";
      for (let i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var QDTEXT = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    var CHARSET = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var EXTENDED_VALUE = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    };
  }
});

// node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/streamsearch/lib/sbmh.js"(exports2, module2) {
    "use strict";
    function memcmp(buf1, pos1, buf2, pos2, num) {
      for (let i = 0; i < num; ++i) {
        if (buf1[pos1 + i] !== buf2[pos2 + i])
          return false;
      }
      return true;
    }
    var SBMH = class {
      constructor(needle, cb) {
        if (typeof cb !== "function")
          throw new Error("Missing match callback");
        if (typeof needle === "string")
          needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle))
          throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        this._occ = [
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen
        ];
        if (needleLen > 1) {
          for (let i = 0; i < needleLen - 1; ++i)
            this._occ[needle[i]] = needleLen - 1 - i;
        }
      }
      reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
      }
      push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk))
          chunk = Buffer.from(chunk, "latin1");
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while (result !== chunkLen && this.matches < this.maxMatches)
          result = feed(this, chunk);
        return result;
      }
      destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize)
          this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
      }
    };
    function feed(self2, data) {
      const len = data.length;
      const needle = self2._needle;
      const needleLen = needle.length;
      let pos = -self2._lookbehindSize;
      const lastNeedleCharPos = needleLen - 1;
      const lastNeedleChar = needle[lastNeedleCharPos];
      const end = len - needleLen;
      const occ = self2._occ;
      const lookbehind = self2._lookbehind;
      if (pos < 0) {
        while (pos < 0 && pos <= end) {
          const nextPos = pos + lastNeedleCharPos;
          const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
          if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
            self2._lookbehindSize = 0;
            ++self2.matches;
            if (pos > -self2._lookbehindSize)
              self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
            else
              self2._cb(true, void 0, 0, 0, true);
            return self2._bufPos = pos + needleLen;
          }
          pos += occ[ch];
        }
        while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
          ++pos;
        if (pos < 0) {
          const bytesToCutOff = self2._lookbehindSize + pos;
          if (bytesToCutOff > 0) {
            self2._cb(false, lookbehind, 0, bytesToCutOff, false);
          }
          self2._lookbehindSize -= bytesToCutOff;
          lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
          lookbehind.set(data, self2._lookbehindSize);
          self2._lookbehindSize += len;
          self2._bufPos = len;
          return len;
        }
        self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
        self2._lookbehindSize = 0;
      }
      pos += self2._bufPos;
      const firstNeedleChar = needle[0];
      while (pos <= end) {
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
          ++self2.matches;
          if (pos > 0)
            self2._cb(true, data, self2._bufPos, pos, true);
          else
            self2._cb(true, void 0, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < len) {
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
          ++pos;
          continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self2._lookbehindSize = len - pos;
        break;
      }
      if (pos > 0)
        self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
      self2._bufPos = len;
      return len;
    }
    function matchNeedle(self2, data, pos, len) {
      const lb = self2._lookbehind;
      const lbSize = self2._lookbehindSize;
      const needle = self2._needle;
      for (let i = 0; i < len; ++i, ++pos) {
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i])
          return false;
      }
      return true;
    }
    module2.exports = SBMH;
  }
});

// node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable, Writable } = require("stream");
    var StreamSearch = require_sbmh();
    var {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    } = require_utils2();
    var BUF_CRLF = Buffer.from("\r\n");
    var BUF_CR = Buffer.from("\r");
    var BUF_DASH = Buffer.from("-");
    function noop2() {
    }
    var MAX_HEADER_PAIRS = 2e3;
    var MAX_HEADER_SIZE = 16 * 1024;
    var HPARSER_NAME = 0;
    var HPARSER_PRE_OWS = 1;
    var HPARSER_VALUE = 2;
    var HeaderParser = class {
      constructor(cb) {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
        this.cb = cb;
      }
      reset() {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
      }
      push(chunk, pos, end) {
        let start = pos;
        while (pos < end) {
          switch (this.state) {
            case HPARSER_NAME: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (TOKEN[code] !== 1) {
                  if (code !== 58)
                    return -1;
                  this.name += chunk.latin1Slice(start, pos);
                  if (this.name.length === 0)
                    return -1;
                  ++pos;
                  done = true;
                  this.state = HPARSER_PRE_OWS;
                  break;
                }
              }
              if (!done) {
                this.name += chunk.latin1Slice(start, pos);
                break;
              }
            }
            case HPARSER_PRE_OWS: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code !== 32 && code !== 9) {
                  start = pos;
                  done = true;
                  this.state = HPARSER_VALUE;
                  break;
                }
              }
              if (!done)
                break;
            }
            case HPARSER_VALUE:
              switch (this.crlf) {
                case 0:
                  for (; pos < end; ++pos) {
                    if (this.byteCount === MAX_HEADER_SIZE)
                      return -1;
                    ++this.byteCount;
                    const code = chunk[pos];
                    if (FIELD_VCHAR[code] !== 1) {
                      if (code !== 13)
                        return -1;
                      ++this.crlf;
                      break;
                    }
                  }
                  this.value += chunk.latin1Slice(start, pos++);
                  break;
                case 1:
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  ++this.crlf;
                  break;
                case 2: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (code === 32 || code === 9) {
                    start = pos;
                    this.crlf = 0;
                  } else {
                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                      this.name = this.name.toLowerCase();
                      if (this.header[this.name] === void 0)
                        this.header[this.name] = [this.value];
                      else
                        this.header[this.name].push(this.value);
                    }
                    if (code === 13) {
                      ++this.crlf;
                      ++pos;
                    } else {
                      start = pos;
                      this.crlf = 0;
                      this.state = HPARSER_NAME;
                      this.name = "";
                      this.value = "";
                    }
                  }
                  break;
                }
                case 3: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  const header = this.header;
                  this.reset();
                  this.cb(header);
                  return pos;
                }
              }
              break;
          }
        }
        return pos;
      }
    };
    var FileStream = class extends Readable {
      constructor(opts, owner) {
        super(opts);
        this.truncated = false;
        this._readcb = null;
        this.once("end", () => {
          this._read();
          if (--owner._fileEndsLeft === 0 && owner._finalcb) {
            const cb = owner._finalcb;
            owner._finalcb = null;
            process.nextTick(cb);
          }
        });
      }
      _read(n) {
        const cb = this._readcb;
        if (cb) {
          this._readcb = null;
          cb();
        }
      }
    };
    var ignoreData = {
      push: (chunk, pos) => {
      },
      destroy: () => {
      }
    };
    function callAndUnsetCb(self2, err) {
      const cb = self2._writecb;
      self2._writecb = null;
      if (err)
        self2.destroy(err);
      else if (cb)
        cb();
    }
    function nullDecoder(val, hint) {
      return val;
    }
    var Multipart = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
          throw new Error("Multipart: Boundary not found");
        const boundary = cfg.conType.params.boundary;
        const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
        const defCharset = cfg.defCharset || "utf8";
        const preservePath = cfg.preservePath;
        const fileOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
        };
        const limits = cfg.limits;
        const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
        const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
        const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
        let parts = -1;
        let fields = 0;
        let files = 0;
        let skipPart = false;
        this._fileEndsLeft = 0;
        this._fileStream = void 0;
        this._complete = false;
        let fileSize = 0;
        let field;
        let fieldSize = 0;
        let partCharset;
        let partEncoding;
        let partType;
        let partName;
        let partTruncated = false;
        let hitFilesLimit = false;
        let hitFieldsLimit = false;
        this._hparser = null;
        const hparser = new HeaderParser((header) => {
          this._hparser = null;
          skipPart = false;
          partType = "text/plain";
          partCharset = defCharset;
          partEncoding = "7bit";
          partName = void 0;
          partTruncated = false;
          let filename;
          if (!header["content-disposition"]) {
            skipPart = true;
            return;
          }
          const disp = parseDisposition(
            header["content-disposition"][0],
            paramDecoder
          );
          if (!disp || disp.type !== "form-data") {
            skipPart = true;
            return;
          }
          if (disp.params) {
            if (disp.params.name)
              partName = disp.params.name;
            if (disp.params["filename*"])
              filename = disp.params["filename*"];
            else if (disp.params.filename)
              filename = disp.params.filename;
            if (filename !== void 0 && !preservePath)
              filename = basename(filename);
          }
          if (header["content-type"]) {
            const conType = parseContentType(header["content-type"][0]);
            if (conType) {
              partType = `${conType.type}/${conType.subtype}`;
              if (conType.params && typeof conType.params.charset === "string")
                partCharset = conType.params.charset.toLowerCase();
            }
          }
          if (header["content-transfer-encoding"])
            partEncoding = header["content-transfer-encoding"][0].toLowerCase();
          if (partType === "application/octet-stream" || filename !== void 0) {
            if (files === filesLimit) {
              if (!hitFilesLimit) {
                hitFilesLimit = true;
                this.emit("filesLimit");
              }
              skipPart = true;
              return;
            }
            ++files;
            if (this.listenerCount("file") === 0) {
              skipPart = true;
              return;
            }
            fileSize = 0;
            this._fileStream = new FileStream(fileOpts, this);
            ++this._fileEndsLeft;
            this.emit(
              "file",
              partName,
              this._fileStream,
              {
                filename,
                encoding: partEncoding,
                mimeType: partType
              }
            );
          } else {
            if (fields === fieldsLimit) {
              if (!hitFieldsLimit) {
                hitFieldsLimit = true;
                this.emit("fieldsLimit");
              }
              skipPart = true;
              return;
            }
            ++fields;
            if (this.listenerCount("field") === 0) {
              skipPart = true;
              return;
            }
            field = [];
            fieldSize = 0;
          }
        });
        let matchPostBoundary = 0;
        const ssCb = (isMatch, data, start, end, isDataSafe) => {
          retrydata:
            while (data) {
              if (this._hparser !== null) {
                const ret = this._hparser.push(data, start, end);
                if (ret === -1) {
                  this._hparser = null;
                  hparser.reset();
                  this.emit("error", new Error("Malformed part header"));
                  break;
                }
                start = ret;
              }
              if (start === end)
                break;
              if (matchPostBoundary !== 0) {
                if (matchPostBoundary === 1) {
                  switch (data[start]) {
                    case 45:
                      matchPostBoundary = 2;
                      ++start;
                      break;
                    case 13:
                      matchPostBoundary = 3;
                      ++start;
                      break;
                    default:
                      matchPostBoundary = 0;
                  }
                  if (start === end)
                    return;
                }
                if (matchPostBoundary === 2) {
                  matchPostBoundary = 0;
                  if (data[start] === 45) {
                    this._complete = true;
                    this._bparser = ignoreData;
                    return;
                  }
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_DASH, 0, 1, false);
                  this._writecb = writecb;
                } else if (matchPostBoundary === 3) {
                  matchPostBoundary = 0;
                  if (data[start] === 10) {
                    ++start;
                    if (parts >= partsLimit)
                      break;
                    this._hparser = hparser;
                    if (start === end)
                      break;
                    continue retrydata;
                  } else {
                    const writecb = this._writecb;
                    this._writecb = noop2;
                    ssCb(false, BUF_CR, 0, 1, false);
                    this._writecb = writecb;
                  }
                }
              }
              if (!skipPart) {
                if (this._fileStream) {
                  let chunk;
                  const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fileSize += chunk.length;
                  if (fileSize === fileSizeLimit) {
                    if (chunk.length > 0)
                      this._fileStream.push(chunk);
                    this._fileStream.emit("limit");
                    this._fileStream.truncated = true;
                    skipPart = true;
                  } else if (!this._fileStream.push(chunk)) {
                    if (this._writecb)
                      this._fileStream._readcb = this._writecb;
                    this._writecb = null;
                  }
                } else if (field !== void 0) {
                  let chunk;
                  const actualLen = Math.min(
                    end - start,
                    fieldSizeLimit - fieldSize
                  );
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fieldSize += actualLen;
                  field.push(chunk);
                  if (fieldSize === fieldSizeLimit) {
                    skipPart = true;
                    partTruncated = true;
                  }
                }
              }
              break;
            }
          if (isMatch) {
            matchPostBoundary = 1;
            if (this._fileStream) {
              this._fileStream.push(null);
              this._fileStream = null;
            } else if (field !== void 0) {
              let data2;
              switch (field.length) {
                case 0:
                  data2 = "";
                  break;
                case 1:
                  data2 = convertToUTF8(field[0], partCharset, 0);
                  break;
                default:
                  data2 = convertToUTF8(
                    Buffer.concat(field, fieldSize),
                    partCharset,
                    0
                  );
              }
              field = void 0;
              fieldSize = 0;
              this.emit(
                "field",
                partName,
                data2,
                {
                  nameTruncated: false,
                  valueTruncated: partTruncated,
                  encoding: partEncoding,
                  mimeType: partType
                }
              );
            }
            if (++parts === partsLimit)
              this.emit("partsLimit");
          }
        };
        this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
        this._writecb = null;
        this._finalcb = null;
        this.write(BUF_CRLF);
      }
      static detect(conType) {
        return conType.type === "multipart" && conType.subtype === "form-data";
      }
      _write(chunk, enc, cb) {
        this._writecb = cb;
        this._bparser.push(chunk, 0);
        if (this._writecb)
          callAndUnsetCb(this);
      }
      _destroy(err, cb) {
        this._hparser = null;
        this._bparser = ignoreData;
        if (!err)
          err = checkEndState(this);
        const fileStream = this._fileStream;
        if (fileStream) {
          this._fileStream = null;
          fileStream.destroy(err);
        }
        cb(err);
      }
      _final(cb) {
        this._bparser.destroy();
        if (!this._complete)
          return cb(new Error("Unexpected end of form"));
        if (this._fileEndsLeft)
          this._finalcb = finalcb.bind(null, this, cb);
        else
          finalcb(this, cb);
      }
    };
    function finalcb(self2, cb, err) {
      if (err)
        return cb(err);
      err = checkEndState(self2);
      cb(err);
    }
    function checkEndState(self2) {
      if (self2._hparser)
        return new Error("Malformed part header");
      const fileStream = self2._fileStream;
      if (fileStream) {
        self2._fileStream = null;
        fileStream.destroy(new Error("Unexpected end of file"));
      }
      if (!self2._complete)
        return new Error("Unexpected end of form");
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var FIELD_VCHAR = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    module2.exports = Multipart;
  }
});

// node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var { getDecoder } = require_utils2();
    var URLEncoded = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        let charset = cfg.defCharset || "utf8";
        if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
          charset = cfg.conType.params.charset;
        this.charset = charset;
        const limits = cfg.limits;
        this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
        this._inKey = true;
        this._keyTrunc = false;
        this._valTrunc = false;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._fields = 0;
        this._key = "";
        this._val = "";
        this._byte = -2;
        this._lastPos = 0;
        this._encode = 0;
        this._decoder = getDecoder(charset);
      }
      static detect(conType) {
        return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
      }
      _write(chunk, enc, cb) {
        if (this._fields >= this.fieldsLimit)
          return cb();
        let i = 0;
        const len = chunk.length;
        this._lastPos = 0;
        if (this._byte !== -2) {
          i = readPctEnc(this, chunk, i, len);
          if (i === -1)
            return cb(new Error("Malformed urlencoded form"));
          if (i >= len)
            return cb();
          if (this._inKey)
            ++this._bytesKey;
          else
            ++this._bytesVal;
        }
        main:
          while (i < len) {
            if (this._inKey) {
              i = skipKeyBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 61:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    this._inKey = false;
                    continue main;
                  case 38:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0) {
                      this.emit(
                        "field",
                        this._key,
                        "",
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: false,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue;
                  case 43:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._key += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesKey;
                i = skipKeyBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
            } else {
              i = skipValBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 38:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._inKey = true;
                    this._val = this._decoder(this._val, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0 || this._bytesVal > 0) {
                      this.emit(
                        "field",
                        this._key,
                        this._val,
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: this._valTrunc,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue main;
                  case 43:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._val += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesVal;
                i = skipValBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
            }
          }
        cb();
      }
      _final(cb) {
        if (this._byte !== -2)
          return cb(new Error("Malformed urlencoded form"));
        if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
          if (this._inKey)
            this._key = this._decoder(this._key, this._encode);
          else
            this._val = this._decoder(this._val, this._encode);
          this.emit(
            "field",
            this._key,
            this._val,
            {
              nameTruncated: this._keyTrunc,
              valueTruncated: this._valTrunc,
              encoding: this.charset,
              mimeType: "text/plain"
            }
          );
        }
        cb();
      }
    };
    function readPctEnc(self2, chunk, pos, len) {
      if (pos >= len)
        return len;
      if (self2._byte === -1) {
        const hexUpper = HEX_VALUES[chunk[pos++]];
        if (hexUpper === -1)
          return -1;
        if (hexUpper >= 8)
          self2._encode = 2;
        if (pos < len) {
          const hexLower = HEX_VALUES[chunk[pos++]];
          if (hexLower === -1)
            return -1;
          if (self2._inKey)
            self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
          else
            self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
          self2._byte = -2;
          self2._lastPos = pos;
        } else {
          self2._byte = hexUpper;
        }
      } else {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
        else
          self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipKeyBytes(self2, chunk, pos, len) {
      if (self2._bytesKey > self2.fieldNameSizeLimit) {
        if (!self2._keyTrunc) {
          if (self2._lastPos < pos)
            self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._keyTrunc = true;
        for (; pos < len; ++pos) {
          const code = chunk[pos];
          if (code === 61 || code === 38)
            break;
          ++self2._bytesKey;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipValBytes(self2, chunk, pos, len) {
      if (self2._bytesVal > self2.fieldSizeLimit) {
        if (!self2._valTrunc) {
          if (self2._lastPos < pos)
            self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._valTrunc = true;
        for (; pos < len; ++pos) {
          if (chunk[pos] === 38)
            break;
          ++self2._bytesVal;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = URLEncoded;
  }
});

// node_modules/busboy/lib/index.js
var require_lib = __commonJS({
  "node_modules/busboy/lib/index.js"(exports2, module2) {
    "use strict";
    var { parseContentType } = require_utils2();
    function getInstance(cfg) {
      const headers = cfg.headers;
      const conType = parseContentType(headers["content-type"]);
      if (!conType)
        throw new Error("Malformed content type");
      for (const type of TYPES) {
        const matched = type.detect(conType);
        if (!matched)
          continue;
        const instanceCfg = {
          limits: cfg.limits,
          headers,
          conType,
          highWaterMark: void 0,
          fileHwm: void 0,
          defCharset: void 0,
          defParamCharset: void 0,
          preservePath: false
        };
        if (cfg.highWaterMark)
          instanceCfg.highWaterMark = cfg.highWaterMark;
        if (cfg.fileHwm)
          instanceCfg.fileHwm = cfg.fileHwm;
        instanceCfg.defCharset = cfg.defCharset;
        instanceCfg.defParamCharset = cfg.defParamCharset;
        instanceCfg.preservePath = cfg.preservePath;
        return new type(instanceCfg);
      }
      throw new Error(`Unsupported content type: ${headers["content-type"]}`);
    }
    var TYPES = [
      require_multipart(),
      require_urlencoded()
    ].filter(function(typemod) {
      return typeof typemod.detect === "function";
    });
    module2.exports = (cfg) => {
      if (typeof cfg !== "object" || cfg === null)
        cfg = {};
      if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
        throw new Error("Missing Content-Type");
      }
      return getInstance(cfg);
    };
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/File.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillFile = void 0;
    var Blob_js_1 = require_Blob();
    var PonyfillFile = class extends Blob_js_1.PonyfillBlob {
      constructor(fileBits, name, options) {
        super(fileBits, options);
        this.name = name;
        this.webkitRelativePath = "";
        this.lastModified = options?.lastModified || Date.now();
      }
    };
    exports2.PonyfillFile = PonyfillFile;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/FormData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStreamFromFormData = exports2.PonyfillFormData = void 0;
    var File_js_1 = require_File();
    var ReadableStream_js_1 = require_ReadableStream();
    var PonyfillFormData = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      append(name, value, fileName) {
        let values = this.map.get(name);
        if (!values) {
          values = [];
          this.map.set(name, values);
        }
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        values.push(entry);
      }
      delete(name) {
        this.map.delete(name);
      }
      get(name) {
        const values = this.map.get(name);
        return values ? values[0] : null;
      }
      getAll(name) {
        return this.map.get(name) || [];
      }
      has(name) {
        return this.map.has(name);
      }
      set(name, value, fileName) {
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        this.map.set(name, [entry]);
      }
      *[Symbol.iterator]() {
        for (const [key, values] of this.map) {
          for (const value of values) {
            yield [key, value];
          }
        }
      }
      entries() {
        return this[Symbol.iterator]();
      }
      keys() {
        return this.map.keys();
      }
      *values() {
        for (const values of this.map.values()) {
          for (const value of values) {
            yield value;
          }
        }
      }
      forEach(callback) {
        for (const [key, value] of this) {
          callback(value, key, this);
        }
      }
    };
    exports2.PonyfillFormData = PonyfillFormData;
    function getStreamFromFormData(formData, boundary = "---") {
      const entries = [];
      let sentInitialHeader = false;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          formData.forEach((value, key) => {
            if (!sentInitialHeader) {
              controller.enqueue(Buffer.from(`--${boundary}\r
`));
              sentInitialHeader = true;
            }
            entries.push([key, value]);
          });
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}--\r
`));
            controller.close();
          }
        },
        pull: async (controller) => {
          const entry = entries.shift();
          if (entry) {
            const [key, value] = entry;
            if (typeof value === "string") {
              controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r
\r
`));
              controller.enqueue(Buffer.from(value));
            } else {
              let filenamePart = "";
              if (value.name) {
                filenamePart = `; filename="${value.name}"`;
              }
              controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r
`));
              controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r
\r
`));
              const entryStream = value.stream();
              for await (const chunk of entryStream) {
                controller.enqueue(chunk);
              }
            }
            if (entries.length === 0) {
              controller.enqueue(Buffer.from(`\r
--${boundary}--\r
`));
              controller.close();
            } else {
              controller.enqueue(Buffer.from(`\r
--${boundary}\r
`));
            }
          } else {
            controller.enqueue(Buffer.from(`\r
--${boundary}--\r
`));
            controller.close();
          }
        }
      });
    }
    exports2.getStreamFromFormData = getStreamFromFormData;
    function getNormalizedFile(name, blob, fileName) {
      if (blob instanceof File_js_1.PonyfillFile) {
        if (fileName != null) {
          return new File_js_1.PonyfillFile([blob], fileName, {
            type: blob.type,
            lastModified: blob.lastModified
          });
        }
        return blob;
      }
      return new File_js_1.PonyfillFile([blob], fileName || name, { type: blob.type });
    }
    function isBlob(value) {
      return value != null && typeof value === "object" && typeof value.arrayBuffer === "function";
    }
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Body.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBody = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var stream_1 = require("stream");
    var busboy_1 = tslib_1.__importDefault(require_lib());
    var Blob_js_1 = require_Blob();
    var File_js_1 = require_File();
    var FormData_js_1 = require_FormData();
    var ReadableStream_js_1 = require_ReadableStream();
    var utils_js_1 = require_utils();
    var BodyInitType;
    (function(BodyInitType2) {
      BodyInitType2["ReadableStream"] = "ReadableStream";
      BodyInitType2["Blob"] = "Blob";
      BodyInitType2["FormData"] = "FormData";
      BodyInitType2["ArrayBuffer"] = "ArrayBuffer";
      BodyInitType2["String"] = "String";
      BodyInitType2["Readable"] = "Readable";
      BodyInitType2["Buffer"] = "Buffer";
      BodyInitType2["Uint8Array"] = "Uint8Array";
    })(BodyInitType || (BodyInitType = {}));
    var PonyfillBody = class {
      constructor(bodyInit, options = {}) {
        this.bodyInit = bodyInit;
        this.options = options;
        this.bodyUsed = false;
        this.contentType = null;
        this.contentLength = null;
        this._bodyFactory = () => null;
        this._generatedBody = null;
        const { bodyFactory, contentType, contentLength, bodyType } = processBodyInit(bodyInit);
        this._bodyFactory = bodyFactory;
        this.contentType = contentType;
        this.contentLength = contentLength;
        this.bodyType = bodyType;
      }
      generateBody() {
        if (this._generatedBody) {
          return this._generatedBody;
        }
        const body = this._bodyFactory();
        this._generatedBody = body;
        return body;
      }
      get body() {
        const _body = this.generateBody();
        if (_body != null) {
          const ponyfillReadableStream = _body;
          const readable = _body.readable;
          return new Proxy(_body.readable, {
            get(_2, prop) {
              if (prop in ponyfillReadableStream) {
                const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
                if (typeof ponyfillReadableStreamProp === "function") {
                  return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
                }
                return ponyfillReadableStreamProp;
              }
              if (prop in readable) {
                const readableProp = readable[prop];
                if (typeof readableProp === "function") {
                  return readableProp.bind(readable);
                }
                return readableProp;
              }
            }
          });
        }
        return null;
      }
      async arrayBuffer() {
        if (this.bodyType === BodyInitType.ArrayBuffer) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.Buffer) {
          const typedBodyInit = this.bodyInit;
          return (0, utils_js_1.uint8ArrayToArrayBuffer)(typedBodyInit);
        }
        if (this.bodyType === BodyInitType.String) {
          const buffer = Buffer.from(this.bodyInit);
          return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
        }
        if (this.bodyType === BodyInitType.Blob) {
          const blob2 = this.bodyInit;
          const arrayBuffer = await blob2.arrayBuffer();
          return arrayBuffer;
        }
        const blob = await this.blob();
        return blob.arrayBuffer();
      }
      _collectChunksFromReadable() {
        return new Promise((resolve, reject) => {
          const chunks = [];
          const _body = this.generateBody();
          if (_body) {
            _body.readable.on("data", (chunk) => {
              chunks.push(chunk);
            });
            _body.readable.on("end", () => {
              resolve(chunks);
            });
            _body.readable.on("error", (e) => {
              reject(e);
            });
          } else {
            resolve(chunks);
          }
        });
      }
      async blob() {
        if (this.bodyType === BodyInitType.Blob) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String || this.bodyType === BodyInitType.Buffer || this.bodyType === BodyInitType.Uint8Array) {
          const bodyInitTyped = this.bodyInit;
          return new Blob_js_1.PonyfillBlob([bodyInitTyped], {
            type: this.contentType || ""
          });
        }
        if (this.bodyType === BodyInitType.ArrayBuffer) {
          const bodyInitTyped = this.bodyInit;
          const buf = Buffer.from(bodyInitTyped, void 0, bodyInitTyped.byteLength);
          return new Blob_js_1.PonyfillBlob([buf], {
            type: this.contentType || ""
          });
        }
        const chunks = await this._collectChunksFromReadable();
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || ""
        });
      }
      formData(opts) {
        if (this.bodyType === BodyInitType.FormData) {
          return Promise.resolve(this.bodyInit);
        }
        const formData = new FormData_js_1.PonyfillFormData();
        const _body = this.generateBody();
        if (_body == null) {
          return Promise.resolve(formData);
        }
        const formDataLimits = {
          ...this.options.formDataLimits,
          ...opts?.formDataLimits
        };
        return new Promise((resolve, reject) => {
          const bb = (0, busboy_1.default)({
            headers: {
              "content-type": this.contentType || ""
            },
            limits: formDataLimits,
            defParamCharset: "utf-8"
          });
          bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
            if (nameTruncated) {
              reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
            }
            if (valueTruncated) {
              reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
            }
            formData.set(name, value);
          });
          bb.on("fieldsLimit", () => {
            reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
          });
          bb.on("file", (name, fileStream, { filename, mimeType }) => {
            const chunks = [];
            fileStream.on("limit", () => {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            });
            fileStream.on("data", (chunk) => {
              chunks.push(Buffer.from(chunk));
            });
            fileStream.on("close", () => {
              if (fileStream.truncated) {
                reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
              }
              const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
              formData.set(name, file);
            });
          });
          bb.on("filesLimit", () => {
            reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
          });
          bb.on("partsLimit", () => {
            reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
          });
          bb.on("close", () => {
            resolve(formData);
          });
          bb.on("error", (err) => {
            reject(err);
          });
          _body?.readable.pipe(bb);
        });
      }
      async buffer() {
        if (this.bodyType === BodyInitType.Buffer) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String) {
          return Buffer.from(this.bodyInit);
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.ArrayBuffer) {
          const bodyInitTyped = this.bodyInit;
          const buffer = Buffer.from(bodyInitTyped, "byteOffset" in bodyInitTyped ? bodyInitTyped.byteOffset : void 0, bodyInitTyped.byteLength);
          return buffer;
        }
        if (this.bodyType === BodyInitType.Blob) {
          if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
            return this.bodyInit.buffer();
          }
          const bodyInitTyped = this.bodyInit;
          const buffer = Buffer.from(await bodyInitTyped.arrayBuffer(), void 0, bodyInitTyped.size);
          return buffer;
        }
        const chunks = await this._collectChunksFromReadable();
        return Buffer.concat(chunks);
      }
      async json() {
        const text = await this.text();
        return JSON.parse(text);
      }
      async text() {
        if (this.bodyType === BodyInitType.String) {
          return this.bodyInit;
        }
        const buffer = await this.buffer();
        return buffer.toString("utf-8");
      }
    };
    exports2.PonyfillBody = PonyfillBody;
    function processBodyInit(bodyInit) {
      if (bodyInit == null) {
        return {
          bodyFactory: () => null,
          contentType: null,
          contentLength: null
        };
      }
      if (typeof bodyInit === "string") {
        const buffer = Buffer.from(bodyInit);
        const contentLength = buffer.byteLength;
        return {
          bodyType: BodyInitType.String,
          contentType: "text/plain;charset=UTF-8",
          contentLength,
          bodyFactory() {
            const readable = stream_1.Readable.from(buffer);
            return new ReadableStream_js_1.PonyfillReadableStream(readable);
          }
        };
      }
      if (bodyInit instanceof Buffer) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.Buffer,
          contentLength,
          contentType: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
        return {
          bodyType: BodyInitType.ReadableStream,
          bodyFactory: () => bodyInit,
          contentType: null,
          contentLength: null
        };
      }
      if (bodyInit instanceof Blob_js_1.PonyfillBlob) {
        return {
          bodyType: BodyInitType.Blob,
          contentType: bodyInit.type,
          contentLength: bodyInit.size,
          bodyFactory() {
            return bodyInit.stream();
          }
        };
      }
      if (bodyInit instanceof Uint8Array) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.Uint8Array,
          contentLength,
          contentType: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if ("buffer" in bodyInit) {
        const contentLength = bodyInit.byteLength;
        return {
          contentLength,
          contentType: null,
          bodyFactory() {
            const buffer = Buffer.from(bodyInit);
            const readable = stream_1.Readable.from(buffer);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof ArrayBuffer) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.ArrayBuffer,
          contentType: null,
          contentLength,
          bodyFactory() {
            const buffer = Buffer.from(bodyInit, void 0, bodyInit.byteLength);
            const readable = stream_1.Readable.from(buffer);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof stream_1.Readable) {
        return {
          bodyType: BodyInitType.Readable,
          contentType: null,
          contentLength: null,
          bodyFactory() {
            const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
            return body;
          }
        };
      }
      if ("stream" in bodyInit) {
        return {
          contentType: bodyInit.type,
          contentLength: bodyInit.size,
          bodyFactory() {
            const bodyStream = bodyInit.stream();
            const body = new ReadableStream_js_1.PonyfillReadableStream(bodyStream);
            return body;
          }
        };
      }
      if ("sort" in bodyInit) {
        const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
        return {
          bodyType: BodyInitType.String,
          contentType,
          contentLength: null,
          bodyFactory() {
            const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
            return body;
          }
        };
      }
      if ("forEach" in bodyInit) {
        const boundary = Math.random().toString(36).substr(2);
        const contentType = `multipart/form-data; boundary=${boundary}`;
        return {
          contentType,
          contentLength: null,
          bodyFactory() {
            return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
          }
        };
      }
      if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
        return {
          contentType: null,
          contentLength: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            return new ReadableStream_js_1.PonyfillReadableStream(readable);
          }
        };
      }
      throw new Error("Unknown body type");
    }
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Headers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitSetCookieHeader = exports2.PonyfillHeaders = exports2.isHeadersLike = void 0;
    var node_util_1 = require("node:util");
    function isHeadersLike(headers) {
      return headers?.get && headers?.forEach;
    }
    exports2.isHeadersLike = isHeadersLike;
    var PonyfillHeaders = class {
      constructor(headersInit) {
        this.headersInit = headersInit;
        this.objectNormalizedKeysOfHeadersInit = [];
        this.objectOriginalKeysOfHeadersInit = [];
      }
      // perf: we don't need to build `this.map` for Requests, as we can access the headers directly
      _get(key) {
        if (this._map) {
          return this._map.get(key.toLowerCase()) || null;
        }
        if (this.headersInit == null) {
          return null;
        }
        const normalized = key.toLowerCase();
        if (Array.isArray(this.headersInit)) {
          return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
        } else if (isHeadersLike(this.headersInit)) {
          return this.headersInit.get(normalized);
        } else {
          const initValue = this.headersInit[key] || this.headersInit[normalized];
          if (initValue != null) {
            return initValue;
          }
          if (!this.objectNormalizedKeysOfHeadersInit.length) {
            Object.keys(this.headersInit).forEach((k2) => {
              this.objectOriginalKeysOfHeadersInit.push(k2);
              this.objectNormalizedKeysOfHeadersInit.push(k2.toLowerCase());
            });
          }
          const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
          if (index === -1) {
            return null;
          }
          const originalKey = this.objectOriginalKeysOfHeadersInit[index];
          return this.headersInit[originalKey];
        }
      }
      // perf: Build the map of headers lazily, only when we need to access all headers or write to it.
      // I could do a getter here, but I'm too lazy to type `getter`.
      getMap() {
        if (!this._map) {
          if (this.headersInit != null) {
            if (Array.isArray(this.headersInit)) {
              this._map = new Map(this.headersInit);
            } else if (isHeadersLike(this.headersInit)) {
              this._map = /* @__PURE__ */ new Map();
              this.headersInit.forEach((value, key) => {
                this._map.set(key, value);
              });
            } else {
              this._map = /* @__PURE__ */ new Map();
              for (const initKey in this.headersInit) {
                const initValue = this.headersInit[initKey];
                if (initValue != null) {
                  const normalizedKey = initKey.toLowerCase();
                  this._map.set(normalizedKey, initValue);
                }
              }
            }
          } else {
            this._map = /* @__PURE__ */ new Map();
          }
        }
        return this._map;
      }
      append(name, value) {
        const key = name.toLowerCase();
        const existingValue = this.getMap().get(key);
        const finalValue = existingValue ? `${existingValue}, ${value}` : value;
        this.getMap().set(key, finalValue);
      }
      get(name) {
        const value = this._get(name);
        if (value == null) {
          return null;
        }
        return value;
      }
      has(name) {
        return !!this._get(name);
      }
      set(name, value) {
        const key = name.toLowerCase();
        this.getMap().set(key, value);
      }
      delete(name) {
        const key = name.toLowerCase();
        this.getMap().delete(key);
      }
      forEach(callback) {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              this.headersInit.forEach(([key, value]) => {
                callback(value, key, this);
              });
              return;
            }
            if (isHeadersLike(this.headersInit)) {
              this.headersInit.forEach(callback);
              return;
            }
            Object.entries(this.headersInit).forEach(([key, value]) => {
              if (value != null) {
                callback(value, key, this);
              }
            });
          }
          return;
        }
        this.getMap().forEach((value, key) => {
          callback(value, key, this);
        });
      }
      keys() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit.map(([key]) => key)[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.keys();
            }
            return Object.keys(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().keys();
      }
      values() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.values();
            }
            return Object.values(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().values();
      }
      entries() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.entries();
            }
            return Object.entries(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().entries();
      }
      getSetCookie() {
        const setCookieHeader = this.get("set-cookie");
        if (!setCookieHeader) {
          return [];
        }
        return splitSetCookieHeader(setCookieHeader);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        const record = {};
        this.forEach((value, key) => {
          if (key === "set-cookie") {
            record["set-cookie"] = this.getSetCookie();
          } else {
            record[key] = value.includes(",") ? value.split(",").map((el2) => el2.trim()) : value;
          }
        });
        return `Headers ${(0, node_util_1.inspect)(record)}`;
      }
    };
    exports2.PonyfillHeaders = PonyfillHeaders;
    function splitSetCookieHeader(setCookieHeader) {
      const setCookieHeaders = [];
      let currentStr = "";
      let ignoreComma = false;
      for (const ch of setCookieHeader) {
        if (currentStr.endsWith("Expires=")) {
          ignoreComma = true;
        }
        if (ignoreComma) {
          if (ch === ";") {
            ignoreComma = false;
          }
          if (ch === "," && currentStr.split("Expires=")[1].length > 3) {
            ignoreComma = false;
          }
        }
        if (ch === "," && !ignoreComma) {
          setCookieHeaders.push(currentStr.trim());
          currentStr = "";
        } else {
          currentStr += ch;
        }
      }
      if (currentStr) {
        setCookieHeaders.push(currentStr.trim());
      }
      return setCookieHeaders;
    }
    exports2.splitSetCookieHeader = splitSetCookieHeader;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Response.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillResponse = void 0;
    var http_1 = require("http");
    var Body_js_1 = require_Body();
    var Headers_js_1 = require_Headers();
    var JSON_CONTENT_TYPE = "application/json; charset=utf-8";
    var PonyfillResponse = class _PonyfillResponse extends Body_js_1.PonyfillBody {
      constructor(body, init) {
        super(body || null, init);
        this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
        this.status = init?.status || 200;
        this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
        this.url = init?.url || "";
        this.redirected = init?.redirected || false;
        this.type = init?.type || "default";
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      clone() {
        return new _PonyfillResponse(this.body, this);
      }
      static error() {
        return new _PonyfillResponse(null, {
          status: 500,
          statusText: "Internal Server Error"
        });
      }
      static redirect(url, status = 301) {
        if (status < 300 || status > 399) {
          throw new RangeError("Invalid status code");
        }
        return new _PonyfillResponse(null, {
          headers: {
            location: url
          },
          status
        });
      }
      static json(data, init = {}) {
        init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
        if (!init.headers.has("content-type")) {
          init.headers.set("content-type", JSON_CONTENT_TYPE);
        }
        return new _PonyfillResponse(JSON.stringify(data), init);
      }
    };
    exports2.PonyfillResponse = PonyfillResponse;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchCurl = void 0;
    var node_stream_1 = require("node:stream");
    var Response_js_1 = require_Response();
    var utils_js_1 = require_utils();
    function fetchCurl(fetchRequest) {
      const { Curl, CurlCode, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
      const curlHandle = new Curl();
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          curlHandle.pause(CurlPause.Recv);
        };
      }
      curlHandle.enable(CurlFeature.NoDataParsing);
      curlHandle.setOpt("URL", fetchRequest.url);
      curlHandle.setOpt("SSL_VERIFYPEER", false);
      curlHandle.enable(CurlFeature.StreamResponse);
      curlHandle.setStreamProgressCallback(function() {
        return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
      });
      if (fetchRequest["bodyType"] === "String") {
        curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
      } else {
        const nodeReadable = fetchRequest.body != null ? "pipe" in fetchRequest.body ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
        if (nodeReadable) {
          curlHandle.setOpt("UPLOAD", true);
          curlHandle.setUploadStream(nodeReadable);
        }
      }
      if (process.env.DEBUG) {
        curlHandle.setOpt("VERBOSE", true);
      }
      curlHandle.setOpt("TRANSFER_ENCODING", false);
      curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
      curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
      curlHandle.setOpt("MAXREDIRS", 20);
      curlHandle.setOpt("ACCEPT_ENCODING", "");
      curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
      const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
      let size;
      const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
        size = Number(value);
      });
      if (size != null) {
        curlHandle.setOpt("INFILESIZE", size);
      }
      curlHandle.setOpt("HTTPHEADER", curlHeaders);
      curlHandle.enable(CurlFeature.NoHeaderParsing);
      return new Promise(function promiseResolver(resolve, reject) {
        curlHandle.once("end", function endListener() {
          curlHandle.close();
        });
        curlHandle.once("error", function errorListener(error) {
          if (error.isCurlError && error.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
          } else {
            reject(error);
          }
          curlHandle.close();
        });
        curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
          const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
            if (headerFilter && !headerFilter.startsWith("HTTP/")) {
              if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
                reject(new Error("redirect is not allowed"));
              }
              return true;
            }
            return false;
          });
          const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
          resolve(new Response_js_1.PonyfillResponse(stream, {
            status,
            headers: headersInit,
            url: fetchRequest.url
          }));
        });
        curlHandle.perform();
      });
    }
    exports2.fetchCurl = fetchCurl;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillAbortError = void 0;
    var PonyfillAbortError = class extends Error {
      constructor(reason) {
        let message = "The operation was aborted";
        if (reason) {
          message += ` reason: ${reason}`;
        }
        super(message, {
          cause: reason
        });
        this.name = "AbortError";
      }
      get reason() {
        return this.cause;
      }
    };
    exports2.PonyfillAbortError = PonyfillAbortError;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/Request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillRequest = void 0;
    var Body_js_1 = require_Body();
    var Headers_js_1 = require_Headers();
    function isRequest(input) {
      return input[Symbol.toStringTag] === "Request";
    }
    var PonyfillRequest = class _PonyfillRequest extends Body_js_1.PonyfillBody {
      constructor(input, options) {
        let url;
        let bodyInit = null;
        let requestInit;
        if (typeof input === "string") {
          url = input;
        } else if ("href" in input) {
          url = input.toString();
        } else if (isRequest(input)) {
          url = input.url;
          bodyInit = input.body;
          requestInit = input;
        }
        if (options != null) {
          bodyInit = options.body || null;
          requestInit = options;
        }
        super(bodyInit, options);
        this.cache = requestInit?.cache || "default";
        this.credentials = requestInit?.credentials || "same-origin";
        this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
        this.integrity = requestInit?.integrity || "";
        this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
        this.method = requestInit?.method?.toUpperCase() || "GET";
        this.mode = requestInit?.mode || "cors";
        this.redirect = requestInit?.redirect || "follow";
        this.referrer = requestInit?.referrer || "about:client";
        this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
        this._signal = requestInit?.signal;
        this.headersSerializer = requestInit?.headersSerializer;
        this.url = url || "";
        this.destination = "document";
        this.priority = "auto";
        if (this.method !== "GET" && this.method !== "HEAD") {
          const contentTypeInHeaders = this.headers.get("content-type");
          if (!contentTypeInHeaders) {
            if (this.contentType) {
              this.headers.set("content-type", this.contentType);
            }
          } else {
            this.contentType = contentTypeInHeaders;
          }
          const contentLengthInHeaders = this.headers.get("content-length");
          if (!contentLengthInHeaders) {
            if (this.contentLength) {
              this.headers.set("content-length", this.contentLength.toString());
            }
          } else {
            this.contentLength = parseInt(contentLengthInHeaders, 10);
          }
        }
      }
      get signal() {
        if (!this._signal) {
          this._signal = new AbortController().signal;
        }
        return this._signal;
      }
      clone() {
        return new _PonyfillRequest(this);
      }
    };
    exports2.PonyfillRequest = PonyfillRequest;
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "node_modules/fast-decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      var percentPosition = uri.indexOf("%");
      if (percentPosition === -1)
        return uri;
      var length = uri.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
            55232 + (codepoint >> 10),
            56320 + (codepoint & 1023)
          );
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
            continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c, shift) {
      var i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
    module2.exports = decodeURIComponent2;
  }
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS({
  "node_modules/fast-querystring/lib/parse.js"(exports2, module2) {
    "use strict";
    var fastDecode = require_fast_decode_uri_component();
    var plusRegex = /\+/g;
    var Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function parse4(input) {
      const result = new Empty();
      if (typeof input !== "string") {
        return result;
      }
      let inputLength = input.length;
      let key = "";
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let hasBothKeyValuePair = false;
      let c = 0;
      for (let i = 0; i < inputLength + 1; i++) {
        c = i !== inputLength ? input.charCodeAt(i) : 38;
        if (c === 38) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i;
          }
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (keyHasPlus) {
              key = key.replace(plusRegex, " ");
            }
            if (shouldDecodeKey) {
              key = fastDecode(key) || key;
            }
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus) {
                value = value.replace(plusRegex, " ");
              }
              if (shouldDecodeValue) {
                value = fastDecode(value) || value;
              }
            }
            const currentValue = result[key];
            if (currentValue === void 0) {
              result[key] = value;
            } else {
              if (currentValue.pop) {
                currentValue.push(value);
              } else {
                result[key] = [currentValue, value];
              }
            }
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
        } else if (c === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
      }
      return result;
    }
    module2.exports = parse4;
  }
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS({
  "node_modules/fast-querystring/lib/internals/querystring.js"(exports2, module2) {
    var hexTable = Array.from(
      { length: 256 },
      (_2, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
    );
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 112 - 127
    ]);
    function encodeString(str) {
      const len = str.length;
      if (len === 0)
        return "";
      let out = "";
      let lastPos = 0;
      let i = 0;
      outer:
        for (; i < len; i++) {
          let c = str.charCodeAt(i);
          while (c < 128) {
            if (noEscape[c] !== 1) {
              if (lastPos < i)
                out += str.slice(lastPos, i);
              lastPos = i + 1;
              out += hexTable[c];
            }
            if (++i === len)
              break outer;
            c = str.charCodeAt(i);
          }
          if (lastPos < i)
            out += str.slice(lastPos, i);
          if (c < 2048) {
            lastPos = i + 1;
            out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            lastPos = i + 1;
            out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          ++i;
          if (i >= len) {
            throw new Error("URI malformed");
          }
          const c2 = str.charCodeAt(i) & 1023;
          lastPos = i + 1;
          c = 65536 + ((c & 1023) << 10 | c2);
          out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
      if (lastPos === 0)
        return str;
      if (lastPos < len)
        return out + str.slice(lastPos);
      return out;
    }
    module2.exports = { encodeString };
  }
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/fast-querystring/lib/stringify.js"(exports2, module2) {
    "use strict";
    var { encodeString } = require_querystring();
    function getAsPrimitive(value) {
      const type = typeof value;
      if (type === "string") {
        return encodeString(value);
      } else if (type === "bigint") {
        return value.toString();
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "number" && Number.isFinite(value)) {
        return value < 1e21 ? "" + value : encodeString("" + value);
      }
      return "";
    }
    function stringify(input) {
      let result = "";
      if (input === null || typeof input !== "object") {
        return result;
      }
      const separator = "&";
      const keys = Object.keys(input);
      const keyLength = keys.length;
      let valueLength = 0;
      for (let i = 0; i < keyLength; i++) {
        const key = keys[i];
        const value = input[key];
        const encodedKey = encodeString(key) + "=";
        if (i) {
          result += separator;
        }
        if (Array.isArray(value)) {
          valueLength = value.length;
          for (let j2 = 0; j2 < valueLength; j2++) {
            if (j2) {
              result += separator;
            }
            result += encodedKey;
            result += getAsPrimitive(value[j2]);
          }
        } else {
          result += encodedKey;
          result += getAsPrimitive(value);
        }
      }
      return result;
    }
    module2.exports = stringify;
  }
});

// node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/fast-querystring/lib/index.js"(exports2, module2) {
    "use strict";
    var parse4 = require_parse();
    var stringify = require_stringify();
    var fastQuerystring = {
      parse: parse4,
      stringify
    };
    module2.exports = fastQuerystring;
    module2.exports.default = fastQuerystring;
    module2.exports.parse = parse4;
    module2.exports.stringify = stringify;
  }
});

// node_modules/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS({
  "node_modules/fast-url-parser/src/urlparser.js"(exports2, module2) {
    "use strict";
    function Url() {
      this._protocol = null;
      this._href = "";
      this._port = -1;
      this._query = null;
      this.auth = null;
      this.slashes = null;
      this.host = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
      this._prependSlash = false;
    }
    var querystring = require("querystring");
    Url.queryString = querystring;
    Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
      if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
      }
      var start = 0;
      var end = str.length - 1;
      while (str.charCodeAt(start) <= 32)
        start++;
      while (str.charCodeAt(end) <= 32)
        end--;
      start = this._parseProtocol(str, start, end);
      if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
          this.hostname = this.host = "";
        }
      }
      if (start <= end) {
        var ch = str.charCodeAt(start);
        if (ch === 47 || ch === 92) {
          this._parsePath(str, start, end, disableAutoEscapeChars);
        } else if (ch === 63) {
          this._parseQuery(str, start, end, disableAutoEscapeChars);
        } else if (ch === 35) {
          this._parseHash(str, start, end, disableAutoEscapeChars);
        } else if (this._protocol !== "javascript") {
          this._parsePath(str, start, end, disableAutoEscapeChars);
        } else {
          this.pathname = str.slice(start, end + 1);
        }
      }
      if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
        this.pathname = "/";
      }
      if (parseQueryString) {
        var search = this.search;
        if (search == null) {
          search = this.search = "";
        }
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        this.query = Url.queryString.parse(search);
      }
    };
    Url.prototype.resolve = function Url$resolve(relative) {
      return this.resolveObject(Url.parse(relative, false, true)).format();
    };
    Url.prototype.format = function Url$format() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "";
      var pathname = this.pathname || "";
      var hash = this.hash || "";
      var search = this.search || "";
      var query = "";
      var hostname = this.hostname || "";
      var port = this.port || "";
      var host = false;
      var scheme = "";
      var q2 = this.query;
      if (q2 && typeof q2 === "object") {
        query = Url.queryString.stringify(q2);
      }
      if (!search) {
        search = query ? "?" + query : "";
      }
      if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
        protocol += ":";
      if (this.host) {
        host = auth + this.host;
      } else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6)
          hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
      }
      var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
      if (protocol)
        scheme = protocol + (slashes ? "//" : "");
      else if (slashes)
        scheme = "//";
      if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
        pathname = "/" + pathname;
      }
      if (search && search.charCodeAt(0) !== 63)
        search = "?" + search;
      if (hash && hash.charCodeAt(0) !== 35)
        hash = "#" + hash;
      pathname = escapePathName(pathname);
      search = escapeSearch(search);
      return scheme + (host === false ? "" : host) + pathname + search + hash;
    };
    Url.prototype.resolveObject = function Url$resolveObject(relative) {
      if (typeof relative === "string")
        relative = Url.parse(relative, false, true);
      var result = this._clone();
      result.hash = relative.hash;
      if (!relative.href) {
        result._href = "";
        return result;
      }
      if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);
        if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
        }
        result._href = "";
        return result;
      }
      if (relative._protocol && relative._protocol !== result._protocol) {
        if (!slashProtocols[relative._protocol]) {
          relative._copyPropsTo(result, false);
          result._href = "";
          return result;
        }
        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
      var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
      var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
      var removeAllDots = mustEndAbs;
      var srcPath = result.pathname && result.pathname.split("/") || [];
      var relPath = relative.pathname && relative.pathname.split("/") || [];
      var psychotic = result._protocol && !slashProtocols[result._protocol];
      if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
          relative.hostname = "";
          relative._port = -1;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host ? relative.host : result.host;
        result.hostname = relative.hostname ? relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
      } else if (relative.search) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result._href = "";
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        result._href = "";
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
      var up2 = 0;
      for (var i2 = srcPath.length; i2 >= 0; i2--) {
        last = srcPath[i2];
        if (last === ".") {
          srcPath.splice(i2, 1);
        } else if (last === "..") {
          srcPath.splice(i2, 1);
          up2++;
        } else if (up2) {
          srcPath.splice(i2, 1);
          up2--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up2--; up2) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    };
    var punycode = require("punycode");
    Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
      return punycode.toASCII(hostname);
    };
    var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
      if (!containsCharacter2(
        pathname,
        35,
        63
        /*'?'*/
      )) {
        return pathname;
      }
      return _escapePath(pathname);
    };
    var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
      if (!containsCharacter2(search, 35, -1))
        return search;
      return _escapeSearch(search);
    };
    Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
      var doLowerCase = false;
      var protocolCharacters = this._protocolCharacters;
      for (var i2 = start; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 58) {
          var protocol = str.slice(start, i2);
          if (doLowerCase)
            protocol = protocol.toLowerCase();
          this._protocol = protocol;
          return i2 + 1;
        } else if (protocolCharacters[ch] === 1) {
          if (ch < 97)
            doLowerCase = true;
        } else {
          return start;
        }
      }
      return start;
    };
    Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
      var auth = str.slice(start, end + 1);
      if (decode) {
        auth = decodeURIComponent(auth);
      }
      this.auth = auth;
    };
    Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
      var port = 0;
      var hadChars = false;
      var validPort = true;
      for (var i2 = start; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (48 <= ch && ch <= 57) {
          port = 10 * port + (ch - 48);
          hadChars = true;
        } else {
          validPort = false;
          if (ch === 92 || ch === 47) {
            validPort = true;
          }
          break;
        }
      }
      if (port === 0 && !hadChars || !validPort) {
        if (!validPort) {
          this._port = -2;
        }
        return 0;
      }
      this._port = port;
      return i2 - start;
    };
    Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
      var hostEndingCharacters = this._hostEndingCharacters;
      var first = str.charCodeAt(start);
      var second = str.charCodeAt(start + 1);
      if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
        this.slashes = true;
        if (start === 0) {
          if (end < 2)
            return start;
          var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
          if (!hasAuth && !slashesDenoteHost) {
            this.slashes = null;
            return start;
          }
        }
        start += 2;
      } else if (!this._protocol || //2. there was a protocol that requires slashes
      //e.g. in 'http:asd' 'asd' is not a hostname
      slashProtocols[this._protocol]) {
        return start;
      }
      var doLowerCase = false;
      var idna = false;
      var hostNameStart = start;
      var hostNameEnd = end;
      var lastCh = -1;
      var portLength = 0;
      var charsAfterDot = 0;
      var authNeedsDecoding = false;
      var j2 = -1;
      for (var i2 = start; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 64) {
          j2 = i2;
        } else if (ch === 37) {
          authNeedsDecoding = true;
        } else if (hostEndingCharacters[ch] === 1) {
          break;
        }
      }
      if (j2 > -1) {
        this._parseAuth(str, start, j2 - 1, authNeedsDecoding);
        start = hostNameStart = j2 + 1;
      }
      if (str.charCodeAt(start) === 91) {
        for (var i2 = start + 1; i2 <= end; ++i2) {
          var ch = str.charCodeAt(i2);
          if (ch === 93) {
            if (str.charCodeAt(i2 + 1) === 58) {
              portLength = this._parsePort(str, i2 + 2, end) + 1;
            }
            var hostname = str.slice(start + 1, i2).toLowerCase();
            this.hostname = hostname;
            this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
            this.pathname = "/";
            return i2 + portLength + 1;
          }
        }
        return start;
      }
      for (var i2 = start; i2 <= end; ++i2) {
        if (charsAfterDot > 62) {
          this.hostname = this.host = str.slice(start, i2);
          return i2;
        }
        var ch = str.charCodeAt(i2);
        if (ch === 58) {
          portLength = this._parsePort(str, i2 + 1, end) + 1;
          hostNameEnd = i2 - 1;
          break;
        } else if (ch < 97) {
          if (ch === 46) {
            charsAfterDot = -1;
          } else if (65 <= ch && ch <= 90) {
            doLowerCase = true;
          } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
            if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
              this._prependSlash = true;
            }
            hostNameEnd = i2 - 1;
            break;
          }
        } else if (ch >= 123) {
          if (ch <= 126) {
            if (this._noPrependSlashHostEnders[ch] === 0) {
              this._prependSlash = true;
            }
            hostNameEnd = i2 - 1;
            break;
          }
          idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
      }
      if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase)
          hostname = hostname.toLowerCase();
        if (idna)
          hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
      }
      return hostNameEnd + 1 + portLength;
    };
    Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
      if (!noProtocol) {
        input._protocol = this._protocol;
      }
      input._href = this._href;
      input._port = this._port;
      input._prependSlash = this._prependSlash;
      input.auth = this.auth;
      input.slashes = this.slashes;
      input.host = this.host;
      input.hostname = this.hostname;
      input.hash = this.hash;
      input.search = this.search;
      input.pathname = this.pathname;
    };
    Url.prototype._clone = function Url$_clone() {
      var ret = new Url();
      ret._protocol = this._protocol;
      ret._href = this._href;
      ret._port = this._port;
      ret._prependSlash = this._prependSlash;
      ret.auth = this.auth;
      ret.slashes = this.slashes;
      ret.host = this.host;
      ret.hostname = this.hostname;
      ret.hash = this.hash;
      ret.search = this.search;
      ret.pathname = this.pathname;
      return ret;
    };
    Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
      var cur = start;
      var i2 = start;
      var ret = "";
      var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
      for (; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        var escaped = autoEscapeMap2[ch];
        if (escaped !== "" && escaped !== void 0) {
          if (cur < i2)
            ret += str.slice(cur, i2);
          ret += escaped;
          cur = i2 + 1;
        }
      }
      if (cur < i2 + 1)
        ret += str.slice(cur, i2);
      return ret;
    };
    Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
      var pathStart = start;
      var pathEnd = end;
      var escape2 = false;
      var autoEscapeCharacters = this._autoEscapeCharacters;
      var prePath = this._port === -2 ? "/:" : "";
      for (var i2 = start; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 35) {
          this._parseHash(str, i2, end, disableAutoEscapeChars);
          pathEnd = i2 - 1;
          break;
        } else if (ch === 63) {
          this._parseQuery(str, i2, end, disableAutoEscapeChars);
          pathEnd = i2 - 1;
          break;
        } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
          escape2 = true;
        }
      }
      if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
      }
      var path;
      if (escape2) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
      } else {
        path = str.slice(pathStart, pathEnd + 1);
      }
      this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
    };
    Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
      var queryStart = start;
      var queryEnd = end;
      var escape2 = false;
      var autoEscapeCharacters = this._autoEscapeCharacters;
      for (var i2 = start; i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 35) {
          this._parseHash(str, i2, end, disableAutoEscapeChars);
          queryEnd = i2 - 1;
          break;
        } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
          escape2 = true;
        }
      }
      if (queryStart > queryEnd) {
        this.search = "";
        return;
      }
      var query;
      if (escape2) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
      } else {
        query = str.slice(queryStart, queryEnd + 1);
      }
      this.search = query;
    };
    Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
      if (start > end) {
        this.hash = "";
        return;
      }
      this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
    };
    Object.defineProperty(Url.prototype, "port", {
      get: function() {
        if (this._port >= 0) {
          return "" + this._port;
        }
        return null;
      },
      set: function(v2) {
        if (v2 == null) {
          this._port = -1;
        } else {
          this._port = parseInt(v2, 10);
        }
      }
    });
    Object.defineProperty(Url.prototype, "query", {
      get: function() {
        var query = this._query;
        if (query != null) {
          return query;
        }
        var search = this.search;
        if (search) {
          if (search.charCodeAt(0) === 63) {
            search = search.slice(1);
          }
          if (search !== "") {
            this._query = search;
            return search;
          }
        }
        return search;
      },
      set: function(v2) {
        this._query = v2;
      }
    });
    Object.defineProperty(Url.prototype, "path", {
      get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
          return p + s;
        }
        return p == null && s ? "/" + s : null;
      },
      set: function() {
      }
    });
    Object.defineProperty(Url.prototype, "protocol", {
      get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
      },
      set: function(v2) {
        if (typeof v2 === "string") {
          var end = v2.length - 1;
          if (v2.charCodeAt(end) === 58) {
            this._protocol = v2.slice(0, end);
          } else {
            this._protocol = v2;
          }
        } else if (v2 == null) {
          this._protocol = null;
        }
      }
    });
    Object.defineProperty(Url.prototype, "href", {
      get: function() {
        var href = this._href;
        if (!href) {
          href = this._href = this.format();
        }
        return href;
      },
      set: function(v2) {
        this._href = v2;
      }
    });
    Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
      if (str instanceof Url)
        return str;
      var ret = new Url();
      ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
      return ret;
    };
    Url.format = function Url$Format(obj) {
      if (typeof obj === "string") {
        obj = Url.parse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    };
    Url.resolve = function Url$Resolve(source, relative) {
      return Url.parse(source, false, true).resolve(relative);
    };
    Url.resolveObject = function Url$ResolveObject(source, relative) {
      if (!source)
        return relative;
      return Url.parse(source, false, true).resolveObject(relative);
    };
    function _escapePath(pathname) {
      return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
    }
    function _escapeSearch(search) {
      return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
      });
    }
    function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
      var len2 = string.length;
      for (var i2 = fromIndex; i2 < len2; ++i2) {
        var ch = string.charCodeAt(i2);
        if (ch === char1) {
          return true;
        } else if (stopCharacterTable[ch] === 1) {
          return false;
        }
      }
      return false;
    }
    function containsCharacter2(string, char1, char2) {
      for (var i2 = 0, len2 = string.length; i2 < len2; ++i2) {
        var ch = string.charCodeAt(i2);
        if (ch === char1 || ch === char2)
          return true;
      }
      return false;
    }
    function makeAsciiTable(spec) {
      var ret = new Uint8Array(128);
      spec.forEach(function(item) {
        if (typeof item === "number") {
          ret[item] = 1;
        } else {
          var start = item[0];
          var end = item[1];
          for (var j2 = start; j2 <= end; ++j2) {
            ret[j2] = 1;
          }
        }
      });
      return ret;
    }
    var autoEscape = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	",
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`",
      "'"
    ];
    var autoEscapeMap = new Array(128);
    for (i = 0, len = autoEscapeMap.length; i < len; ++i) {
      autoEscapeMap[i] = "";
    }
    var i;
    var len;
    for (i = 0, len = autoEscape.length; i < len; ++i) {
      c = autoEscape[i];
      esc = encodeURIComponent(c);
      if (esc === c) {
        esc = escape(c);
      }
      autoEscapeMap[c.charCodeAt(0)] = esc;
    }
    var c;
    var esc;
    var i;
    var len;
    var afterQueryAutoEscapeMap = autoEscapeMap.slice();
    autoEscapeMap[
      92
      /*'\'*/
    ] = "/";
    var slashProtocols = Url.prototype._slashProtocols = {
      http: true,
      https: true,
      gopher: true,
      file: true,
      ftp: true,
      "http:": true,
      "https:": true,
      "gopher:": true,
      "file:": true,
      "ftp:": true
    };
    function f() {
    }
    f.prototype = slashProtocols;
    Url.prototype._protocolCharacters = makeAsciiTable([
      [
        97,
        122
        /*'z'*/
      ],
      [
        65,
        90
        /*'Z'*/
      ],
      46,
      43,
      45
      /*'-'*/
    ]);
    Url.prototype._hostEndingCharacters = makeAsciiTable([
      35,
      63,
      47,
      92
      /*'\'*/
    ]);
    Url.prototype._autoEscapeCharacters = makeAsciiTable(
      autoEscape.map(function(v2) {
        return v2.charCodeAt(0);
      })
    );
    Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
      [
        "<",
        ">",
        "'",
        "`",
        " ",
        "\r",
        "\n",
        "	",
        "{",
        "}",
        "|",
        "^",
        "`",
        '"',
        "%",
        ";"
      ].map(function(v2) {
        return v2.charCodeAt(0);
      })
    );
    Url.prototype._autoEscapeMap = autoEscapeMap;
    Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
    module2.exports = Url;
    Url.replace = function Url$Replace() {
      require.cache.url = {
        exports: Url
      };
    };
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillURLSearchParams = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
    var PonyfillURLSearchParams = class {
      constructor(init) {
        if (init) {
          if (typeof init === "string") {
            this.params = fast_querystring_1.default.parse(init);
          } else if (Array.isArray(init)) {
            this.params = {};
            for (const [key, value] of init) {
              this.params[key] = value;
            }
          } else if ("entries" in init) {
            this.params = {};
            for (const [key, value] of init.entries()) {
              this.params[key] = value;
            }
          } else {
            this.params = init;
          }
        } else {
          this.params = {};
        }
      }
      append(name, value) {
        const existingValue = this.params[name];
        const finalValue = existingValue ? `${existingValue},${value}` : value;
        this.params[name] = finalValue;
      }
      delete(name) {
        delete this.params[name];
      }
      get(name) {
        const value = this.params[name];
        if (Array.isArray(value)) {
          return value[0] || null;
        }
        return value || null;
      }
      getAll(name) {
        const value = this.params[name];
        if (!Array.isArray(value)) {
          return value ? [value] : [];
        }
        return value;
      }
      has(name) {
        return name in this.params;
      }
      set(name, value) {
        this.params[name] = value;
      }
      sort() {
        const sortedKeys = Object.keys(this.params).sort();
        const sortedParams = {};
        for (const key of sortedKeys) {
          sortedParams[key] = this.params[key];
        }
        this.params = sortedParams;
      }
      toString() {
        return fast_querystring_1.default.stringify(this.params);
      }
      *keys() {
        for (const key in this.params) {
          yield key;
        }
      }
      *entries() {
        for (const key of this.keys()) {
          const value = this.params[key];
          if (Array.isArray(value)) {
            for (const item of value) {
              yield [key, item];
            }
          } else {
            yield [key, value];
          }
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      forEach(callback) {
        for (const [key, value] of this) {
          callback(value, key, this);
        }
      }
      get size() {
        return Object.keys(this.params).length;
      }
    };
    exports2.PonyfillURLSearchParams = PonyfillURLSearchParams;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/URL.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillURL = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
    var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
    var URLSearchParams_js_1 = require_URLSearchParams();
    fast_url_parser_1.default.queryString = fast_querystring_1.default;
    var PonyfillURL = class _PonyfillURL extends fast_url_parser_1.default {
      constructor(url, base) {
        super();
        if (url.startsWith("data:")) {
          this.protocol = "data:";
          this.pathname = url.slice("data:".length);
          return;
        }
        this.parse(url, false);
        if (base) {
          const baseParsed = typeof base === "string" ? new _PonyfillURL(base) : base;
          this.protocol = this.protocol || baseParsed.protocol;
          this.host = this.host || baseParsed.host;
          this.pathname = this.pathname || baseParsed.pathname;
        }
      }
      get origin() {
        return `${this.protocol}//${this.host}`;
      }
      get searchParams() {
        if (!this._searchParams) {
          this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
        }
        return this._searchParams;
      }
      get username() {
        return this.auth?.split(":")[0] || "";
      }
      set username(value) {
        this.auth = `${value}:${this.password}`;
      }
      get password() {
        return this.auth?.split(":")[1] || "";
      }
      set password(value) {
        this.auth = `${this.username}:${value}`;
      }
      toString() {
        return this.format();
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.PonyfillURL = PonyfillURL;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchNodeHttp = void 0;
    var http_1 = require("http");
    var https_1 = require("https");
    var stream_1 = require("stream");
    var zlib_1 = require("zlib");
    var AbortError_js_1 = require_AbortError();
    var Request_js_1 = require_Request();
    var Response_js_1 = require_Response();
    var URL_js_1 = require_URL();
    var utils_js_1 = require_utils();
    function getRequestFnForProtocol(url) {
      if (url.startsWith("http:")) {
        return http_1.request;
      } else if (url.startsWith("https:")) {
        return https_1.request;
      }
      throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
    }
    function fetchNodeHttp(fetchRequest) {
      return new Promise((resolve, reject) => {
        try {
          const requestFn = getRequestFnForProtocol(fetchRequest.url);
          const nodeReadable = fetchRequest.body != null ? "pipe" in fetchRequest.body ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
          const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
          const nodeHeaders = headersSerializer(fetchRequest.headers);
          const nodeRequest = requestFn(fetchRequest.url, {
            method: fetchRequest.method,
            headers: nodeHeaders,
            signal: fetchRequest["_signal"] ?? void 0,
            agent: fetchRequest.agent
          });
          fetchRequest["_signal"]?.addEventListener("abort", () => {
            if (!nodeRequest.aborted) {
              nodeRequest.abort();
            }
          });
          nodeRequest.once("abort", (reason) => {
            reject(new AbortError_js_1.PonyfillAbortError(reason));
          });
          nodeRequest.once("response", (nodeResponse) => {
            let responseBody = nodeResponse;
            const contentEncoding = nodeResponse.headers["content-encoding"];
            switch (contentEncoding) {
              case "x-gzip":
              case "gzip":
                responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
                break;
              case "x-deflate":
              case "deflate":
                responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
                break;
              case "br":
                responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
                break;
            }
            if (nodeResponse.headers.location) {
              if (fetchRequest.redirect === "error") {
                const redirectError = new Error("Redirects are not allowed");
                reject(redirectError);
                nodeResponse.resume();
                return;
              }
              if (fetchRequest.redirect === "follow") {
                const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
                const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
                resolve(redirectResponse$.then((redirectResponse) => {
                  redirectResponse.redirected = true;
                  return redirectResponse;
                }));
                nodeResponse.resume();
                return;
              }
            }
            const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
              status: nodeResponse.statusCode,
              statusText: nodeResponse.statusMessage,
              headers: nodeResponse.headers,
              url: fetchRequest.url
            });
            resolve(ponyfillResponse);
          });
          nodeRequest.once("error", reject);
          if (nodeReadable) {
            nodeReadable.pipe(nodeRequest);
          } else {
            nodeRequest.end();
          }
        } catch (e) {
          reject(e);
        }
      });
    }
    exports2.fetchNodeHttp = fetchNodeHttp;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchPonyfill = void 0;
    var fs_1 = require("fs");
    var url_1 = require("url");
    var Blob_js_1 = require_Blob();
    var fetchCurl_js_1 = require_fetchCurl();
    var fetchNodeHttp_js_1 = require_fetchNodeHttp();
    var Request_js_1 = require_Request();
    var Response_js_1 = require_Response();
    var BASE64_SUFFIX = ";base64";
    function getResponseForFile(url) {
      const path = (0, url_1.fileURLToPath)(url);
      const readable = (0, fs_1.createReadStream)(path);
      return new Response_js_1.PonyfillResponse(readable);
    }
    function getResponseForDataUri(url) {
      const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
      const data = decodeURIComponent(datas.join(","));
      if (mimeType.endsWith(BASE64_SUFFIX)) {
        const buffer = Buffer.from(data, "base64url");
        const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
        const file = new Blob_js_1.PonyfillBlob([buffer], { type: realMimeType });
        return new Response_js_1.PonyfillResponse(file, {
          status: 200,
          statusText: "OK"
        });
      }
      return new Response_js_1.PonyfillResponse(data, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": mimeType
        }
      });
    }
    async function fetchPonyfill(info, init) {
      if (typeof info === "string" || "href" in info) {
        const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
        return fetchPonyfill(ponyfillRequest);
      }
      const fetchRequest = info;
      if (fetchRequest.url.startsWith("data:")) {
        const response = getResponseForDataUri(fetchRequest.url);
        return Promise.resolve(response);
      }
      if (fetchRequest.url.startsWith("file:")) {
        const response = getResponseForFile(fetchRequest.url);
        return Promise.resolve(response);
      }
      if (globalThis.libcurl) {
        return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
      }
      return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
    }
    exports2.fetchPonyfill = fetchPonyfill;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBtoa = exports2.PonyfillTextDecoder = exports2.PonyfillTextEncoder = void 0;
    var PonyfillTextEncoder = class {
      constructor(encoding = "utf-8") {
        this.encoding = encoding;
      }
      encode(input) {
        return Buffer.from(input, this.encoding);
      }
      encodeInto(source, destination) {
        const buffer = this.encode(source);
        const copied = buffer.copy(destination);
        return {
          read: copied,
          written: copied
        };
      }
    };
    exports2.PonyfillTextEncoder = PonyfillTextEncoder;
    var PonyfillTextDecoder = class {
      constructor(encoding = "utf-8", options) {
        this.encoding = encoding;
        this.fatal = false;
        this.ignoreBOM = false;
        if (options) {
          this.fatal = options.fatal || false;
          this.ignoreBOM = options.ignoreBOM || false;
        }
      }
      decode(input) {
        return Buffer.from(input).toString(this.encoding);
      }
    };
    exports2.PonyfillTextDecoder = PonyfillTextDecoder;
    function PonyfillBtoa(input) {
      return Buffer.from(input, "binary").toString("base64");
    }
    exports2.PonyfillBtoa = PonyfillBtoa;
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/node-fetch/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLSearchParams = exports2.URL = exports2.btoa = exports2.TextDecoder = exports2.TextEncoder = exports2.Blob = exports2.FormData = exports2.File = exports2.ReadableStream = exports2.Response = exports2.Request = exports2.Body = exports2.Headers = exports2.fetch = void 0;
    var fetch_js_1 = require_fetch();
    Object.defineProperty(exports2, "fetch", { enumerable: true, get: function() {
      return fetch_js_1.fetchPonyfill;
    } });
    var Headers_js_1 = require_Headers();
    Object.defineProperty(exports2, "Headers", { enumerable: true, get: function() {
      return Headers_js_1.PonyfillHeaders;
    } });
    var Body_js_1 = require_Body();
    Object.defineProperty(exports2, "Body", { enumerable: true, get: function() {
      return Body_js_1.PonyfillBody;
    } });
    var Request_js_1 = require_Request();
    Object.defineProperty(exports2, "Request", { enumerable: true, get: function() {
      return Request_js_1.PonyfillRequest;
    } });
    var Response_js_1 = require_Response();
    Object.defineProperty(exports2, "Response", { enumerable: true, get: function() {
      return Response_js_1.PonyfillResponse;
    } });
    var ReadableStream_js_1 = require_ReadableStream();
    Object.defineProperty(exports2, "ReadableStream", { enumerable: true, get: function() {
      return ReadableStream_js_1.PonyfillReadableStream;
    } });
    var File_js_1 = require_File();
    Object.defineProperty(exports2, "File", { enumerable: true, get: function() {
      return File_js_1.PonyfillFile;
    } });
    var FormData_js_1 = require_FormData();
    Object.defineProperty(exports2, "FormData", { enumerable: true, get: function() {
      return FormData_js_1.PonyfillFormData;
    } });
    var Blob_js_1 = require_Blob();
    Object.defineProperty(exports2, "Blob", { enumerable: true, get: function() {
      return Blob_js_1.PonyfillBlob;
    } });
    var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
    Object.defineProperty(exports2, "TextEncoder", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillTextEncoder;
    } });
    Object.defineProperty(exports2, "TextDecoder", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillTextDecoder;
    } });
    Object.defineProperty(exports2, "btoa", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillBtoa;
    } });
    var URL_js_1 = require_URL();
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return URL_js_1.PonyfillURL;
    } });
    var URLSearchParams_js_1 = require_URLSearchParams();
    Object.defineProperty(exports2, "URLSearchParams", { enumerable: true, get: function() {
      return URLSearchParams_js_1.PonyfillURLSearchParams;
    } });
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js"(exports2, module2) {
    module2.exports = function createNodePonyfill(opts = {}) {
      const ponyfills = {};
      if (!ponyfills.URLPattern) {
        const urlPatternModule = require_urlpattern_polyfill();
        ponyfills.URLPattern = urlPatternModule.URLPattern;
      }
      if (globalThis.Deno || process.versions.bun) {
        return globalThis;
      }
      const newNodeFetch = require_cjs();
      ponyfills.fetch = newNodeFetch.fetch;
      ponyfills.Request = newNodeFetch.Request;
      ponyfills.Response = newNodeFetch.Response;
      ponyfills.Headers = newNodeFetch.Headers;
      ponyfills.FormData = newNodeFetch.FormData;
      ponyfills.ReadableStream = newNodeFetch.ReadableStream;
      ponyfills.URL = newNodeFetch.URL;
      ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
      ponyfills.WritableStream = globalThis.WritableStream;
      ponyfills.TransformStream = globalThis.TransformStream;
      if (!ponyfills.WritableStream) {
        const streamsWeb = require("stream/web");
        ponyfills.WritableStream = streamsWeb.WritableStream;
        ponyfills.TransformStream = streamsWeb.TransformStream;
      }
      ponyfills.Blob = newNodeFetch.Blob;
      ponyfills.File = newNodeFetch.File;
      ponyfills.crypto = globalThis.crypto;
      ponyfills.btoa = newNodeFetch.btoa;
      ponyfills.TextEncoder = newNodeFetch.TextEncoder;
      ponyfills.TextDecoder = newNodeFetch.TextDecoder;
      if (opts.formDataLimits) {
        ponyfills.Body = class Body extends newNodeFetch.Body {
          constructor(body, userOpts) {
            super(body, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
        ponyfills.Request = class Request extends newNodeFetch.Request {
          constructor(input, userOpts) {
            super(input, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
        ponyfills.Response = class Response extends newNodeFetch.Response {
          constructor(body, userOpts) {
            super(body, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
      }
      if (!ponyfills.crypto) {
        const cryptoModule = require("crypto");
        ponyfills.crypto = cryptoModule.webcrypto;
      }
      return ponyfills;
    };
  }
});

// node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS({
  "node_modules/graphql-yoga/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js"(exports2, module2) {
    var createNodePonyfill = require_create_node_ponyfill();
    var ponyfills = createNodePonyfill();
    try {
      const nodelibcurlName = "node-libcurl";
      globalThis.libcurl = globalThis.libcurl || require(nodelibcurlName);
    } catch (e) {
    }
    module2.exports.fetch = ponyfills.fetch;
    module2.exports.Headers = ponyfills.Headers;
    module2.exports.Request = ponyfills.Request;
    module2.exports.Response = ponyfills.Response;
    module2.exports.FormData = ponyfills.FormData;
    module2.exports.ReadableStream = ponyfills.ReadableStream;
    module2.exports.WritableStream = ponyfills.WritableStream;
    module2.exports.TransformStream = ponyfills.TransformStream;
    module2.exports.Blob = ponyfills.Blob;
    module2.exports.File = ponyfills.File;
    module2.exports.crypto = ponyfills.crypto;
    module2.exports.btoa = ponyfills.btoa;
    module2.exports.TextEncoder = ponyfills.TextEncoder;
    module2.exports.TextDecoder = ponyfills.TextDecoder;
    module2.exports.URLPattern = ponyfills.URLPattern;
    module2.exports.URL = ponyfills.URL;
    module2.exports.URLSearchParams = ponyfills.URLSearchParams;
    exports2.createFetch = createNodePonyfill;
  }
});

// node_modules/@whatwg-node/server/node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/urlpattern-polyfill/dist/urlpattern.cjs"(exports2, module2) {
    "use strict";
    var M2 = Object.defineProperty;
    var Se2 = Object.getOwnPropertyDescriptor;
    var ke2 = Object.getOwnPropertyNames;
    var Ee2 = Object.prototype.hasOwnProperty;
    var Re2 = (e, t) => {
      for (var r in t)
        M2(e, r, { get: t[r], enumerable: true });
    };
    var ye2 = (e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let a of ke2(t))
          !Ee2.call(e, a) && a !== r && M2(e, a, { get: () => t[a], enumerable: !(n = Se2(t, a)) || n.enumerable });
      return e;
    };
    var Oe2 = (e) => ye2(M2({}, "__esModule", { value: true }), e);
    var Ne2 = {};
    Re2(Ne2, { URLPattern: () => Y });
    module2.exports = Oe2(Ne2);
    var k2 = class {
      type = 3;
      name = "";
      prefix = "";
      value = "";
      suffix = "";
      modifier = 3;
      constructor(t, r, n, a, c, l) {
        this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
      }
      hasCustomName() {
        return this.name !== "" && typeof this.name != "number";
      }
    };
    var Te = /[$_\p{ID_Start}]/u;
    var Ae2 = /[$_\u200C\u200D\p{ID_Continue}]/u;
    var v2 = ".*";
    function we2(e, t) {
      return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
    }
    function D2(e, t = false) {
      let r = [], n = 0;
      for (; n < e.length; ) {
        let a = e[n], c = function(l) {
          if (!t)
            throw new TypeError(l);
          r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
        };
        if (a === "*") {
          r.push({ type: "ASTERISK", index: n, value: e[n++] });
          continue;
        }
        if (a === "+" || a === "?") {
          r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
          continue;
        }
        if (a === "\\") {
          r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
          continue;
        }
        if (a === "{") {
          r.push({ type: "OPEN", index: n, value: e[n++] });
          continue;
        }
        if (a === "}") {
          r.push({ type: "CLOSE", index: n, value: e[n++] });
          continue;
        }
        if (a === ":") {
          let l = "", s = n + 1;
          for (; s < e.length; ) {
            let i = e.substr(s, 1);
            if (s === n + 1 && Te.test(i) || s !== n + 1 && Ae2.test(i)) {
              l += e[s++];
              continue;
            }
            break;
          }
          if (!l) {
            c(`Missing parameter name at ${n}`);
            continue;
          }
          r.push({ type: "NAME", index: n, value: l }), n = s;
          continue;
        }
        if (a === "(") {
          let l = 1, s = "", i = n + 1, o = false;
          if (e[i] === "?") {
            c(`Pattern cannot start with "?" at ${i}`);
            continue;
          }
          for (; i < e.length; ) {
            if (!we2(e[i], false)) {
              c(`Invalid character '${e[i]}' at ${i}.`), o = true;
              break;
            }
            if (e[i] === "\\") {
              s += e[i++] + e[i++];
              continue;
            }
            if (e[i] === ")") {
              if (l--, l === 0) {
                i++;
                break;
              }
            } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
              c(`Capturing groups are not allowed at ${i}`), o = true;
              break;
            }
            s += e[i++];
          }
          if (o)
            continue;
          if (l) {
            c(`Unbalanced pattern at ${n}`);
            continue;
          }
          if (!s) {
            c(`Missing pattern at ${n}`);
            continue;
          }
          r.push({ type: "REGEX", index: n, value: s }), n = i;
          continue;
        }
        r.push({ type: "CHAR", index: n, value: e[n++] });
      }
      return r.push({ type: "END", index: n, value: "" }), r;
    }
    function F(e, t = {}) {
      let r = D2(e);
      t.delimiter ??= "/#?", t.prefixes ??= "./";
      let n = `[^${x(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = /* @__PURE__ */ new Set(), o = (f) => {
        if (l < r.length && r[l].type === f)
          return r[l++].value;
      }, h2 = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), p = (f) => {
        let u = o(f);
        if (u !== void 0)
          return u;
        let { type: d, index: T } = r[l];
        throw new TypeError(`Unexpected ${d} at ${T}, expected ${f}`);
      }, O2 = () => {
        let f = "", u;
        for (; u = o("CHAR") ?? o("ESCAPED_CHAR"); )
          f += u;
        return f;
      }, be2 = (f) => f, L2 = t.encodePart || be2, I = "", H = (f) => {
        I += f;
      }, $ = () => {
        I.length && (a.push(new k2(3, "", "", L2(I), "", 3)), I = "");
      }, X2 = (f, u, d, T, Z) => {
        let g = 3;
        switch (Z) {
          case "?":
            g = 1;
            break;
          case "*":
            g = 0;
            break;
          case "+":
            g = 2;
            break;
        }
        if (!u && !d && g === 3) {
          H(f);
          return;
        }
        if ($(), !u && !d) {
          if (!f)
            return;
          a.push(new k2(3, "", "", L2(f), "", g));
          return;
        }
        let m2;
        d ? d === "*" ? m2 = v2 : m2 = d : m2 = n;
        let R = 2;
        m2 === n ? (R = 1, m2 = "") : m2 === v2 && (R = 0, m2 = "");
        let S2;
        if (u ? S2 = u : d && (S2 = c++), i.has(S2))
          throw new TypeError(`Duplicate name '${S2}'.`);
        i.add(S2), a.push(new k2(R, S2, L2(f), m2, L2(T), g));
      };
      for (; l < r.length; ) {
        let f = o("CHAR"), u = o("NAME"), d = o("REGEX");
        if (!u && !d && (d = o("ASTERISK")), u || d) {
          let g = f ?? "";
          t.prefixes.indexOf(g) === -1 && (H(g), g = ""), $();
          let m2 = h2();
          X2(g, u, d, "", m2);
          continue;
        }
        let T = f ?? o("ESCAPED_CHAR");
        if (T) {
          H(T);
          continue;
        }
        if (o("OPEN")) {
          let g = O2(), m2 = o("NAME"), R = o("REGEX");
          !m2 && !R && (R = o("ASTERISK"));
          let S2 = O2();
          p("CLOSE");
          let Pe2 = h2();
          X2(g, m2, R, S2, Pe2);
          continue;
        }
        $(), p("END");
      }
      return a;
    }
    function x(e) {
      return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
    }
    function B(e) {
      return e && e.ignoreCase ? "ui" : "u";
    }
    function q2(e, t, r) {
      return W2(F(e, r), t, r);
    }
    function y(e) {
      switch (e) {
        case 0:
          return "*";
        case 1:
          return "?";
        case 2:
          return "+";
        case 3:
          return "";
      }
    }
    function W2(e, t, r = {}) {
      r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
      let n = r.start ? "^" : "";
      for (let s of e) {
        if (s.type === 3) {
          s.modifier === 3 ? n += x(s.value) : n += `(?:${x(s.value)})${y(s.modifier)}`;
          continue;
        }
        t && t.push(s.name);
        let i = `[^${x(r.delimiter)}]+?`, o = s.value;
        if (s.type === 1 ? o = i : s.type === 0 && (o = v2), !s.prefix.length && !s.suffix.length) {
          s.modifier === 3 || s.modifier === 1 ? n += `(${o})${y(s.modifier)}` : n += `((?:${o})${y(s.modifier)})`;
          continue;
        }
        if (s.modifier === 3 || s.modifier === 1) {
          n += `(?:${x(s.prefix)}(${o})${x(s.suffix)})`, n += y(s.modifier);
          continue;
        }
        n += `(?:${x(s.prefix)}`, n += `((?:${o})(?:`, n += x(s.suffix), n += x(s.prefix), n += `(?:${o}))*)${x(s.suffix)})`, s.modifier === 0 && (n += "?");
      }
      let a = `[${x(r.endsWith)}]|$`, c = `[${x(r.delimiter)}]`;
      if (r.end)
        return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
      r.strict || (n += `(?:${c}(?=${a}))?`);
      let l = false;
      if (e.length) {
        let s = e[e.length - 1];
        s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
      }
      return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
    }
    var b2 = { delimiter: "", prefixes: "", sensitive: true, strict: true };
    var J2 = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
    var Q2 = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
    function ee2(e, t) {
      return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
    }
    function te2(e, t) {
      return e.startsWith(t) ? e.substring(t.length, e.length) : e;
    }
    function Ce2(e, t) {
      return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
    }
    function _2(e) {
      return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
    }
    var re2 = ["ftp", "file", "http", "https", "ws", "wss"];
    function N2(e) {
      if (!e)
        return true;
      for (let t of re2)
        if (e.test(t))
          return true;
      return false;
    }
    function ne2(e, t) {
      if (e = te2(e, "#"), t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
    }
    function se2(e, t) {
      if (e = te2(e, "?"), t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
    }
    function ie2(e, t) {
      return t || e === "" ? e : _2(e) ? K2(e) : j2(e);
    }
    function ae2(e, t) {
      if (t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.password = e, r.password;
    }
    function oe2(e, t) {
      if (t || e === "")
        return e;
      let r = new URL("https://example.com");
      return r.username = e, r.username;
    }
    function ce(e, t, r) {
      if (r || e === "")
        return e;
      if (t && !re2.includes(t))
        return new URL(`${t}:${e}`).pathname;
      let n = e[0] == "/";
      return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
    }
    function le(e, t, r) {
      return z(t) === e && (e = ""), r || e === "" ? e : V2(e);
    }
    function he2(e, t) {
      return e = Ce2(e, ":"), t || e === "" ? e : A(e);
    }
    function z(e) {
      switch (e) {
        case "ws":
        case "http":
          return "80";
        case "wws":
        case "https":
          return "443";
        case "ftp":
          return "21";
        default:
          return "";
      }
    }
    function A(e) {
      if (e === "")
        return e;
      if (/^[-+.A-Za-z0-9]*$/.test(e))
        return e.toLowerCase();
      throw new TypeError(`Invalid protocol '${e}'.`);
    }
    function fe2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.username = e, t.username;
    }
    function ue2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.password = e, t.password;
    }
    function j2(e) {
      if (e === "")
        return e;
      if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
        throw new TypeError(`Invalid hostname '${e}'`);
      let t = new URL("https://example.com");
      return t.hostname = e, t.hostname;
    }
    function K2(e) {
      if (e === "")
        return e;
      if (/[^0-9a-fA-F[\]:]/g.test(e))
        throw new TypeError(`Invalid IPv6 hostname '${e}'`);
      return e.toLowerCase();
    }
    function V2(e) {
      if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
        return e;
      throw new TypeError(`Invalid port '${e}'.`);
    }
    function pe2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
    }
    function de(e) {
      return e === "" ? e : new URL(`data:${e}`).pathname;
    }
    function ge2(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.search = e, t.search.substring(1, t.search.length);
    }
    function me3(e) {
      if (e === "")
        return e;
      let t = new URL("https://example.com");
      return t.hash = e, t.hash.substring(1, t.hash.length);
    }
    var U2 = class {
      #i;
      #n = [];
      #t = {};
      #e = 0;
      #s = 1;
      #u = 0;
      #c = 0;
      #p = 0;
      #d = 0;
      #g = false;
      constructor(t) {
        this.#i = t;
      }
      get result() {
        return this.#t;
      }
      parse() {
        for (this.#n = D2(this.#i, true); this.#e < this.#n.length; this.#e += this.#s) {
          if (this.#s = 1, this.#n[this.#e].type === "END") {
            if (this.#c === 0) {
              this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
              continue;
            } else if (this.#c === 2) {
              this.#f(5);
              continue;
            }
            this.#r(10, 0);
            break;
          }
          if (this.#p > 0)
            if (this.#T())
              this.#p -= 1;
            else
              continue;
          if (this.#O()) {
            this.#p += 1;
            continue;
          }
          switch (this.#c) {
            case 0:
              this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
              break;
            case 1:
              if (this.#S()) {
                this.#C();
                let t = 7, r = 1;
                this.#g && (this.#t.pathname = "/"), this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
              }
              break;
            case 2:
              this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
              break;
            case 3:
              this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
              break;
            case 4:
              this.#x() && this.#r(5, 1);
              break;
            case 5:
              this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 6:
              this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 7:
              this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
              break;
            case 8:
              this.#l() && this.#r(9, 1);
              break;
            case 9:
              break;
            case 10:
              break;
          }
        }
      }
      #r(t, r) {
        switch (this.#c) {
          case 0:
            break;
          case 1:
            this.#t.protocol = this.#o();
            break;
          case 2:
            break;
          case 3:
            this.#t.username = this.#o();
            break;
          case 4:
            this.#t.password = this.#o();
            break;
          case 5:
            this.#t.hostname = this.#o();
            break;
          case 6:
            this.#t.port = this.#o();
            break;
          case 7:
            this.#t.pathname = this.#o();
            break;
          case 8:
            this.#t.search = this.#o();
            break;
          case 9:
            this.#t.hash = this.#o();
            break;
          case 10:
            break;
        }
        this.#k(t, r);
      }
      #k(t, r) {
        this.#c = t, this.#u = this.#e + r, this.#e += r, this.#s = 0;
      }
      #P() {
        this.#e = this.#u, this.#s = 0;
      }
      #f(t) {
        this.#P(), this.#c = t;
      }
      #m(t) {
        return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
      }
      #a(t, r) {
        let n = this.#m(t);
        return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
      }
      #S() {
        return this.#a(this.#e, ":");
      }
      #E() {
        return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
      }
      #x() {
        return this.#a(this.#e, "@");
      }
      #R() {
        return this.#a(this.#e, ":");
      }
      #y() {
        return this.#a(this.#e, ":");
      }
      #b() {
        return this.#a(this.#e, "/");
      }
      #h() {
        if (this.#a(this.#e, "?"))
          return true;
        if (this.#n[this.#e].value !== "?")
          return false;
        let t = this.#m(this.#e - 1);
        return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
      }
      #l() {
        return this.#a(this.#e, "#");
      }
      #O() {
        return this.#n[this.#e].type == "OPEN";
      }
      #T() {
        return this.#n[this.#e].type == "CLOSE";
      }
      #A() {
        return this.#a(this.#e, "[");
      }
      #w() {
        return this.#a(this.#e, "]");
      }
      #o() {
        let t = this.#n[this.#e], r = this.#m(this.#u).index;
        return this.#i.substring(r, t.index);
      }
      #C() {
        let t = {};
        Object.assign(t, b2), t.encodePart = A;
        let r = q2(this.#o(), void 0, t);
        this.#g = N2(r);
      }
    };
    var G = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
    var E2 = "*";
    function xe2(e, t) {
      if (typeof e != "string")
        throw new TypeError("parameter 1 is not of type 'string'.");
      let r = new URL(e, t);
      return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : void 0, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : void 0 };
    }
    function P(e, t) {
      return t ? C(e) : e;
    }
    function w2(e, t, r) {
      let n;
      if (typeof t.baseURL == "string")
        try {
          n = new URL(t.baseURL), e.protocol = P(n.protocol.substring(0, n.protocol.length - 1), r), e.username = P(n.username, r), e.password = P(n.password, r), e.hostname = P(n.hostname, r), e.port = P(n.port, r), e.pathname = P(n.pathname, r), e.search = P(n.search.substring(1, n.search.length), r), e.hash = P(n.hash.substring(1, n.hash.length), r);
        } catch {
          throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
        }
      if (typeof t.protocol == "string" && (e.protocol = he2(t.protocol, r)), typeof t.username == "string" && (e.username = oe2(t.username, r)), typeof t.password == "string" && (e.password = ae2(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie2(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
        if (e.pathname = t.pathname, n && !ee2(e.pathname, r)) {
          let a = n.pathname.lastIndexOf("/");
          a >= 0 && (e.pathname = P(n.pathname.substring(0, a + 1), r) + e.pathname);
        }
        e.pathname = ce(e.pathname, e.protocol, r);
      }
      return typeof t.search == "string" && (e.search = se2(t.search, r)), typeof t.hash == "string" && (e.hash = ne2(t.hash, r)), e;
    }
    function C(e) {
      return e.replace(/([+*?:{}()\\])/g, "\\$1");
    }
    function Le2(e) {
      return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
    }
    function Ie2(e, t) {
      t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
      let r = ".*", n = `[^${Le2(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
      for (let l = 0; l < e.length; ++l) {
        let s = e[l];
        if (s.type === 3) {
          if (s.modifier === 3) {
            c += C(s.value);
            continue;
          }
          c += `{${C(s.value)}}${y(s.modifier)}`;
          continue;
        }
        let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), h2 = l > 0 ? e[l - 1] : null, p = l < e.length - 1 ? e[l + 1] : null;
        if (!o && i && s.type === 1 && s.modifier === 3 && p && !p.prefix.length && !p.suffix.length)
          if (p.type === 3) {
            let O2 = p.value.length > 0 ? p.value[0] : "";
            o = a.test(O2);
          } else
            o = !p.hasCustomName();
        if (!o && !s.prefix.length && h2 && h2.type === 3) {
          let O2 = h2.value[h2.value.length - 1];
          o = t.prefixes.includes(O2);
        }
        o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!h2 || h2.type === 3 || h2.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += y(s.modifier));
      }
      return c;
    }
    var Y = class {
      #i;
      #n = {};
      #t = {};
      #e = {};
      #s = {};
      constructor(t = {}, r, n) {
        try {
          let a;
          if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
            let i = new U2(t);
            if (i.parse(), t = i.result, a === void 0 && typeof t.protocol != "string")
              throw new TypeError("A base URL must be provided for a relative constructor string.");
            t.baseURL = a;
          } else {
            if (!t || typeof t != "object")
              throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
            if (a)
              throw new TypeError("parameter 1 is not of type 'string'.");
          }
          typeof n > "u" && (n = { ignoreCase: false });
          let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E2, protocol: E2, username: E2, password: E2, hostname: E2, port: E2, search: E2, hash: E2 };
          this.#i = w2(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
          let s;
          for (s of G) {
            if (!(s in this.#i))
              continue;
            let i = {}, o = this.#i[s];
            switch (this.#t[s] = [], s) {
              case "protocol":
                Object.assign(i, b2), i.encodePart = A;
                break;
              case "username":
                Object.assign(i, b2), i.encodePart = fe2;
                break;
              case "password":
                Object.assign(i, b2), i.encodePart = ue2;
                break;
              case "hostname":
                Object.assign(i, J2), _2(o) ? i.encodePart = K2 : i.encodePart = j2;
                break;
              case "port":
                Object.assign(i, b2), i.encodePart = V2;
                break;
              case "pathname":
                N2(this.#n.protocol) ? (Object.assign(i, Q2, c), i.encodePart = pe2) : (Object.assign(i, b2, c), i.encodePart = de);
                break;
              case "search":
                Object.assign(i, b2, c), i.encodePart = ge2;
                break;
              case "hash":
                Object.assign(i, b2, c), i.encodePart = me3;
                break;
            }
            try {
              this.#s[s] = F(o, i), this.#n[s] = W2(this.#s[s], this.#t[s], i), this.#e[s] = Ie2(this.#s[s], i);
            } catch {
              throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
            }
          }
        } catch (a) {
          throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
        }
      }
      test(t = {}, r) {
        let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
        if (typeof t != "string" && r)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (typeof t > "u")
          return false;
        try {
          typeof t == "object" ? n = w2(n, t, false) : n = w2(n, xe2(t, r), false);
        } catch {
          return false;
        }
        let a;
        for (a of G)
          if (!this.#n[a].exec(n[a]))
            return false;
        return true;
      }
      exec(t = {}, r) {
        let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
        if (typeof t != "string" && r)
          throw new TypeError("parameter 1 is not of type 'string'.");
        if (typeof t > "u")
          return;
        try {
          typeof t == "object" ? n = w2(n, t, false) : n = w2(n, xe2(t, r), false);
        } catch {
          return null;
        }
        let a = {};
        r ? a.inputs = [t, r] : a.inputs = [t];
        let c;
        for (c of G) {
          let l = this.#n[c].exec(n[c]);
          if (!l)
            return null;
          let s = {};
          for (let [i, o] of this.#t[c].entries())
            if (typeof o == "string" || typeof o == "number") {
              let h2 = l[i + 1];
              s[o] = h2;
            }
          a[c] = { input: n[c] ?? "", groups: s };
        }
        return a;
      }
      static compareComponent(t, r, n) {
        let a = (i, o) => {
          for (let h2 of ["type", "modifier", "prefix", "value", "suffix"]) {
            if (i[h2] < o[h2])
              return -1;
            if (i[h2] === o[h2])
              continue;
            return 1;
          }
          return 0;
        }, c = new k2(3, "", "", "", "", 3), l = new k2(0, "", "", "", "", 3), s = (i, o) => {
          let h2 = 0;
          for (; h2 < Math.min(i.length, o.length); ++h2) {
            let p = a(i[h2], o[h2]);
            if (p)
              return p;
          }
          return i.length === o.length ? 0 : a(i[h2] ?? c, o[h2] ?? c);
        };
        return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
      }
      get protocol() {
        return this.#e.protocol;
      }
      get username() {
        return this.#e.username;
      }
      get password() {
        return this.#e.password;
      }
      get hostname() {
        return this.#e.hostname;
      }
      get port() {
        return this.#e.port;
      }
      get pathname() {
        return this.#e.pathname;
      }
      get search() {
        return this.#e.search;
      }
      get hash() {
        return this.#e.hash;
      }
    };
  }
});

// node_modules/@whatwg-node/server/node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/urlpattern-polyfill/index.cjs"(exports2, module2) {
    var { URLPattern } = require_urlpattern2();
    module2.exports = { URLPattern };
    if (!globalThis.URLPattern) {
      globalThis.URLPattern = URLPattern;
    }
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillReadableStream = void 0;
    var stream_1 = require("stream");
    function createController(desiredSize, readable) {
      let chunks = [];
      let _closed = false;
      let flushed = false;
      return {
        desiredSize,
        enqueue(chunk) {
          const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
          if (!flushed) {
            chunks.push(buf);
          } else {
            readable.push(buf);
          }
        },
        close() {
          if (chunks.length > 0) {
            this._flush();
          }
          readable.push(null);
          _closed = true;
        },
        error(error) {
          if (chunks.length > 0) {
            this._flush();
          }
          readable.destroy(error);
        },
        get _closed() {
          return _closed;
        },
        _flush() {
          flushed = true;
          if (chunks.length > 0) {
            const concatenated = Buffer.concat(chunks);
            readable.push(concatenated);
            chunks = [];
          }
        }
      };
    }
    var PonyfillReadableStream = class _PonyfillReadableStream {
      constructor(underlyingSource) {
        this.locked = false;
        if (underlyingSource instanceof _PonyfillReadableStream) {
          this.readable = underlyingSource.readable;
        } else if (underlyingSource && "read" in underlyingSource) {
          this.readable = underlyingSource;
        } else if (underlyingSource && "getReader" in underlyingSource) {
          let reader;
          let started = false;
          this.readable = new stream_1.Readable({
            read() {
              if (!started) {
                started = true;
                reader = underlyingSource.getReader();
              }
              reader.read().then(({ value, done }) => {
                if (done) {
                  this.push(null);
                } else {
                  this.push(value);
                }
              }).catch((err) => {
                this.destroy(err);
              });
            },
            destroy(err, callback) {
              reader.cancel(err).then(() => callback(err), callback);
            }
          });
        } else {
          let started = false;
          let ongoing = false;
          this.readable = new stream_1.Readable({
            read(desiredSize) {
              if (ongoing) {
                return;
              }
              ongoing = true;
              return Promise.resolve().then(async () => {
                if (!started) {
                  const controller2 = createController(desiredSize, this);
                  started = true;
                  await underlyingSource?.start?.(controller2);
                  controller2._flush();
                  if (controller2._closed) {
                    return;
                  }
                }
                const controller = createController(desiredSize, this);
                await underlyingSource?.pull?.(controller);
                controller._flush();
                ongoing = false;
              });
            },
            async destroy(err, callback) {
              try {
                await underlyingSource?.cancel?.(err);
                callback(null);
              } catch (err2) {
                callback(err2);
              }
            }
          });
        }
      }
      cancel(reason) {
        this.readable.destroy(reason);
        return Promise.resolve();
      }
      getReader(_options) {
        const iterator = this.readable[Symbol.asyncIterator]();
        this.locked = true;
        return {
          read() {
            return iterator.next();
          },
          releaseLock: () => {
            iterator.return?.();
            this.locked = false;
          },
          cancel: async (reason) => {
            await iterator.return?.(reason);
            this.locked = false;
          },
          closed: new Promise((resolve, reject) => {
            this.readable.once("end", resolve);
            this.readable.once("error", reject);
          })
        };
      }
      [Symbol.asyncIterator]() {
        return this.readable[Symbol.asyncIterator]();
      }
      tee() {
        throw new Error("Not implemented");
      }
      async pipeTo(destination) {
        const writer = destination.getWriter();
        await writer.ready;
        for await (const chunk of this.readable) {
          await writer.write(chunk);
        }
        await writer.ready;
        return writer.close();
      }
      pipeThrough({ writable, readable }) {
        this.pipeTo(writable);
        return readable;
      }
      static [Symbol.hasInstance](instance) {
        return instance != null && typeof instance === "object" && "getReader" in instance;
      }
    };
    exports2.PonyfillReadableStream = PonyfillReadableStream;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils3 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultHeadersSerializer = exports2.uint8ArrayToArrayBuffer = exports2.getHeadersObj = void 0;
    function getHeadersObj(headers) {
      if (headers == null || !("forEach" in headers)) {
        return headers;
      }
      const obj = {};
      headers.forEach((value, key) => {
        obj[key] = value;
      });
      return obj;
    }
    exports2.getHeadersObj = getHeadersObj;
    function uint8ArrayToArrayBuffer(uint8array) {
      return uint8array.buffer.slice(uint8array.byteOffset, uint8array.byteOffset + uint8array.byteLength);
    }
    exports2.uint8ArrayToArrayBuffer = uint8ArrayToArrayBuffer;
    function defaultHeadersSerializer(headers, onContentLength) {
      const headerArray = [];
      headers.forEach((value, key) => {
        if (onContentLength && key === "content-length") {
          onContentLength(value);
        }
        headerArray.push(`${key}: ${value}`);
      });
      return headerArray;
    }
    exports2.defaultHeadersSerializer = defaultHeadersSerializer;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Blob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBlob = void 0;
    var ReadableStream_js_1 = require_ReadableStream2();
    var utils_js_1 = require_utils3();
    function getBlobPartAsBuffer(blobPart) {
      if (typeof blobPart === "string") {
        return Buffer.from(blobPart);
      } else if (Buffer.isBuffer(blobPart)) {
        return blobPart;
      } else if (blobPart instanceof Uint8Array) {
        return Buffer.from(blobPart);
      } else if ("buffer" in blobPart) {
        return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
      } else {
        return Buffer.from(blobPart);
      }
    }
    function isBlob(obj) {
      return obj != null && typeof obj === "object" && obj.arrayBuffer != null;
    }
    var PonyfillBlob = class {
      constructor(blobParts, options) {
        this.blobParts = blobParts;
        this.type = options?.type || "application/octet-stream";
        this.encoding = options?.encoding || "utf8";
      }
      async buffer() {
        const bufferChunks = [];
        for (const blobPart of this.blobParts) {
          if (isBlob(blobPart)) {
            const arrayBuf = await blobPart.arrayBuffer();
            const buf = Buffer.from(arrayBuf, void 0, blobPart.size);
            bufferChunks.push(buf);
          } else {
            const buf = getBlobPartAsBuffer(blobPart);
            bufferChunks.push(buf);
          }
        }
        return Buffer.concat(bufferChunks);
      }
      async arrayBuffer() {
        const buffer = await this.buffer();
        return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
      }
      async text() {
        let text = "";
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            text += blobPart;
          } else if ("text" in blobPart) {
            text += await blobPart.text();
          } else {
            const buf = getBlobPartAsBuffer(blobPart);
            text += buf.toString(this.encoding);
          }
        }
        return text;
      }
      get size() {
        let size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            size += Buffer.byteLength(blobPart);
          } else if (isBlob(blobPart)) {
            size += blobPart.size;
          } else if ("length" in blobPart) {
            size += blobPart.length;
          } else if ("byteLength" in blobPart) {
            size += blobPart.byteLength;
          }
        }
        return size;
      }
      stream() {
        let partQueue = [];
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            partQueue = [...this.blobParts];
            if (partQueue.length === 0) {
              controller.close();
            }
          },
          pull: async (controller) => {
            const blobPart = partQueue.pop();
            if (blobPart) {
              if (isBlob(blobPart)) {
                const arrayBuffer = await blobPart.arrayBuffer();
                const buf = Buffer.from(arrayBuffer, void 0, blobPart.size);
                controller.enqueue(buf);
              } else {
                const buf = getBlobPartAsBuffer(blobPart);
                controller.enqueue(buf);
              }
            } else {
              controller.close();
            }
          }
        });
      }
      slice() {
        throw new Error("Not implemented");
      }
    };
    exports2.PonyfillBlob = PonyfillBlob;
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter2,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldIn: () => __classPrivateFieldIn2,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate2,
  __esDecorate: () => __esDecorate2,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __propKey: () => __propKey2,
  __read: () => __read2,
  __rest: () => __rest2,
  __runInitializers: () => __runInitializers2,
  __setFunctionName: () => __setFunctionName2,
  __spread: () => __spread2,
  __spreadArray: () => __spreadArray2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends2(d, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics2(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate2(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.push(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.push(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers2(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey2(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName2(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar2(m2, o) {
  for (var p in m2)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding2(o, m2, p);
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar2;
}
function __spread2() {
  for (var ar2 = [], i = 0; i < arguments.length; i++)
    ar2 = ar2.concat(__read2(arguments[i]));
  return ar2;
}
function __spreadArrays2() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k2++)
      r[k2] = a[j2];
  return r;
}
function __spreadArray2(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar2; i < l; i++) {
      if (ar2 || !(i in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i);
        ar2[i] = from[i];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
function __await2(v2) {
  return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n, v2, a, b2]) > 1 || resume(n, v2);
        });
      };
  }
  function resume(n, v2) {
    try {
      step(g[n](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v2) {
    if (f(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator2(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v2) {
      return (p = !p) ? { value: __await2(o[n](v2)), done: false } : f ? f(v2) : v2;
    } : f;
  }
}
function __asyncValues2(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw2) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw2 });
  } else {
    cooked.raw = raw2;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding2(result, mod, k2);
  }
  __setModuleDefault2(result, mod);
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet2(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn2(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
var extendStatics2, __assign2, __createBinding2, __setModuleDefault2;
var init_tslib_es62 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d, b2) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics2(d, b2);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    __createBinding2 = Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    };
    __setModuleDefault2 = Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    };
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/File.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillFile = void 0;
    var Blob_js_1 = require_Blob2();
    var PonyfillFile = class extends Blob_js_1.PonyfillBlob {
      constructor(fileBits, name, options) {
        super(fileBits, options);
        this.name = name;
        this.webkitRelativePath = "";
        this.lastModified = options?.lastModified || Date.now();
      }
    };
    exports2.PonyfillFile = PonyfillFile;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/FormData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStreamFromFormData = exports2.PonyfillFormData = void 0;
    var File_js_1 = require_File2();
    var ReadableStream_js_1 = require_ReadableStream2();
    var PonyfillFormData = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      append(name, value, fileName) {
        let values = this.map.get(name);
        if (!values) {
          values = [];
          this.map.set(name, values);
        }
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        values.push(entry);
      }
      delete(name) {
        this.map.delete(name);
      }
      get(name) {
        const values = this.map.get(name);
        return values ? values[0] : null;
      }
      getAll(name) {
        return this.map.get(name) || [];
      }
      has(name) {
        return this.map.has(name);
      }
      set(name, value, fileName) {
        const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
        this.map.set(name, [entry]);
      }
      *[Symbol.iterator]() {
        for (const [key, values] of this.map) {
          for (const value of values) {
            yield [key, value];
          }
        }
      }
      entries() {
        return this[Symbol.iterator]();
      }
      keys() {
        return this.map.keys();
      }
      *values() {
        for (const values of this.map.values()) {
          for (const value of values) {
            yield value;
          }
        }
      }
      forEach(callback) {
        for (const [key, value] of this) {
          callback(value, key, this);
        }
      }
    };
    exports2.PonyfillFormData = PonyfillFormData;
    function getStreamFromFormData(formData, boundary = "---") {
      const entries = [];
      let sentInitialHeader = false;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          formData.forEach((value, key) => {
            if (!sentInitialHeader) {
              controller.enqueue(Buffer.from(`--${boundary}\r
`));
              sentInitialHeader = true;
            }
            entries.push([key, value]);
          });
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}--\r
`));
            controller.close();
          }
        },
        pull: async (controller) => {
          const entry = entries.shift();
          if (entry) {
            const [key, value] = entry;
            if (typeof value === "string") {
              controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r
\r
`));
              controller.enqueue(Buffer.from(value));
            } else {
              let filenamePart = "";
              if (value.name) {
                filenamePart = `; filename="${value.name}"`;
              }
              controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r
`));
              controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r
\r
`));
              const entryStream = value.stream();
              for await (const chunk of entryStream) {
                controller.enqueue(chunk);
              }
            }
            if (entries.length === 0) {
              controller.enqueue(Buffer.from(`\r
--${boundary}--\r
`));
              controller.close();
            } else {
              controller.enqueue(Buffer.from(`\r
--${boundary}\r
`));
            }
          } else {
            controller.enqueue(Buffer.from(`\r
--${boundary}--\r
`));
            controller.close();
          }
        }
      });
    }
    exports2.getStreamFromFormData = getStreamFromFormData;
    function getNormalizedFile(name, blob, fileName) {
      if (blob instanceof File_js_1.PonyfillFile) {
        if (fileName != null) {
          return new File_js_1.PonyfillFile([blob], fileName, {
            type: blob.type,
            lastModified: blob.lastModified
          });
        }
        return blob;
      }
      return new File_js_1.PonyfillFile([blob], fileName || name, { type: blob.type });
    }
    function isBlob(value) {
      return value != null && typeof value === "object" && typeof value.arrayBuffer === "function";
    }
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Body.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBody = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var stream_1 = require("stream");
    var busboy_1 = tslib_1.__importDefault(require_lib());
    var Blob_js_1 = require_Blob2();
    var File_js_1 = require_File2();
    var FormData_js_1 = require_FormData2();
    var ReadableStream_js_1 = require_ReadableStream2();
    var utils_js_1 = require_utils3();
    var BodyInitType;
    (function(BodyInitType2) {
      BodyInitType2["ReadableStream"] = "ReadableStream";
      BodyInitType2["Blob"] = "Blob";
      BodyInitType2["FormData"] = "FormData";
      BodyInitType2["ArrayBuffer"] = "ArrayBuffer";
      BodyInitType2["String"] = "String";
      BodyInitType2["Readable"] = "Readable";
      BodyInitType2["Buffer"] = "Buffer";
      BodyInitType2["Uint8Array"] = "Uint8Array";
    })(BodyInitType || (BodyInitType = {}));
    var PonyfillBody = class {
      constructor(bodyInit, options = {}) {
        this.bodyInit = bodyInit;
        this.options = options;
        this.bodyUsed = false;
        this.contentType = null;
        this.contentLength = null;
        this._bodyFactory = () => null;
        this._generatedBody = null;
        const { bodyFactory, contentType, contentLength, bodyType } = processBodyInit(bodyInit);
        this._bodyFactory = bodyFactory;
        this.contentType = contentType;
        this.contentLength = contentLength;
        this.bodyType = bodyType;
      }
      generateBody() {
        if (this._generatedBody) {
          return this._generatedBody;
        }
        const body = this._bodyFactory();
        this._generatedBody = body;
        return body;
      }
      get body() {
        const _body = this.generateBody();
        if (_body != null) {
          const ponyfillReadableStream = _body;
          const readable = _body.readable;
          return new Proxy(_body.readable, {
            get(_2, prop) {
              if (prop in ponyfillReadableStream) {
                const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
                if (typeof ponyfillReadableStreamProp === "function") {
                  return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
                }
                return ponyfillReadableStreamProp;
              }
              if (prop in readable) {
                const readableProp = readable[prop];
                if (typeof readableProp === "function") {
                  return readableProp.bind(readable);
                }
                return readableProp;
              }
            }
          });
        }
        return null;
      }
      async arrayBuffer() {
        if (this.bodyType === BodyInitType.ArrayBuffer) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.Buffer) {
          const typedBodyInit = this.bodyInit;
          return (0, utils_js_1.uint8ArrayToArrayBuffer)(typedBodyInit);
        }
        if (this.bodyType === BodyInitType.String) {
          const buffer = Buffer.from(this.bodyInit);
          return (0, utils_js_1.uint8ArrayToArrayBuffer)(buffer);
        }
        if (this.bodyType === BodyInitType.Blob) {
          const blob2 = this.bodyInit;
          const arrayBuffer = await blob2.arrayBuffer();
          return arrayBuffer;
        }
        const blob = await this.blob();
        return blob.arrayBuffer();
      }
      _collectChunksFromReadable() {
        return new Promise((resolve, reject) => {
          const chunks = [];
          const _body = this.generateBody();
          if (_body) {
            _body.readable.on("data", (chunk) => {
              chunks.push(chunk);
            });
            _body.readable.on("end", () => {
              resolve(chunks);
            });
            _body.readable.on("error", (e) => {
              reject(e);
            });
          } else {
            resolve(chunks);
          }
        });
      }
      async blob() {
        if (this.bodyType === BodyInitType.Blob) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String || this.bodyType === BodyInitType.Buffer || this.bodyType === BodyInitType.Uint8Array) {
          const bodyInitTyped = this.bodyInit;
          return new Blob_js_1.PonyfillBlob([bodyInitTyped], {
            type: this.contentType || ""
          });
        }
        if (this.bodyType === BodyInitType.ArrayBuffer) {
          const bodyInitTyped = this.bodyInit;
          const buf = Buffer.from(bodyInitTyped, void 0, bodyInitTyped.byteLength);
          return new Blob_js_1.PonyfillBlob([buf], {
            type: this.contentType || ""
          });
        }
        const chunks = await this._collectChunksFromReadable();
        return new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || ""
        });
      }
      formData(opts) {
        if (this.bodyType === BodyInitType.FormData) {
          return Promise.resolve(this.bodyInit);
        }
        const formData = new FormData_js_1.PonyfillFormData();
        const _body = this.generateBody();
        if (_body == null) {
          return Promise.resolve(formData);
        }
        const formDataLimits = {
          ...this.options.formDataLimits,
          ...opts?.formDataLimits
        };
        return new Promise((resolve, reject) => {
          const bb = (0, busboy_1.default)({
            headers: {
              "content-type": this.contentType || ""
            },
            limits: formDataLimits,
            defParamCharset: "utf-8"
          });
          bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
            if (nameTruncated) {
              reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
            }
            if (valueTruncated) {
              reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
            }
            formData.set(name, value);
          });
          bb.on("fieldsLimit", () => {
            reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
          });
          bb.on("file", (name, fileStream, { filename, mimeType }) => {
            const chunks = [];
            fileStream.on("limit", () => {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            });
            fileStream.on("data", (chunk) => {
              chunks.push(Buffer.from(chunk));
            });
            fileStream.on("close", () => {
              if (fileStream.truncated) {
                reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
              }
              const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
              formData.set(name, file);
            });
          });
          bb.on("filesLimit", () => {
            reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
          });
          bb.on("partsLimit", () => {
            reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
          });
          bb.on("close", () => {
            resolve(formData);
          });
          bb.on("error", (err) => {
            reject(err);
          });
          _body?.readable.pipe(bb);
        });
      }
      async buffer() {
        if (this.bodyType === BodyInitType.Buffer) {
          return this.bodyInit;
        }
        if (this.bodyType === BodyInitType.String) {
          return Buffer.from(this.bodyInit);
        }
        if (this.bodyType === BodyInitType.Uint8Array || this.bodyType === BodyInitType.ArrayBuffer) {
          const bodyInitTyped = this.bodyInit;
          const buffer = Buffer.from(bodyInitTyped, "byteOffset" in bodyInitTyped ? bodyInitTyped.byteOffset : void 0, bodyInitTyped.byteLength);
          return buffer;
        }
        if (this.bodyType === BodyInitType.Blob) {
          if (this.bodyInit instanceof Blob_js_1.PonyfillBlob) {
            return this.bodyInit.buffer();
          }
          const bodyInitTyped = this.bodyInit;
          const buffer = Buffer.from(await bodyInitTyped.arrayBuffer(), void 0, bodyInitTyped.size);
          return buffer;
        }
        const chunks = await this._collectChunksFromReadable();
        return Buffer.concat(chunks);
      }
      async json() {
        const text = await this.text();
        return JSON.parse(text);
      }
      async text() {
        if (this.bodyType === BodyInitType.String) {
          return this.bodyInit;
        }
        const buffer = await this.buffer();
        return buffer.toString("utf-8");
      }
    };
    exports2.PonyfillBody = PonyfillBody;
    function processBodyInit(bodyInit) {
      if (bodyInit == null) {
        return {
          bodyFactory: () => null,
          contentType: null,
          contentLength: null
        };
      }
      if (typeof bodyInit === "string") {
        const buffer = Buffer.from(bodyInit);
        const contentLength = buffer.byteLength;
        return {
          bodyType: BodyInitType.String,
          contentType: "text/plain;charset=UTF-8",
          contentLength,
          bodyFactory() {
            const readable = stream_1.Readable.from(buffer);
            return new ReadableStream_js_1.PonyfillReadableStream(readable);
          }
        };
      }
      if (bodyInit instanceof Buffer) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.Buffer,
          contentLength,
          contentType: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream) {
        return {
          bodyType: BodyInitType.ReadableStream,
          bodyFactory: () => bodyInit,
          contentType: null,
          contentLength: null
        };
      }
      if (bodyInit instanceof Blob_js_1.PonyfillBlob) {
        return {
          bodyType: BodyInitType.Blob,
          contentType: bodyInit.type,
          contentLength: bodyInit.size,
          bodyFactory() {
            return bodyInit.stream();
          }
        };
      }
      if (bodyInit instanceof Uint8Array) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.Uint8Array,
          contentLength,
          contentType: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if ("buffer" in bodyInit) {
        const contentLength = bodyInit.byteLength;
        return {
          contentLength,
          contentType: null,
          bodyFactory() {
            const buffer = Buffer.from(bodyInit);
            const readable = stream_1.Readable.from(buffer);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof ArrayBuffer) {
        const contentLength = bodyInit.byteLength;
        return {
          bodyType: BodyInitType.ArrayBuffer,
          contentType: null,
          contentLength,
          bodyFactory() {
            const buffer = Buffer.from(bodyInit, void 0, bodyInit.byteLength);
            const readable = stream_1.Readable.from(buffer);
            const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
            return body;
          }
        };
      }
      if (bodyInit instanceof stream_1.Readable) {
        return {
          bodyType: BodyInitType.Readable,
          contentType: null,
          contentLength: null,
          bodyFactory() {
            const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
            return body;
          }
        };
      }
      if ("stream" in bodyInit) {
        return {
          contentType: bodyInit.type,
          contentLength: bodyInit.size,
          bodyFactory() {
            const bodyStream = bodyInit.stream();
            const body = new ReadableStream_js_1.PonyfillReadableStream(bodyStream);
            return body;
          }
        };
      }
      if ("sort" in bodyInit) {
        const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
        return {
          bodyType: BodyInitType.String,
          contentType,
          contentLength: null,
          bodyFactory() {
            const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
            return body;
          }
        };
      }
      if ("forEach" in bodyInit) {
        const boundary = Math.random().toString(36).substr(2);
        const contentType = `multipart/form-data; boundary=${boundary}`;
        return {
          contentType,
          contentLength: null,
          bodyFactory() {
            return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
          }
        };
      }
      if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
        return {
          contentType: null,
          contentLength: null,
          bodyFactory() {
            const readable = stream_1.Readable.from(bodyInit);
            return new ReadableStream_js_1.PonyfillReadableStream(readable);
          }
        };
      }
      throw new Error("Unknown body type");
    }
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Headers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitSetCookieHeader = exports2.PonyfillHeaders = exports2.isHeadersLike = void 0;
    var node_util_1 = require("node:util");
    function isHeadersLike(headers) {
      return headers?.get && headers?.forEach;
    }
    exports2.isHeadersLike = isHeadersLike;
    var PonyfillHeaders = class {
      constructor(headersInit) {
        this.headersInit = headersInit;
        this.objectNormalizedKeysOfHeadersInit = [];
        this.objectOriginalKeysOfHeadersInit = [];
      }
      // perf: we don't need to build `this.map` for Requests, as we can access the headers directly
      _get(key) {
        if (this._map) {
          return this._map.get(key.toLowerCase()) || null;
        }
        if (this.headersInit == null) {
          return null;
        }
        const normalized = key.toLowerCase();
        if (Array.isArray(this.headersInit)) {
          return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
        } else if (isHeadersLike(this.headersInit)) {
          return this.headersInit.get(normalized);
        } else {
          const initValue = this.headersInit[key] || this.headersInit[normalized];
          if (initValue != null) {
            return initValue;
          }
          if (!this.objectNormalizedKeysOfHeadersInit.length) {
            Object.keys(this.headersInit).forEach((k2) => {
              this.objectOriginalKeysOfHeadersInit.push(k2);
              this.objectNormalizedKeysOfHeadersInit.push(k2.toLowerCase());
            });
          }
          const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
          if (index === -1) {
            return null;
          }
          const originalKey = this.objectOriginalKeysOfHeadersInit[index];
          return this.headersInit[originalKey];
        }
      }
      // perf: Build the map of headers lazily, only when we need to access all headers or write to it.
      // I could do a getter here, but I'm too lazy to type `getter`.
      getMap() {
        if (!this._map) {
          if (this.headersInit != null) {
            if (Array.isArray(this.headersInit)) {
              this._map = new Map(this.headersInit);
            } else if (isHeadersLike(this.headersInit)) {
              this._map = /* @__PURE__ */ new Map();
              this.headersInit.forEach((value, key) => {
                this._map.set(key, value);
              });
            } else {
              this._map = /* @__PURE__ */ new Map();
              for (const initKey in this.headersInit) {
                const initValue = this.headersInit[initKey];
                if (initValue != null) {
                  const normalizedKey = initKey.toLowerCase();
                  this._map.set(normalizedKey, initValue);
                }
              }
            }
          } else {
            this._map = /* @__PURE__ */ new Map();
          }
        }
        return this._map;
      }
      append(name, value) {
        const key = name.toLowerCase();
        const existingValue = this.getMap().get(key);
        const finalValue = existingValue ? `${existingValue}, ${value}` : value;
        this.getMap().set(key, finalValue);
      }
      get(name) {
        const value = this._get(name);
        if (value == null) {
          return null;
        }
        return value;
      }
      has(name) {
        return !!this._get(name);
      }
      set(name, value) {
        const key = name.toLowerCase();
        this.getMap().set(key, value);
      }
      delete(name) {
        const key = name.toLowerCase();
        this.getMap().delete(key);
      }
      forEach(callback) {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              this.headersInit.forEach(([key, value]) => {
                callback(value, key, this);
              });
              return;
            }
            if (isHeadersLike(this.headersInit)) {
              this.headersInit.forEach(callback);
              return;
            }
            Object.entries(this.headersInit).forEach(([key, value]) => {
              if (value != null) {
                callback(value, key, this);
              }
            });
          }
          return;
        }
        this.getMap().forEach((value, key) => {
          callback(value, key, this);
        });
      }
      keys() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit.map(([key]) => key)[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.keys();
            }
            return Object.keys(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().keys();
      }
      values() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.values();
            }
            return Object.values(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().values();
      }
      entries() {
        if (!this._map) {
          if (this.headersInit) {
            if (Array.isArray(this.headersInit)) {
              return this.headersInit[Symbol.iterator]();
            }
            if (isHeadersLike(this.headersInit)) {
              return this.headersInit.entries();
            }
            return Object.entries(this.headersInit)[Symbol.iterator]();
          }
        }
        return this.getMap().entries();
      }
      getSetCookie() {
        const setCookieHeader = this.get("set-cookie");
        if (!setCookieHeader) {
          return [];
        }
        return splitSetCookieHeader(setCookieHeader);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        const record = {};
        this.forEach((value, key) => {
          if (key === "set-cookie") {
            record["set-cookie"] = this.getSetCookie();
          } else {
            record[key] = value.includes(",") ? value.split(",").map((el2) => el2.trim()) : value;
          }
        });
        return `Headers ${(0, node_util_1.inspect)(record)}`;
      }
    };
    exports2.PonyfillHeaders = PonyfillHeaders;
    function splitSetCookieHeader(setCookieHeader) {
      const setCookieHeaders = [];
      let currentStr = "";
      let ignoreComma = false;
      for (const ch of setCookieHeader) {
        if (currentStr.endsWith("Expires=")) {
          ignoreComma = true;
        }
        if (ignoreComma) {
          if (ch === ";") {
            ignoreComma = false;
          }
          if (ch === "," && currentStr.split("Expires=")[1].length > 3) {
            ignoreComma = false;
          }
        }
        if (ch === "," && !ignoreComma) {
          setCookieHeaders.push(currentStr.trim());
          currentStr = "";
        } else {
          currentStr += ch;
        }
      }
      if (currentStr) {
        setCookieHeaders.push(currentStr.trim());
      }
      return setCookieHeaders;
    }
    exports2.splitSetCookieHeader = splitSetCookieHeader;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Response.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillResponse = void 0;
    var http_1 = require("http");
    var Body_js_1 = require_Body2();
    var Headers_js_1 = require_Headers2();
    var JSON_CONTENT_TYPE = "application/json; charset=utf-8";
    var PonyfillResponse = class _PonyfillResponse extends Body_js_1.PonyfillBody {
      constructor(body, init) {
        super(body || null, init);
        this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
        this.status = init?.status || 200;
        this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
        this.url = init?.url || "";
        this.redirected = init?.redirected || false;
        this.type = init?.type || "default";
        const contentTypeInHeaders = this.headers.get("content-type");
        if (!contentTypeInHeaders) {
          if (this.contentType) {
            this.headers.set("content-type", this.contentType);
          }
        } else {
          this.contentType = contentTypeInHeaders;
        }
        const contentLengthInHeaders = this.headers.get("content-length");
        if (!contentLengthInHeaders) {
          if (this.contentLength) {
            this.headers.set("content-length", this.contentLength.toString());
          }
        } else {
          this.contentLength = parseInt(contentLengthInHeaders, 10);
        }
      }
      get ok() {
        return this.status >= 200 && this.status < 300;
      }
      clone() {
        return new _PonyfillResponse(this.body, this);
      }
      static error() {
        return new _PonyfillResponse(null, {
          status: 500,
          statusText: "Internal Server Error"
        });
      }
      static redirect(url, status = 301) {
        if (status < 300 || status > 399) {
          throw new RangeError("Invalid status code");
        }
        return new _PonyfillResponse(null, {
          headers: {
            location: url
          },
          status
        });
      }
      static json(data, init = {}) {
        init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
        if (!init.headers.has("content-type")) {
          init.headers.set("content-type", JSON_CONTENT_TYPE);
        }
        return new _PonyfillResponse(JSON.stringify(data), init);
      }
    };
    exports2.PonyfillResponse = PonyfillResponse;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchCurl = void 0;
    var node_stream_1 = require("node:stream");
    var Response_js_1 = require_Response2();
    var utils_js_1 = require_utils3();
    function fetchCurl(fetchRequest) {
      const { Curl, CurlCode, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
      const curlHandle = new Curl();
      if (fetchRequest["_signal"]) {
        fetchRequest["_signal"].onabort = () => {
          curlHandle.pause(CurlPause.Recv);
        };
      }
      curlHandle.enable(CurlFeature.NoDataParsing);
      curlHandle.setOpt("URL", fetchRequest.url);
      curlHandle.setOpt("SSL_VERIFYPEER", false);
      curlHandle.enable(CurlFeature.StreamResponse);
      curlHandle.setStreamProgressCallback(function() {
        return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
      });
      if (fetchRequest["bodyType"] === "String") {
        curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
      } else {
        const nodeReadable = fetchRequest.body != null ? "pipe" in fetchRequest.body ? fetchRequest.body : node_stream_1.Readable.from(fetchRequest.body) : null;
        if (nodeReadable) {
          curlHandle.setOpt("UPLOAD", true);
          curlHandle.setUploadStream(nodeReadable);
        }
      }
      if (process.env.DEBUG) {
        curlHandle.setOpt("VERBOSE", true);
      }
      curlHandle.setOpt("TRANSFER_ENCODING", false);
      curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
      curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
      curlHandle.setOpt("MAXREDIRS", 20);
      curlHandle.setOpt("ACCEPT_ENCODING", "");
      curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
      const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
      let size;
      const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
        size = Number(value);
      });
      if (size != null) {
        curlHandle.setOpt("INFILESIZE", size);
      }
      curlHandle.setOpt("HTTPHEADER", curlHeaders);
      curlHandle.enable(CurlFeature.NoHeaderParsing);
      return new Promise(function promiseResolver(resolve, reject) {
        curlHandle.once("end", function endListener() {
          curlHandle.close();
        });
        curlHandle.once("error", function errorListener(error) {
          if (error.isCurlError && error.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
          } else {
            reject(error);
          }
          curlHandle.close();
        });
        curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
          const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
            if (headerFilter && !headerFilter.startsWith("HTTP/")) {
              if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
                reject(new Error("redirect is not allowed"));
              }
              return true;
            }
            return false;
          });
          const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
          resolve(new Response_js_1.PonyfillResponse(stream, {
            status,
            headers: headersInit,
            url: fetchRequest.url
          }));
        });
        curlHandle.perform();
      });
    }
    exports2.fetchCurl = fetchCurl;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js
var require_AbortError2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/AbortError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillAbortError = void 0;
    var PonyfillAbortError = class extends Error {
      constructor(reason) {
        let message = "The operation was aborted";
        if (reason) {
          message += ` reason: ${reason}`;
        }
        super(message, {
          cause: reason
        });
        this.name = "AbortError";
      }
      get reason() {
        return this.cause;
      }
    };
    exports2.PonyfillAbortError = PonyfillAbortError;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/Request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillRequest = void 0;
    var Body_js_1 = require_Body2();
    var Headers_js_1 = require_Headers2();
    function isRequest(input) {
      return input[Symbol.toStringTag] === "Request";
    }
    var PonyfillRequest = class _PonyfillRequest extends Body_js_1.PonyfillBody {
      constructor(input, options) {
        let url;
        let bodyInit = null;
        let requestInit;
        if (typeof input === "string") {
          url = input;
        } else if ("href" in input) {
          url = input.toString();
        } else if (isRequest(input)) {
          url = input.url;
          bodyInit = input.body;
          requestInit = input;
        }
        if (options != null) {
          bodyInit = options.body || null;
          requestInit = options;
        }
        super(bodyInit, options);
        this.cache = requestInit?.cache || "default";
        this.credentials = requestInit?.credentials || "same-origin";
        this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
        this.integrity = requestInit?.integrity || "";
        this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
        this.method = requestInit?.method?.toUpperCase() || "GET";
        this.mode = requestInit?.mode || "cors";
        this.redirect = requestInit?.redirect || "follow";
        this.referrer = requestInit?.referrer || "about:client";
        this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
        this._signal = requestInit?.signal;
        this.headersSerializer = requestInit?.headersSerializer;
        this.url = url || "";
        this.destination = "document";
        this.priority = "auto";
        if (this.method !== "GET" && this.method !== "HEAD") {
          const contentTypeInHeaders = this.headers.get("content-type");
          if (!contentTypeInHeaders) {
            if (this.contentType) {
              this.headers.set("content-type", this.contentType);
            }
          } else {
            this.contentType = contentTypeInHeaders;
          }
          const contentLengthInHeaders = this.headers.get("content-length");
          if (!contentLengthInHeaders) {
            if (this.contentLength) {
              this.headers.set("content-length", this.contentLength.toString());
            }
          } else {
            this.contentLength = parseInt(contentLengthInHeaders, 10);
          }
        }
      }
      get signal() {
        if (!this._signal) {
          this._signal = new AbortController().signal;
        }
        return this._signal;
      }
      clone() {
        return new _PonyfillRequest(this);
      }
    };
    exports2.PonyfillRequest = PonyfillRequest;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillURLSearchParams = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
    var PonyfillURLSearchParams = class {
      constructor(init) {
        if (init) {
          if (typeof init === "string") {
            this.params = fast_querystring_1.default.parse(init);
          } else if (Array.isArray(init)) {
            this.params = {};
            for (const [key, value] of init) {
              this.params[key] = value;
            }
          } else if ("entries" in init) {
            this.params = {};
            for (const [key, value] of init.entries()) {
              this.params[key] = value;
            }
          } else {
            this.params = init;
          }
        } else {
          this.params = {};
        }
      }
      append(name, value) {
        const existingValue = this.params[name];
        const finalValue = existingValue ? `${existingValue},${value}` : value;
        this.params[name] = finalValue;
      }
      delete(name) {
        delete this.params[name];
      }
      get(name) {
        const value = this.params[name];
        if (Array.isArray(value)) {
          return value[0] || null;
        }
        return value || null;
      }
      getAll(name) {
        const value = this.params[name];
        if (!Array.isArray(value)) {
          return value ? [value] : [];
        }
        return value;
      }
      has(name) {
        return name in this.params;
      }
      set(name, value) {
        this.params[name] = value;
      }
      sort() {
        const sortedKeys = Object.keys(this.params).sort();
        const sortedParams = {};
        for (const key of sortedKeys) {
          sortedParams[key] = this.params[key];
        }
        this.params = sortedParams;
      }
      toString() {
        return fast_querystring_1.default.stringify(this.params);
      }
      *keys() {
        for (const key in this.params) {
          yield key;
        }
      }
      *entries() {
        for (const key of this.keys()) {
          const value = this.params[key];
          if (Array.isArray(value)) {
            for (const item of value) {
              yield [key, item];
            }
          } else {
            yield [key, value];
          }
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      forEach(callback) {
        for (const [key, value] of this) {
          callback(value, key, this);
        }
      }
      get size() {
        return Object.keys(this.params).length;
      }
    };
    exports2.PonyfillURLSearchParams = PonyfillURLSearchParams;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/URL.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillURL = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
    var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
    var URLSearchParams_js_1 = require_URLSearchParams2();
    fast_url_parser_1.default.queryString = fast_querystring_1.default;
    var PonyfillURL = class _PonyfillURL extends fast_url_parser_1.default {
      constructor(url, base) {
        super();
        if (url.startsWith("data:")) {
          this.protocol = "data:";
          this.pathname = url.slice("data:".length);
          return;
        }
        this.parse(url, false);
        if (base) {
          const baseParsed = typeof base === "string" ? new _PonyfillURL(base) : base;
          this.protocol = this.protocol || baseParsed.protocol;
          this.host = this.host || baseParsed.host;
          this.pathname = this.pathname || baseParsed.pathname;
        }
      }
      get origin() {
        return `${this.protocol}//${this.host}`;
      }
      get searchParams() {
        if (!this._searchParams) {
          this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
        }
        return this._searchParams;
      }
      get username() {
        return this.auth?.split(":")[0] || "";
      }
      set username(value) {
        this.auth = `${value}:${this.password}`;
      }
      get password() {
        return this.auth?.split(":")[1] || "";
      }
      set password(value) {
        this.auth = `${this.username}:${value}`;
      }
      toString() {
        return this.format();
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.PonyfillURL = PonyfillURL;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchNodeHttp = void 0;
    var http_1 = require("http");
    var https_1 = require("https");
    var stream_1 = require("stream");
    var zlib_1 = require("zlib");
    var AbortError_js_1 = require_AbortError2();
    var Request_js_1 = require_Request2();
    var Response_js_1 = require_Response2();
    var URL_js_1 = require_URL2();
    var utils_js_1 = require_utils3();
    function getRequestFnForProtocol(url) {
      if (url.startsWith("http:")) {
        return http_1.request;
      } else if (url.startsWith("https:")) {
        return https_1.request;
      }
      throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
    }
    function fetchNodeHttp(fetchRequest) {
      return new Promise((resolve, reject) => {
        try {
          const requestFn = getRequestFnForProtocol(fetchRequest.url);
          const nodeReadable = fetchRequest.body != null ? "pipe" in fetchRequest.body ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
          const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
          const nodeHeaders = headersSerializer(fetchRequest.headers);
          const nodeRequest = requestFn(fetchRequest.url, {
            method: fetchRequest.method,
            headers: nodeHeaders,
            signal: fetchRequest["_signal"] ?? void 0,
            agent: fetchRequest.agent
          });
          fetchRequest["_signal"]?.addEventListener("abort", () => {
            if (!nodeRequest.aborted) {
              nodeRequest.abort();
            }
          });
          nodeRequest.once("abort", (reason) => {
            reject(new AbortError_js_1.PonyfillAbortError(reason));
          });
          nodeRequest.once("response", (nodeResponse) => {
            let responseBody = nodeResponse;
            const contentEncoding = nodeResponse.headers["content-encoding"];
            switch (contentEncoding) {
              case "x-gzip":
              case "gzip":
                responseBody = nodeResponse.pipe((0, zlib_1.createGunzip)());
                break;
              case "x-deflate":
              case "deflate":
                responseBody = nodeResponse.pipe((0, zlib_1.createInflate)());
                break;
              case "br":
                responseBody = nodeResponse.pipe((0, zlib_1.createBrotliDecompress)());
                break;
            }
            if (nodeResponse.headers.location) {
              if (fetchRequest.redirect === "error") {
                const redirectError = new Error("Redirects are not allowed");
                reject(redirectError);
                nodeResponse.resume();
                return;
              }
              if (fetchRequest.redirect === "follow") {
                const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
                const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
                resolve(redirectResponse$.then((redirectResponse) => {
                  redirectResponse.redirected = true;
                  return redirectResponse;
                }));
                nodeResponse.resume();
                return;
              }
            }
            const ponyfillResponse = new Response_js_1.PonyfillResponse(responseBody, {
              status: nodeResponse.statusCode,
              statusText: nodeResponse.statusMessage,
              headers: nodeResponse.headers,
              url: fetchRequest.url
            });
            resolve(ponyfillResponse);
          });
          nodeRequest.once("error", reject);
          if (nodeReadable) {
            nodeReadable.pipe(nodeRequest);
          } else {
            nodeRequest.end();
          }
        } catch (e) {
          reject(e);
        }
      });
    }
    exports2.fetchNodeHttp = fetchNodeHttp;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fetchPonyfill = void 0;
    var fs_1 = require("fs");
    var url_1 = require("url");
    var Blob_js_1 = require_Blob2();
    var fetchCurl_js_1 = require_fetchCurl2();
    var fetchNodeHttp_js_1 = require_fetchNodeHttp2();
    var Request_js_1 = require_Request2();
    var Response_js_1 = require_Response2();
    var BASE64_SUFFIX = ";base64";
    function getResponseForFile(url) {
      const path = (0, url_1.fileURLToPath)(url);
      const readable = (0, fs_1.createReadStream)(path);
      return new Response_js_1.PonyfillResponse(readable);
    }
    function getResponseForDataUri(url) {
      const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
      const data = decodeURIComponent(datas.join(","));
      if (mimeType.endsWith(BASE64_SUFFIX)) {
        const buffer = Buffer.from(data, "base64url");
        const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
        const file = new Blob_js_1.PonyfillBlob([buffer], { type: realMimeType });
        return new Response_js_1.PonyfillResponse(file, {
          status: 200,
          statusText: "OK"
        });
      }
      return new Response_js_1.PonyfillResponse(data, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": mimeType
        }
      });
    }
    async function fetchPonyfill(info, init) {
      if (typeof info === "string" || "href" in info) {
        const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
        return fetchPonyfill(ponyfillRequest);
      }
      const fetchRequest = info;
      if (fetchRequest.url.startsWith("data:")) {
        const response = getResponseForDataUri(fetchRequest.url);
        return Promise.resolve(response);
      }
      if (fetchRequest.url.startsWith("file:")) {
        const response = getResponseForFile(fetchRequest.url);
        return Promise.resolve(response);
      }
      if (globalThis.libcurl) {
        return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
      }
      return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
    }
    exports2.fetchPonyfill = fetchPonyfill;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PonyfillBtoa = exports2.PonyfillTextDecoder = exports2.PonyfillTextEncoder = void 0;
    var PonyfillTextEncoder = class {
      constructor(encoding = "utf-8") {
        this.encoding = encoding;
      }
      encode(input) {
        return Buffer.from(input, this.encoding);
      }
      encodeInto(source, destination) {
        const buffer = this.encode(source);
        const copied = buffer.copy(destination);
        return {
          read: copied,
          written: copied
        };
      }
    };
    exports2.PonyfillTextEncoder = PonyfillTextEncoder;
    var PonyfillTextDecoder = class {
      constructor(encoding = "utf-8", options) {
        this.encoding = encoding;
        this.fatal = false;
        this.ignoreBOM = false;
        if (options) {
          this.fatal = options.fatal || false;
          this.ignoreBOM = options.ignoreBOM || false;
        }
      }
      decode(input) {
        return Buffer.from(input).toString(this.encoding);
      }
    };
    exports2.PonyfillTextDecoder = PonyfillTextDecoder;
    function PonyfillBtoa(input) {
      return Buffer.from(input, "binary").toString("base64");
    }
    exports2.PonyfillBtoa = PonyfillBtoa;
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/node-fetch/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLSearchParams = exports2.URL = exports2.btoa = exports2.TextDecoder = exports2.TextEncoder = exports2.Blob = exports2.FormData = exports2.File = exports2.ReadableStream = exports2.Response = exports2.Request = exports2.Body = exports2.Headers = exports2.fetch = void 0;
    var fetch_js_1 = require_fetch2();
    Object.defineProperty(exports2, "fetch", { enumerable: true, get: function() {
      return fetch_js_1.fetchPonyfill;
    } });
    var Headers_js_1 = require_Headers2();
    Object.defineProperty(exports2, "Headers", { enumerable: true, get: function() {
      return Headers_js_1.PonyfillHeaders;
    } });
    var Body_js_1 = require_Body2();
    Object.defineProperty(exports2, "Body", { enumerable: true, get: function() {
      return Body_js_1.PonyfillBody;
    } });
    var Request_js_1 = require_Request2();
    Object.defineProperty(exports2, "Request", { enumerable: true, get: function() {
      return Request_js_1.PonyfillRequest;
    } });
    var Response_js_1 = require_Response2();
    Object.defineProperty(exports2, "Response", { enumerable: true, get: function() {
      return Response_js_1.PonyfillResponse;
    } });
    var ReadableStream_js_1 = require_ReadableStream2();
    Object.defineProperty(exports2, "ReadableStream", { enumerable: true, get: function() {
      return ReadableStream_js_1.PonyfillReadableStream;
    } });
    var File_js_1 = require_File2();
    Object.defineProperty(exports2, "File", { enumerable: true, get: function() {
      return File_js_1.PonyfillFile;
    } });
    var FormData_js_1 = require_FormData2();
    Object.defineProperty(exports2, "FormData", { enumerable: true, get: function() {
      return FormData_js_1.PonyfillFormData;
    } });
    var Blob_js_1 = require_Blob2();
    Object.defineProperty(exports2, "Blob", { enumerable: true, get: function() {
      return Blob_js_1.PonyfillBlob;
    } });
    var TextEncoderDecoder_js_1 = require_TextEncoderDecoder2();
    Object.defineProperty(exports2, "TextEncoder", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillTextEncoder;
    } });
    Object.defineProperty(exports2, "TextDecoder", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillTextDecoder;
    } });
    Object.defineProperty(exports2, "btoa", { enumerable: true, get: function() {
      return TextEncoderDecoder_js_1.PonyfillBtoa;
    } });
    var URL_js_1 = require_URL2();
    Object.defineProperty(exports2, "URL", { enumerable: true, get: function() {
      return URL_js_1.PonyfillURL;
    } });
    var URLSearchParams_js_1 = require_URLSearchParams2();
    Object.defineProperty(exports2, "URLSearchParams", { enumerable: true, get: function() {
      return URLSearchParams_js_1.PonyfillURLSearchParams;
    } });
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js"(exports2, module2) {
    module2.exports = function createNodePonyfill(opts = {}) {
      const ponyfills = {};
      if (!ponyfills.URLPattern) {
        const urlPatternModule = require_urlpattern_polyfill2();
        ponyfills.URLPattern = urlPatternModule.URLPattern;
      }
      if (globalThis.Deno || process.versions.bun) {
        return globalThis;
      }
      const newNodeFetch = require_cjs2();
      ponyfills.fetch = newNodeFetch.fetch;
      ponyfills.Request = newNodeFetch.Request;
      ponyfills.Response = newNodeFetch.Response;
      ponyfills.Headers = newNodeFetch.Headers;
      ponyfills.FormData = newNodeFetch.FormData;
      ponyfills.ReadableStream = newNodeFetch.ReadableStream;
      ponyfills.URL = newNodeFetch.URL;
      ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
      ponyfills.WritableStream = globalThis.WritableStream;
      ponyfills.TransformStream = globalThis.TransformStream;
      if (!ponyfills.WritableStream) {
        const streamsWeb = require("stream/web");
        ponyfills.WritableStream = streamsWeb.WritableStream;
        ponyfills.TransformStream = streamsWeb.TransformStream;
      }
      ponyfills.Blob = newNodeFetch.Blob;
      ponyfills.File = newNodeFetch.File;
      ponyfills.crypto = globalThis.crypto;
      ponyfills.btoa = newNodeFetch.btoa;
      ponyfills.TextEncoder = newNodeFetch.TextEncoder;
      ponyfills.TextDecoder = newNodeFetch.TextDecoder;
      if (opts.formDataLimits) {
        ponyfills.Body = class Body extends newNodeFetch.Body {
          constructor(body, userOpts) {
            super(body, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
        ponyfills.Request = class Request extends newNodeFetch.Request {
          constructor(input, userOpts) {
            super(input, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
        ponyfills.Response = class Response extends newNodeFetch.Response {
          constructor(body, userOpts) {
            super(body, {
              formDataLimits: opts.formDataLimits,
              ...userOpts
            });
          }
        };
      }
      if (!ponyfills.crypto) {
        const cryptoModule = require("crypto");
        ponyfills.crypto = cryptoModule.webcrypto;
      }
      return ponyfills;
    };
  }
});

// node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var require_node_ponyfill2 = __commonJS({
  "node_modules/@whatwg-node/server/node_modules/@whatwg-node/fetch/dist/node-ponyfill.js"(exports2, module2) {
    var createNodePonyfill = require_create_node_ponyfill2();
    var ponyfills = createNodePonyfill();
    try {
      const nodelibcurlName = "node-libcurl";
      globalThis.libcurl = globalThis.libcurl || require(nodelibcurlName);
    } catch (e) {
    }
    module2.exports.fetch = ponyfills.fetch;
    module2.exports.Headers = ponyfills.Headers;
    module2.exports.Request = ponyfills.Request;
    module2.exports.Response = ponyfills.Response;
    module2.exports.FormData = ponyfills.FormData;
    module2.exports.ReadableStream = ponyfills.ReadableStream;
    module2.exports.WritableStream = ponyfills.WritableStream;
    module2.exports.TransformStream = ponyfills.TransformStream;
    module2.exports.Blob = ponyfills.Blob;
    module2.exports.File = ponyfills.File;
    module2.exports.crypto = ponyfills.crypto;
    module2.exports.btoa = ponyfills.btoa;
    module2.exports.TextEncoder = ponyfills.TextEncoder;
    module2.exports.TextDecoder = ponyfills.TextDecoder;
    module2.exports.URLPattern = ponyfills.URLPattern;
    module2.exports.URL = ponyfills.URL;
    module2.exports.URLSearchParams = ponyfills.URLSearchParams;
    exports2.createFetch = createNodePonyfill;
  }
});

// node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS({
  "node_modules/@prisma/client/runtime/library.js"(exports, module) {
    "use strict";
    var Fl = Object.create;
    var yr = Object.defineProperty;
    var kl = Object.getOwnPropertyDescriptor;
    var Ol = Object.getOwnPropertyNames;
    var Dl = Object.getPrototypeOf;
    var _l = Object.prototype.hasOwnProperty;
    var q = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
    var Rt = (e, t) => {
      for (var r in t)
        yr(e, r, { get: t[r], enumerable: true });
    };
    var Gi = (e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let i of Ol(t))
          !_l.call(e, i) && i !== r && yr(e, i, { get: () => t[i], enumerable: !(n = kl(t, i)) || n.enumerable });
      return e;
    };
    var S = (e, t, r) => (r = e != null ? Fl(Dl(e)) : {}, Gi(t || !e || !e.__esModule ? yr(r, "default", { value: e, enumerable: true }) : r, e));
    var Nl = (e) => Gi(yr({}, "__esModule", { value: true }), e);
    var no = q((om, ro) => {
      "use strict";
      var tt = 1e3, rt = tt * 60, nt = rt * 60, Ke = nt * 24, Ll = Ke * 7, $l = Ke * 365.25;
      ro.exports = function(e, t) {
        t = t || {};
        var r = typeof e;
        if (r === "string" && e.length > 0)
          return ql(e);
        if (r === "number" && isFinite(e))
          return t.long ? jl(e) : Vl(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      };
      function ql(e) {
        if (e = String(e), !(e.length > 100)) {
          var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
          if (t) {
            var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
            switch (n) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return r * $l;
              case "weeks":
              case "week":
              case "w":
                return r * Ll;
              case "days":
              case "day":
              case "d":
                return r * Ke;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return r * nt;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return r * rt;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return r * tt;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return r;
              default:
                return;
            }
          }
        }
      }
      function Vl(e) {
        var t = Math.abs(e);
        return t >= Ke ? Math.round(e / Ke) + "d" : t >= nt ? Math.round(e / nt) + "h" : t >= rt ? Math.round(e / rt) + "m" : t >= tt ? Math.round(e / tt) + "s" : e + "ms";
      }
      function jl(e) {
        var t = Math.abs(e);
        return t >= Ke ? xr(e, t, Ke, "day") : t >= nt ? xr(e, t, nt, "hour") : t >= rt ? xr(e, t, rt, "minute") : t >= tt ? xr(e, t, tt, "second") : e + " ms";
      }
      function xr(e, t, r, n) {
        var i = t >= r * 1.5;
        return Math.round(e / r) + " " + n + (i ? "s" : "");
      }
    });
    var Rn = q((sm, io) => {
      "use strict";
      function Bl(e) {
        r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = no(), r.destroy = u, Object.keys(e).forEach((c) => {
          r[c] = e[c];
        }), r.names = [], r.skips = [], r.formatters = {};
        function t(c) {
          let p = 0;
          for (let d = 0; d < c.length; d++)
            p = (p << 5) - p + c.charCodeAt(d), p |= 0;
          return r.colors[Math.abs(p) % r.colors.length];
        }
        r.selectColor = t;
        function r(c) {
          let p, d = null, f, y;
          function g(...P) {
            if (!g.enabled)
              return;
            let T = g, C = Number(/* @__PURE__ */ new Date()), x = C - (p || C);
            T.diff = x, T.prev = p, T.curr = C, p = C, P[0] = r.coerce(P[0]), typeof P[0] != "string" && P.unshift("%O");
            let R = 0;
            P[0] = P[0].replace(/%([a-zA-Z%])/g, (G, Ue) => {
              if (G === "%%")
                return "%";
              R++;
              let $ = r.formatters[Ue];
              if (typeof $ == "function") {
                let z = P[R];
                G = $.call(T, z), P.splice(R, 1), R--;
              }
              return G;
            }), r.formatArgs.call(T, P), (T.log || r.log).apply(T, P);
          }
          return g.namespace = c, g.useColors = r.useColors(), g.color = r.selectColor(c), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d !== null ? d : (f !== r.namespaces && (f = r.namespaces, y = r.enabled(c)), y), set: (P) => {
            d = P;
          } }), typeof r.init == "function" && r.init(g), g;
        }
        function n(c, p) {
          let d = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
          return d.log = this.log, d;
        }
        function i(c) {
          r.save(c), r.namespaces = c, r.names = [], r.skips = [];
          let p, d = (typeof c == "string" ? c : "").split(/[\s,]+/), f = d.length;
          for (p = 0; p < f; p++)
            d[p] && (c = d[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
        }
        function o() {
          let c = [...r.names.map(a), ...r.skips.map(a).map((p) => "-" + p)].join(",");
          return r.enable(""), c;
        }
        function s(c) {
          if (c[c.length - 1] === "*")
            return true;
          let p, d;
          for (p = 0, d = r.skips.length; p < d; p++)
            if (r.skips[p].test(c))
              return false;
          for (p = 0, d = r.names.length; p < d; p++)
            if (r.names[p].test(c))
              return true;
          return false;
        }
        function a(c) {
          return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function l(c) {
          return c instanceof Error ? c.stack || c.message : c;
        }
        function u() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return r.enable(r.load()), r;
      }
      io.exports = Bl;
    });
    var oo = q((le, br) => {
      "use strict";
      le.formatArgs = Kl;
      le.save = Ql;
      le.load = Jl;
      le.useColors = Ul;
      le.storage = Gl();
      le.destroy = (() => {
        let e = false;
        return () => {
          e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
      })();
      le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function Ul() {
        return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function Kl(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + br.exports.humanize(this.diff), !this.useColors)
          return;
        let t = "color: " + this.color;
        e.splice(1, 0, t, "color: inherit");
        let r = 0, n = 0;
        e[0].replace(/%[a-zA-Z%]/g, (i) => {
          i !== "%%" && (r++, i === "%c" && (n = r));
        }), e.splice(n, 0, t);
      }
      le.log = console.debug || console.log || (() => {
      });
      function Ql(e) {
        try {
          e ? le.storage.setItem("debug", e) : le.storage.removeItem("debug");
        } catch {
        }
      }
      function Jl() {
        let e;
        try {
          e = le.storage.getItem("debug");
        } catch {
        }
        return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
      }
      function Gl() {
        try {
          return localStorage;
        } catch {
        }
      }
      br.exports = Rn()(le);
      var { formatters: Hl } = br.exports;
      Hl.j = function(e) {
        try {
          return JSON.stringify(e);
        } catch (t) {
          return "[UnexpectedJSONParseError]: " + t.message;
        }
      };
    });
    var Mn = q((am, so) => {
      "use strict";
      so.exports = (e, t = process.argv) => {
        let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
        return n !== -1 && (i === -1 || n < i);
      };
    });
    var Fn = q((lm, lo) => {
      "use strict";
      var Wl = require("os"), ao = require("tty"), de = Mn(), { env: B } = process, Fe;
      de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? Fe = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (Fe = 1);
      "FORCE_COLOR" in B && (B.FORCE_COLOR === "true" ? Fe = 1 : B.FORCE_COLOR === "false" ? Fe = 0 : Fe = B.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B.FORCE_COLOR, 10), 3));
      function Sn(e) {
        return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function In(e, t) {
        if (Fe === 0)
          return 0;
        if (de("color=16m") || de("color=full") || de("color=truecolor"))
          return 3;
        if (de("color=256"))
          return 2;
        if (e && !t && Fe === void 0)
          return 0;
        let r = Fe || 0;
        if (B.TERM === "dumb")
          return r;
        if (process.platform === "win32") {
          let n = Wl.release().split(".");
          return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in B)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => n in B) || B.CI_NAME === "codeship" ? 1 : r;
        if ("TEAMCITY_VERSION" in B)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B.TEAMCITY_VERSION) ? 1 : 0;
        if (B.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in B) {
          let n = parseInt((B.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (B.TERM_PROGRAM) {
            case "iTerm.app":
              return n >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(B.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B.TERM) || "COLORTERM" in B ? 1 : r;
      }
      function zl(e) {
        let t = In(e, e && e.isTTY);
        return Sn(t);
      }
      lo.exports = { supportsColor: zl, stdout: Sn(In(true, ao.isatty(1))), stderr: Sn(In(true, ao.isatty(2))) };
    });
    var co = q((H, wr) => {
      "use strict";
      var Yl = require("tty"), Er = require("util");
      H.init = iu;
      H.log = tu;
      H.formatArgs = Xl;
      H.save = ru;
      H.load = nu;
      H.useColors = Zl;
      H.destroy = Er.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      H.colors = [6, 2, 3, 4, 5, 1];
      try {
        let e = Fn();
        e && (e.stderr || e).level >= 2 && (H.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
      } catch {
      }
      H.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
        let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[t];
        return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[r] = n, e;
      }, {});
      function Zl() {
        return "colors" in H.inspectOpts ? !!H.inspectOpts.colors : Yl.isatty(process.stderr.fd);
      }
      function Xl(e) {
        let { namespace: t, useColors: r } = this;
        if (r) {
          let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${t} \x1B[0m`;
          e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + wr.exports.humanize(this.diff) + "\x1B[0m");
        } else
          e[0] = eu() + t + " " + e[0];
      }
      function eu() {
        return H.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function tu(...e) {
        return process.stderr.write(Er.format(...e) + `
`);
      }
      function ru(e) {
        e ? process.env.DEBUG = e : delete process.env.DEBUG;
      }
      function nu() {
        return process.env.DEBUG;
      }
      function iu(e) {
        e.inspectOpts = {};
        let t = Object.keys(H.inspectOpts);
        for (let r = 0; r < t.length; r++)
          e.inspectOpts[t[r]] = H.inspectOpts[t[r]];
      }
      wr.exports = Rn()(H);
      var { formatters: uo } = wr.exports;
      uo.o = function(e) {
        return this.inspectOpts.colors = this.useColors, Er.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
      };
      uo.O = function(e) {
        return this.inspectOpts.colors = this.useColors, Er.inspect(e, this.inspectOpts);
      };
    });
    var po = q((um, kn) => {
      "use strict";
      typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? kn.exports = oo() : kn.exports = co();
    });
    var vo = q((jm, $n) => {
      "use strict";
      var A = $n.exports;
      $n.exports.default = A;
      var I = "\x1B[", St = "\x1B]", st = "\x07", Ar = ";", Po = process.env.TERM_PROGRAM === "Apple_Terminal";
      A.cursorTo = (e, t) => {
        if (typeof e != "number")
          throw new TypeError("The `x` argument is required");
        return typeof t != "number" ? I + (e + 1) + "G" : I + (t + 1) + ";" + (e + 1) + "H";
      };
      A.cursorMove = (e, t) => {
        if (typeof e != "number")
          throw new TypeError("The `x` argument is required");
        let r = "";
        return e < 0 ? r += I + -e + "D" : e > 0 && (r += I + e + "C"), t < 0 ? r += I + -t + "A" : t > 0 && (r += I + t + "B"), r;
      };
      A.cursorUp = (e = 1) => I + e + "A";
      A.cursorDown = (e = 1) => I + e + "B";
      A.cursorForward = (e = 1) => I + e + "C";
      A.cursorBackward = (e = 1) => I + e + "D";
      A.cursorLeft = I + "G";
      A.cursorSavePosition = Po ? "\x1B7" : I + "s";
      A.cursorRestorePosition = Po ? "\x1B8" : I + "u";
      A.cursorGetPosition = I + "6n";
      A.cursorNextLine = I + "E";
      A.cursorPrevLine = I + "F";
      A.cursorHide = I + "?25l";
      A.cursorShow = I + "?25h";
      A.eraseLines = (e) => {
        let t = "";
        for (let r = 0; r < e; r++)
          t += A.eraseLine + (r < e - 1 ? A.cursorUp() : "");
        return e && (t += A.cursorLeft), t;
      };
      A.eraseEndLine = I + "K";
      A.eraseStartLine = I + "1K";
      A.eraseLine = I + "2K";
      A.eraseDown = I + "J";
      A.eraseUp = I + "1J";
      A.eraseScreen = I + "2J";
      A.scrollUp = I + "S";
      A.scrollDown = I + "T";
      A.clearScreen = "\x1Bc";
      A.clearTerminal = process.platform === "win32" ? `${A.eraseScreen}${I}0f` : `${A.eraseScreen}${I}3J${I}H`;
      A.beep = st;
      A.link = (e, t) => [St, "8", Ar, Ar, t, st, e, St, "8", Ar, Ar, st].join("");
      A.image = (e, t = {}) => {
        let r = `${St}1337;File=inline=1`;
        return t.width && (r += `;width=${t.width}`), t.height && (r += `;height=${t.height}`), t.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e.toString("base64") + st;
      };
      A.iTerm = { setCwd: (e = process.cwd()) => `${St}50;CurrentDir=${e}${st}`, annotation: (e, t = {}) => {
        let r = `${St}1337;`, n = typeof t.x < "u", i = typeof t.y < "u";
        if ((n || i) && !(n && i && typeof t.length < "u"))
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        return e = e.replace(/\|/g, ""), r += t.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t.length > 0 ? r += (n ? [e, t.length, t.x, t.y] : [t.length, e]).join("|") : r += e, r + st;
      } };
    });
    var Ao = q((Bm, Co) => {
      "use strict";
      var cu = Fn(), at = Mn();
      function To(e) {
        if (/^\d{3,4}$/.test(e)) {
          let r = /(\d{1,2})(\d{2})/.exec(e);
          return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
        }
        let t = (e || "").split(".").map((r) => parseInt(r, 10));
        return { major: t[0], minor: t[1], patch: t[2] };
      }
      function qn(e) {
        let { env: t } = process;
        if ("FORCE_HYPERLINK" in t)
          return !(t.FORCE_HYPERLINK.length > 0 && parseInt(t.FORCE_HYPERLINK, 10) === 0);
        if (at("no-hyperlink") || at("no-hyperlinks") || at("hyperlink=false") || at("hyperlink=never"))
          return false;
        if (at("hyperlink=true") || at("hyperlink=always") || "NETLIFY" in t)
          return true;
        if (!cu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || "CI" in t || "TEAMCITY_VERSION" in t)
          return false;
        if ("TERM_PROGRAM" in t) {
          let r = To(t.TERM_PROGRAM_VERSION);
          switch (t.TERM_PROGRAM) {
            case "iTerm.app":
              return r.major === 3 ? r.minor >= 1 : r.major > 3;
            case "WezTerm":
              return r.major >= 20200620;
            case "vscode":
              return r.major > 1 || r.major === 1 && r.minor >= 72;
          }
        }
        if ("VTE_VERSION" in t) {
          if (t.VTE_VERSION === "0.50.0")
            return false;
          let r = To(t.VTE_VERSION);
          return r.major > 0 || r.minor >= 50;
        }
        return false;
      }
      Co.exports = { supportsHyperlink: qn, stdout: qn(process.stdout), stderr: qn(process.stderr) };
    });
    var Mo = q((Um, It) => {
      "use strict";
      var pu = vo(), Vn = Ao(), Ro = (e, t, { target: r = "stdout", ...n } = {}) => Vn[r] ? pu.link(e, t) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, t) : `${e} (\u200B${t}\u200B)`;
      It.exports = (e, t, r = {}) => Ro(e, t, r);
      It.exports.stderr = (e, t, r = {}) => Ro(e, t, { target: "stderr", ...r });
      It.exports.isSupported = Vn.stdout;
      It.exports.stderr.isSupported = Vn.stderr;
    });
    var $o = q((lf, Au) => {
      Au.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
    });
    var Vo = q((uf, Fr) => {
      "use strict";
      var Ru = require("fs"), qo = require("path"), Mu = require("os"), Su = $o(), Iu = Su.version, Fu = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function ku(e) {
        let t = {}, r = e.toString();
        r = r.replace(/\r\n?/mg, `
`);
        let n;
        for (; (n = Fu.exec(r)) != null; ) {
          let i = n[1], o = n[2] || "";
          o = o.trim();
          let s = o[0];
          o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), t[i] = o;
        }
        return t;
      }
      function Kn(e) {
        console.log(`[dotenv@${Iu}][DEBUG] ${e}`);
      }
      function Ou(e) {
        return e[0] === "~" ? qo.join(Mu.homedir(), e.slice(1)) : e;
      }
      function Du(e) {
        let t = qo.resolve(process.cwd(), ".env"), r = "utf8", n = !!(e && e.debug), i = !!(e && e.override);
        e && (e.path != null && (t = Ou(e.path)), e.encoding != null && (r = e.encoding));
        try {
          let o = Ir.parse(Ru.readFileSync(t, { encoding: r }));
          return Object.keys(o).forEach(function(s) {
            Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && Kn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
          }), { parsed: o };
        } catch (o) {
          return n && Kn(`Failed to load ${t} ${o.message}`), { error: o };
        }
      }
      var Ir = { config: Du, parse: ku };
      Fr.exports.config = Ir.config;
      Fr.exports.parse = Ir.parse;
      Fr.exports = Ir;
    });
    var Jo = q((yf, Qo) => {
      "use strict";
      Qo.exports = (e) => {
        let t = e.match(/^[ \t]*(?=\S)/gm);
        return t ? t.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
      };
    });
    var Ho = q((hf, Go) => {
      "use strict";
      var $u = Jo();
      Go.exports = (e) => {
        let t = $u(e);
        if (t === 0)
          return e;
        let r = new RegExp(`^[ \\t]{${t}}`, "gm");
        return e.replace(r, "");
      };
    });
    var Wo = q((xf, qu) => {
      qu.exports = { name: "@prisma/engines-version", version: "5.3.1-2.61e140623197a131c2a6189271ffee05a7aa9a59", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "61e140623197a131c2a6189271ffee05a7aa9a59" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.17.15", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var Hn = q((Or) => {
      "use strict";
      Object.defineProperty(Or, "__esModule", { value: true });
      Or.enginesVersion = void 0;
      Or.enginesVersion = Wo().prisma.enginesVersion;
    });
    var Xn = q((Ff, Zo) => {
      "use strict";
      Zo.exports = (e, t = 1, r) => {
        if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
        if (typeof t != "number")
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);
        if (typeof r.indent != "string")
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
        if (t === 0)
          return e;
        let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e.replace(n, r.indent.repeat(t));
      };
    });
    var rs = q((Df, ts) => {
      "use strict";
      ts.exports = ({ onlyFirst: e = false } = {}) => {
        let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t, e ? void 0 : "g");
      };
    });
    var ni = q((_f, ns) => {
      "use strict";
      var Wu = rs();
      ns.exports = (e) => typeof e == "string" ? e.replace(Wu(), "") : e;
    });
    var is = q((Lf, Dr) => {
      "use strict";
      Dr.exports = (e = {}) => {
        let t;
        if (e.repoUrl)
          t = e.repoUrl;
        else if (e.user && e.repo)
          t = `https://github.com/${e.user}/${e.repo}`;
        else
          throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let r = new URL(`${t}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let i of n) {
          let o = e[i];
          if (o !== void 0) {
            if (i === "labels" || i === "projects") {
              if (!Array.isArray(o))
                throw new TypeError(`The \`${i}\` option should be an array`);
              o = o.join(",");
            }
            r.searchParams.set(i, o);
          }
        }
        return r.toString();
      };
      Dr.exports.default = Dr.exports;
    });
    var $i = q((iP, La) => {
      "use strict";
      La.exports = function() {
        function e(t, r, n, i, o) {
          return t < r || n < r ? t > n ? n + 1 : t + 1 : i === o ? r : r + 1;
        }
        return function(t, r) {
          if (t === r)
            return 0;
          if (t.length > r.length) {
            var n = t;
            t = r, r = n;
          }
          for (var i = t.length, o = r.length; i > 0 && t.charCodeAt(i - 1) === r.charCodeAt(o - 1); )
            i--, o--;
          for (var s = 0; s < i && t.charCodeAt(s) === r.charCodeAt(s); )
            s++;
          if (i -= s, o -= s, i === 0 || o < 3)
            return o;
          var a = 0, l, u, c, p, d, f, y, g, P, T, C, x, R = [];
          for (l = 0; l < i; l++)
            R.push(l + 1), R.push(t.charCodeAt(s + l));
          for (var ce = R.length - 1; a < o - 3; )
            for (P = r.charCodeAt(s + (u = a)), T = r.charCodeAt(s + (c = a + 1)), C = r.charCodeAt(s + (p = a + 2)), x = r.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0; l < ce; l += 2)
              y = R[l], g = R[l + 1], u = e(y, u, c, P, g), c = e(u, c, p, T, g), p = e(c, p, d, C, g), f = e(p, d, f, x, g), R[l] = f, d = p, p = c, c = u, u = y;
          for (; a < o; )
            for (P = r.charCodeAt(s + (u = a)), f = ++a, l = 0; l < ce; l += 2)
              y = R[l], R[l] = f = e(y, u, f, P, R[l + 1]), u = y;
          return f;
        };
      }();
    });
    var Gd = {};
    Rt(Gd, { DMMF: () => pe, DMMFClass: () => hr, Debug: () => On, Decimal: () => we, Extensions: () => vn, MetricsClient: () => pt, NotFoundError: () => Ce, PrismaClientInitializationError: () => k, PrismaClientKnownRequestError: () => U, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => K, PrismaClientValidationError: () => X, Public: () => Tn, Sql: () => oe, Types: () => Cn, defineDmmfProperty: () => as, empty: () => us, getPrismaClient: () => Ml, join: () => ls, makeStrictEnum: () => Sl, objectEnumValues: () => $r, raw: () => li, sqltag: () => ui, warnEnvConflicts: () => Il, warnOnce: () => Lt });
    module.exports = Nl(Gd);
    var vn = {};
    Rt(vn, { defineExtension: () => Hi, getExtensionContext: () => Wi });
    function Hi(e) {
      return typeof e == "function" ? e : (t) => t.$extends(e);
    }
    function Wi(e) {
      return e;
    }
    var Tn = {};
    Rt(Tn, { validator: () => zi });
    function zi(...e) {
      return (t) => t;
    }
    var Cn = {};
    Rt(Cn, { Extensions: () => Yi, Public: () => Zi, Result: () => Xi, Utils: () => eo });
    var Yi = {};
    var Zi = {};
    var Xi = {};
    var eo = {};
    var Ie = (e, t) => {
      let r = {};
      for (let n of e) {
        let i = n[t];
        r[i] = n;
      }
      return r;
    };
    function to(e) {
      return e.substring(0, 1).toLowerCase() + e.substring(1);
    }
    var hr = class {
      constructor(t) {
        this.document = t;
        this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
      }
      get datamodel() {
        return this.document.datamodel;
      }
      get mappings() {
        return this.document.mappings;
      }
      get schema() {
        return this.document.schema;
      }
      get inputObjectTypes() {
        return this.schema.inputObjectTypes;
      }
      get outputObjectTypes() {
        return this.schema.outputObjectTypes;
      }
      isComposite(t) {
        return this.compositeNames.has(t);
      }
      getOtherOperationNames() {
        return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
      }
      hasEnumInNamespace(t, r) {
        return this.schema.enumTypes[r]?.find((n) => n.name === t) !== void 0;
      }
      resolveInputObjectType(t) {
        return this.inputTypesByName.get(An(t.type, t.namespace));
      }
      resolveOutputObjectType(t) {
        if (t.location === "outputObjectTypes")
          return this.outputObjectTypes[t.namespace ?? "prisma"].find((r) => r.name === t.type);
      }
      buildModelMap() {
        return Ie(this.datamodel.models, "name");
      }
      buildTypeMap() {
        return Ie(this.datamodel.types, "name");
      }
      buildTypeModelMap() {
        return { ...this.buildTypeMap(), ...this.buildModelMap() };
      }
      buildMappingsMap() {
        return Ie(this.mappings.modelOperations, "model");
      }
      buildMergedOutputTypeMap() {
        return { model: Ie(this.schema.outputObjectTypes.model, "name"), prisma: Ie(this.schema.outputObjectTypes.prisma, "name") };
      }
      buildRootFieldMap() {
        return { ...Ie(this.outputTypeMap.prisma.Query.fields, "name"), ...Ie(this.outputTypeMap.prisma.Mutation.fields, "name") };
      }
      buildInputTypesMap() {
        let t = /* @__PURE__ */ new Map();
        for (let r of this.inputObjectTypes.prisma)
          t.set(An(r.name, "prisma"), r);
        if (!this.inputObjectTypes.model)
          return t;
        for (let r of this.inputObjectTypes.model)
          t.set(An(r.name, "model"), r);
        return t;
      }
    };
    function An(e, t) {
      return t ? `${t}.${e}` : e;
    }
    var pe;
    ((t) => {
      let e;
      ((x) => (x.findUnique = "findUnique", x.findUniqueOrThrow = "findUniqueOrThrow", x.findFirst = "findFirst", x.findFirstOrThrow = "findFirstOrThrow", x.findMany = "findMany", x.create = "create", x.createMany = "createMany", x.update = "update", x.updateMany = "updateMany", x.upsert = "upsert", x.delete = "delete", x.deleteMany = "deleteMany", x.groupBy = "groupBy", x.count = "count", x.aggregate = "aggregate", x.findRaw = "findRaw", x.aggregateRaw = "aggregateRaw"))(e = t.ModelAction || (t.ModelAction = {}));
    })(pe || (pe = {}));
    var Pr = S(po());
    var ou = 100;
    var Mt = [];
    typeof process < "u" && typeof process.stderr?.write != "function" && (Pr.default.log = console.debug ?? console.log);
    function su(e) {
      let t = (0, Pr.default)(e), r = Object.assign((...n) => (t.log = r.log, n.length !== 0 && Mt.push([e, ...n]), Mt.length > ou && Mt.shift(), t("", ...n)), t);
      return r;
    }
    var On = Object.assign(su, Pr.default);
    function mo(e = 7500) {
      let t = Mt.map((r) => r.map((n) => typeof n == "string" ? n : JSON.stringify(n)).join(" ")).join(`
`);
      return t.length < e ? t : t.slice(-e);
    }
    function fo() {
      Mt.length = 0;
    }
    var D = On;
    var Dn;
    var go;
    var yo;
    var ho;
    var xo = true;
    typeof process < "u" && ({ FORCE_COLOR: Dn, NODE_DISABLE_COLORS: go, NO_COLOR: yo, TERM: ho } = process.env || {}, xo = process.stdout && process.stdout.isTTY);
    var au = { enabled: !go && yo == null && ho !== "dumb" && (Dn != null && Dn !== "0" || xo) };
    function _(e, t) {
      let r = new RegExp(`\\x1b\\[${t}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${t}m`;
      return function(o) {
        return !au.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(r, i + n) : o) + i;
      };
    }
    var pm = _(0, 0);
    var ne = _(1, 22);
    var ke = _(2, 22);
    var dm = _(3, 23);
    var te = _(4, 24);
    var mm = _(7, 27);
    var fm = _(8, 28);
    var gm = _(9, 29);
    var ym = _(30, 39);
    var me = _(31, 39);
    var Qe = _(32, 39);
    var he = _(33, 39);
    var it = _(34, 39);
    var hm = _(35, 39);
    var Oe = _(36, 39);
    var xm = _(37, 39);
    var vr = _(90, 39);
    var bm = _(90, 39);
    var Em = _(40, 49);
    var wm = _(41, 49);
    var Pm = _(42, 49);
    var vm = _(43, 49);
    var Tm = _(44, 49);
    var Cm = _(45, 49);
    var Am = _(46, 49);
    var Rm = _(47, 49);
    var bo = S(require("fs"));
    function _n() {
      let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      if (!(e && bo.default.existsSync(e)) && process.arch === "ia32")
        throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
    }
    var Tr = "libquery_engine";
    function Nn(e, t) {
      let r = t === "url";
      return e.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r ? `${Tr}.dylib.node` : `${Tr}-${e}.dylib.node` : r ? `${Tr}.so.node` : `${Tr}-${e}.so.node`;
    }
    var ko = S(require("child_process"));
    var jn = S(require("fs/promises"));
    var Mr = S(require("os"));
    var Cr = Symbol("@ts-pattern/matcher");
    var Eo = "@ts-pattern/anonymous-select-key";
    var wo = function(e) {
      return !!(e && typeof e == "object");
    };
    var Ln = function(e) {
      return e && !!e[Cr];
    };
    var lu = function e(t, r, n) {
      if (wo(t)) {
        if (Ln(t)) {
          var i = t[Cr]().match(r), o = i.matched, s = i.selections;
          return o && s && Object.keys(s).forEach(function(l) {
            return n(l, s[l]);
          }), o;
        }
        if (!wo(r))
          return false;
        if (Array.isArray(t))
          return !!Array.isArray(r) && t.length === r.length && t.every(function(l, u) {
            return e(l, r[u], n);
          });
        if (t instanceof Map)
          return r instanceof Map && Array.from(t.keys()).every(function(l) {
            return e(t.get(l), r.get(l), n);
          });
        if (t instanceof Set) {
          if (!(r instanceof Set))
            return false;
          if (t.size === 0)
            return r.size === 0;
          if (t.size === 1) {
            var a = Array.from(t.values())[0];
            return Ln(a) ? Array.from(r.values()).every(function(l) {
              return e(a, l, n);
            }) : r.has(a);
          }
          return Array.from(t.values()).every(function(l) {
            return r.has(l);
          });
        }
        return Object.keys(t).every(function(l) {
          var u, c = t[l];
          return (l in r || Ln(u = c) && u[Cr]().matcherType === "optional") && e(c, r[l], n);
        });
      }
      return Object.is(r, t);
    };
    function Je(e) {
      var t;
      return (t = {})[Cr] = function() {
        return { match: function(r) {
          return { matched: !!e(r) };
        } };
      }, t;
    }
    var Om = Je(function(e) {
      return true;
    });
    var Dm = Je(function(e) {
      return typeof e == "string";
    });
    var _m = Je(function(e) {
      return typeof e == "number";
    });
    var Nm = Je(function(e) {
      return typeof e == "boolean";
    });
    var Lm = Je(function(e) {
      return typeof e == "bigint";
    });
    var $m = Je(function(e) {
      return typeof e == "symbol";
    });
    var qm = Je(function(e) {
      return e == null;
    });
    function ot(e) {
      return new uu(e, []);
    }
    var uu = function() {
      function e(r, n) {
        this.value = void 0, this.cases = void 0, this.value = r, this.cases = n;
      }
      var t = e.prototype;
      return t.with = function() {
        var r = [].slice.call(arguments), n = r[r.length - 1], i = [r[0]], o = [];
        return r.length === 3 && typeof r[1] == "function" ? (i.push(r[0]), o.push(r[1])) : r.length > 2 && i.push.apply(i, r.slice(1, r.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
          var a = {}, l = !!(i.some(function(u) {
            return lu(u, s, function(c, p) {
              a[c] = p;
            });
          }) && o.every(function(u) {
            return u(s);
          }));
          return { matched: l, value: l && Object.keys(a).length ? Eo in a ? a[Eo] : a : s };
        }, handler: n }]));
      }, t.when = function(r, n) {
        return new e(this.value, this.cases.concat([{ match: function(i) {
          return { matched: !!r(i), value: i };
        }, handler: n }]));
      }, t.otherwise = function(r) {
        return new e(this.value, this.cases.concat([{ match: function(n) {
          return { matched: true, value: n };
        }, handler: r }])).run();
      }, t.exhaustive = function() {
        return this.run();
      }, t.run = function() {
        for (var r = this.value, n = void 0, i = 0; i < this.cases.length; i++) {
          var o = this.cases[i], s = o.match(this.value);
          if (s.matched) {
            r = s.value, n = o.handler;
            break;
          }
        }
        if (!n) {
          var a;
          try {
            a = JSON.stringify(this.value);
          } catch {
            a = this.value;
          }
          throw new Error("Pattern matching error: no pattern matches value " + a);
        }
        return n(r, this.value);
      }, e;
    }();
    var Oo = require("util");
    var So = S(Mo());
    function Ft(e) {
      return (0, So.default)(e, e, { fallback: te });
    }
    var du = { warn: he("prisma:warn") };
    var mu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function kt(e, ...t) {
      mu.warn() && console.warn(`${du.warn} ${e}`, ...t);
    }
    var fu = (0, Oo.promisify)(ko.default.exec);
    var ie = D("prisma:get-platform");
    var gu = ["1.0.x", "1.1.x", "3.0.x"];
    async function Do() {
      let e = Mr.default.platform(), t = process.arch;
      if (e === "freebsd") {
        let s = await Sr("freebsd-version");
        if (s && s.trim().length > 0) {
          let l = /^(\d+)\.?/.exec(s);
          if (l)
            return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: t };
        }
      }
      if (e !== "linux")
        return { platform: e, arch: t };
      let r = await hu(), n = await Cu(), i = bu({ arch: t, archFromUname: n, familyDistro: r.familyDistro }), { libssl: o } = await Eu(i);
      return { platform: "linux", libssl: o, arch: t, archFromUname: n, ...r };
    }
    function yu(e) {
      let t = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n = t.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = r.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = ot({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: void 0, familyDistro: void 0, originalDistro: l }));
      return ie(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
    }
    async function hu() {
      let e = "/etc/os-release";
      try {
        let t = await jn.default.readFile(e, { encoding: "utf-8" });
        return yu(t);
      } catch {
        return { targetDistro: void 0, familyDistro: void 0, originalDistro: void 0 };
      }
    }
    function xu(e) {
      let t = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
      if (t) {
        let r = `${t[1]}.x`;
        return _o(r);
      }
    }
    function Io(e) {
      let t = /libssl\.so\.(\d)(\.\d)?/.exec(e);
      if (t) {
        let r = `${t[1]}${t[2] ?? ".0"}.x`;
        return _o(r);
      }
    }
    function _o(e) {
      let t = (() => {
        if (Lo(e))
          return e;
        let r = e.split(".");
        return r[1] = "0", r.join(".");
      })();
      if (gu.includes(t))
        return t;
    }
    function bu(e) {
      return ot(e).with({ familyDistro: "musl" }, () => (ie('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t }) => (ie('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t}-linux-gnu`, `/lib/${t}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ie('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t, arch: r, archFromUname: n }) => (ie(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`), []));
    }
    async function Eu(e) {
      let t = 'grep -v "libssl.so.0"', r = await Fo(e);
      if (r) {
        ie(`Found libssl.so file using platform-specific paths: ${r}`);
        let o = Io(r);
        if (ie(`The parsed libssl version is: ${o}`), o)
          return { libssl: o, strategy: "libssl-specific-path" };
      }
      ie('Falling back to "ldconfig" and other generic paths');
      let n = await Sr(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);
      if (n || (n = await Fo(["/lib64", "/usr/lib64", "/lib"])), n) {
        ie(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
        let o = Io(n);
        if (ie(`The parsed libssl version is: ${o}`), o)
          return { libssl: o, strategy: "ldconfig" };
      }
      let i = await Sr("openssl version -v");
      if (i) {
        ie(`Found openssl binary with version: ${i}`);
        let o = xu(i);
        if (ie(`The parsed openssl version is: ${o}`), o)
          return { libssl: o, strategy: "openssl-binary" };
      }
      return ie("Couldn't find any version of libssl or OpenSSL in the system"), {};
    }
    async function Fo(e) {
      for (let t of e) {
        let r = await wu(t);
        if (r)
          return r;
      }
    }
    async function wu(e) {
      try {
        return (await jn.default.readdir(e)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
      } catch (t) {
        if (t.code === "ENOENT")
          return;
        throw t;
      }
    }
    async function lt() {
      let { binaryTarget: e } = await No();
      return e;
    }
    function Pu(e) {
      return e.binaryTarget !== void 0;
    }
    async function Bn() {
      let { memoized: e, ...t } = await No();
      return t;
    }
    var Rr = {};
    async function No() {
      if (Pu(Rr))
        return Promise.resolve({ ...Rr, memoized: true });
      let e = await Do(), t = vu(e);
      return Rr = { ...e, binaryTarget: t }, { ...Rr, memoized: false };
    }
    function vu(e) {
      let { platform: t, arch: r, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
      t === "linux" && !["x64", "arm64"].includes(r) && kt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
      let l = "1.1.x";
      if (t === "linux" && i === void 0) {
        let c = ot({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
        kt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
      }
      let u = "debian";
      if (t === "linux" && o === void 0 && kt(`Prisma doesn't know which engines to download for the Linux distro "${a}". Falling back to Prisma engines built "${u}".
Please report your experience by creating an issue at ${Ft("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t === "darwin" && r === "arm64")
        return "darwin-arm64";
      if (t === "darwin")
        return "darwin";
      if (t === "win32")
        return "windows";
      if (t === "freebsd")
        return o;
      if (t === "openbsd")
        return "openbsd";
      if (t === "netbsd")
        return "netbsd";
      if (t === "linux" && o === "nixos")
        return "linux-nixos";
      if (t === "linux" && r === "arm64")
        return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
      if (t === "linux" && r === "arm")
        return `linux-arm-openssl-${i || l}`;
      if (t === "linux" && o === "musl") {
        let c = "linux-musl";
        return !i || Lo(i) ? c : `${c}-openssl-${i}`;
      }
      return t === "linux" && o && i ? `${o}-openssl-${i}` : (t !== "linux" && kt(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
    }
    async function Tu(e) {
      try {
        return await e();
      } catch {
        return;
      }
    }
    function Sr(e) {
      return Tu(async () => {
        let t = await fu(e);
        return ie(`Command "${e}" successfully returned "${t.stdout}"`), t.stdout;
      });
    }
    async function Cu() {
      return typeof Mr.default.machine == "function" ? Mr.default.machine() : (await Sr("uname -m"))?.trim();
    }
    function Lo(e) {
      return e.startsWith("1.");
    }
    var Un = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "openbsd", "netbsd", "arm"];
    var Jn = S(Vo());
    var kr = S(require("fs"));
    var ut = S(require("path"));
    function jo(e) {
      let t = e.ignoreProcessEnv ? {} : process.env, r = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
        let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
        if (!a)
          return o;
        let l = a[1], u, c;
        if (l === "\\")
          c = a[0], u = c.replace("\\$", "$");
        else {
          let p = a[2];
          c = a[0].substring(l.length), u = Object.hasOwnProperty.call(t, p) ? t[p] : e.parsed[p] || "", u = r(u);
        }
        return o.replace(c, u);
      }, n) ?? n;
      for (let n in e.parsed) {
        let i = Object.hasOwnProperty.call(t, n) ? t[n] : e.parsed[n];
        e.parsed[n] = r(i);
      }
      for (let n in e.parsed)
        t[n] = e.parsed[n];
      return e;
    }
    var Qn = D("prisma:tryLoadEnv");
    function Ot({ rootEnvPath: e, schemaEnvPath: t }, r = { conflictCheck: "none" }) {
      let n = Bo(e);
      r.conflictCheck !== "none" && _u(n, t, r.conflictCheck);
      let i = null;
      return Uo(n?.path, t) || (i = Bo(t)), !n && !i && Qn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(me(ne("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
    }
    function _u(e, t, r) {
      let n = e?.dotenvResult.parsed, i = !Uo(e?.path, t);
      if (n && t && i && kr.default.existsSync(t)) {
        let o = Jn.default.parse(kr.default.readFileSync(t)), s = [];
        for (let a in o)
          n[a] === o[a] && s.push(a);
        if (s.length > 0) {
          let a = ut.default.relative(process.cwd(), e.path), l = ut.default.relative(process.cwd(), t);
          if (r === "error") {
            let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${te(a)} and ${te(l)}
Conflicting env vars:
${s.map((c) => `  ${ne(c)}`).join(`
`)}

We suggest to move the contents of ${te(l)} to ${te(a)} to consolidate your env vars.
`;
            throw new Error(u);
          } else if (r === "warn") {
            let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => ne(c)).join(", ")} in ${te(a)} and ${te(l)}
Env vars from ${te(l)} overwrite the ones from ${te(a)}
      `;
            console.warn(`${he("warn(prisma)")} ${u}`);
          }
        }
      }
    }
    function Bo(e) {
      return Nu(e) ? (Qn(`Environment variables loaded from ${e}`), { dotenvResult: jo(Jn.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0 })), message: ke(`Environment variables loaded from ${ut.default.relative(process.cwd(), e)}`), path: e }) : (Qn(`Environment variables not found at ${e}`), null);
    }
    function Uo(e, t) {
      return e && t && ut.default.resolve(e) === ut.default.resolve(t);
    }
    function Nu(e) {
      return !!(e && kr.default.existsSync(e));
    }
    var Ko = "library";
    function Gn(e) {
      let t = Lu();
      return t || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : Ko);
    }
    function Lu() {
      let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e === "library" ? "library" : e === "binary" ? "binary" : void 0;
    }
    var Vu = S(Hn());
    var N = S(require("path"));
    var ju = S(Hn());
    var wf = D("prisma:engines");
    function zo() {
      return N.default.join(__dirname, "../");
    }
    var Pf = "libquery-engine";
    N.default.join(__dirname, "../query-engine-darwin");
    N.default.join(__dirname, "../query-engine-darwin-arm64");
    N.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    N.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    N.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    N.default.join(__dirname, "../query-engine-linux-static-x64");
    N.default.join(__dirname, "../query-engine-linux-static-arm64");
    N.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    N.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    N.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    N.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    N.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    N.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    N.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    N.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    N.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    N.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    N.default.join(__dirname, "../query_engine-windows.dll.node");
    var Wn = S(require("fs"));
    var Yo = D("chmodPlusX");
    function zn(e) {
      if (process.platform === "win32")
        return;
      let t = Wn.default.statSync(e), r = t.mode | 64 | 8 | 1;
      if (t.mode === r) {
        Yo(`Execution permissions of ${e} are fine`);
        return;
      }
      let n = r.toString(8).slice(-3);
      Yo(`Have to call chmodPlusX on ${e}`), Wn.default.chmodSync(e, n);
    }
    function Yn(e) {
      let t = e.e, r = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = t.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Ft("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${ke(e.id)}\`).`, s = ot({ message: t.message, code: t.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
        let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
        return `${r("libssl")}. Please install ${a} and try again.`;
      }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
      return `${o}
${s}

Details: ${t.message}`;
    }
    var Dt = S(require("path"));
    function Zn(e) {
      return Dt.default.sep === Dt.default.posix.sep ? e : e.split(Dt.default.sep).join(Dt.default.posix.sep);
    }
    var Xo = S(Xn());
    function ti(e) {
      return String(new ei(e));
    }
    var ei = class {
      constructor(t) {
        this.config = t;
      }
      toString() {
        let { config: t } = this, r = t.provider.fromEnvVar ? `env("${t.provider.fromEnvVar}")` : t.provider.value, n = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Bu(t.binaryTargets) }));
        return `generator ${t.name} {
${(0, Xo.default)(Uu(n), 2)}
}`;
      }
    };
    function Bu(e) {
      let t;
      if (e.length > 0) {
        let r = e.find((n) => n.fromEnvVar !== null);
        r ? t = `env("${r.fromEnvVar}")` : t = e.map((n) => n.native ? "native" : n.value);
      } else
        t = void 0;
      return t;
    }
    function Uu(e) {
      let t = Object.keys(e).reduce((r, n) => Math.max(r, n.length), 0);
      return Object.entries(e).map(([r, n]) => `${r.padEnd(t)} = ${Ku(n)}`).join(`
`);
    }
    function Ku(e) {
      return JSON.parse(JSON.stringify(e, (t, r) => Array.isArray(r) ? `[${r.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(r)));
    }
    var Nt = {};
    Rt(Nt, { error: () => Gu, info: () => Ju, log: () => Qu, query: () => Hu, should: () => es, tags: () => _t, warn: () => ri });
    var _t = { error: me("prisma:error"), warn: he("prisma:warn"), info: Oe("prisma:info"), query: it("prisma:query") };
    var es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
    function Qu(...e) {
      console.log(...e);
    }
    function ri(e, ...t) {
      es.warn() && console.warn(`${_t.warn} ${e}`, ...t);
    }
    function Ju(e, ...t) {
      console.info(`${_t.info} ${e}`, ...t);
    }
    function Gu(e, ...t) {
      console.error(`${_t.error} ${e}`, ...t);
    }
    function Hu(e, ...t) {
      console.log(`${_t.query} ${e}`, ...t);
    }
    function Ge(e, t) {
      throw new Error(t);
    }
    function ii(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }
    var oi = (e, t) => e.reduce((r, n) => (r[t(n)] = n, r), {});
    function ct(e, t) {
      let r = {};
      for (let n of Object.keys(e))
        r[n] = t(e[n], n);
      return r;
    }
    function si(e, t) {
      if (e.length === 0)
        return;
      let r = e[0];
      for (let n = 1; n < e.length; n++)
        t(r, e[n]) < 0 && (r = e[n]);
      return r;
    }
    function E(e, t) {
      Object.defineProperty(e, "name", { value: t, configurable: true });
    }
    var os = /* @__PURE__ */ new Set();
    var Lt = (e, t, ...r) => {
      os.has(e) || (os.add(e), ri(t, ...r));
    };
    var U = class extends Error {
      constructor(r, { code: n, clientVersion: i, meta: o, batchRequestIdx: s }) {
        super(r);
        this.name = "PrismaClientKnownRequestError", this.code = n, this.clientVersion = i, this.meta = o, Object.defineProperty(this, "batchRequestIdx", { value: s, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    E(U, "PrismaClientKnownRequestError");
    var Ce = class extends U {
      constructor(t, r) {
        super(t, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
      }
    };
    E(Ce, "NotFoundError");
    var k = class e extends Error {
      constructor(r, n, i) {
        super(r);
        this.name = "PrismaClientInitializationError", this.clientVersion = n, this.errorCode = i, Error.captureStackTrace(e);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    E(k, "PrismaClientInitializationError");
    var ue = class extends Error {
      constructor(r, n) {
        super(r);
        this.name = "PrismaClientRustPanicError", this.clientVersion = n;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    E(ue, "PrismaClientRustPanicError");
    var K = class extends Error {
      constructor(r, { clientVersion: n, batchRequestIdx: i }) {
        super(r);
        this.name = "PrismaClientUnknownRequestError", this.clientVersion = n, Object.defineProperty(this, "batchRequestIdx", { value: i, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    E(K, "PrismaClientUnknownRequestError");
    var X = class extends Error {
      constructor(r, { clientVersion: n }) {
        super(r);
        this.name = "PrismaClientValidationError";
        this.clientVersion = n;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    E(X, "PrismaClientValidationError");
    var pt = class {
      constructor(t) {
        this._engine = t;
      }
      prometheus(t) {
        return this._engine.metrics({ format: "prometheus", ...t });
      }
      json(t) {
        return this._engine.metrics({ format: "json", ...t });
      }
    };
    function $t(e) {
      let t;
      return { get() {
        return t || (t = { value: e() }), t.value;
      } };
    }
    function as(e, t) {
      let r = $t(() => zu(t));
      Object.defineProperty(e, "dmmf", { get: () => r.get() });
    }
    function zu(e) {
      return { datamodel: { models: ai(e.models), enums: ai(e.enums), types: ai(e.types) } };
    }
    function ai(e) {
      return Object.entries(e).map(([t, r]) => ({ name: t, ...r }));
    }
    var Cl = require("async_hooks");
    var Al = require("events");
    var Rl = S(require("fs"));
    var fr = S(require("path"));
    var oe = class e {
      constructor(t, r) {
        if (t.length - 1 !== r.length)
          throw t.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t.length} strings to have ${t.length - 1} values`);
        let n = r.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
        this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = t[0];
        let i = 0, o = 0;
        for (; i < r.length; ) {
          let s = r[i++], a = t[i];
          if (s instanceof e) {
            this.strings[o] += s.strings[0];
            let l = 0;
            for (; l < s.values.length; )
              this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
            this.strings[o] += a;
          } else
            this.values[o++] = s, this.strings[o] = a;
        }
      }
      get text() {
        let t = 1, r = this.strings[0];
        for (; t < this.strings.length; )
          r += `$${t}${this.strings[t++]}`;
        return r;
      }
      get sql() {
        let t = 1, r = this.strings[0];
        for (; t < this.strings.length; )
          r += `?${this.strings[t++]}`;
        return r;
      }
      inspect() {
        return { text: this.text, sql: this.sql, values: this.values };
      }
    };
    function ls(e, t = ",", r = "", n = "") {
      if (e.length === 0)
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new oe([r, ...Array(e.length - 1).fill(t), n], e);
    }
    function li(e) {
      return new oe([e], []);
    }
    var us = li("");
    function ui(e, ...t) {
      return new oe(e, t);
    }
    function qt(e) {
      return { getKeys() {
        return Object.keys(e);
      }, getPropertyValue(t) {
        return e[t];
      } };
    }
    function re(e, t) {
      return { getKeys() {
        return [e];
      }, getPropertyValue() {
        return t();
      } };
    }
    var xe = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get(t) {
        return this._map.get(t)?.value;
      }
      set(t, r) {
        this._map.set(t, { value: r });
      }
      getOrCreate(t, r) {
        let n = this._map.get(t);
        if (n)
          return n.value;
        let i = r();
        return this.set(t, i), i;
      }
    };
    function He(e) {
      let t = new xe();
      return { getKeys() {
        return e.getKeys();
      }, getPropertyValue(r) {
        return t.getOrCreate(r, () => e.getPropertyValue(r));
      }, getPropertyDescriptor(r) {
        return e.getPropertyDescriptor?.(r);
      } };
    }
    var ds = require("util");
    var _r = { enumerable: true, configurable: true, writable: true };
    function Nr(e) {
      let t = new Set(e);
      return { getOwnPropertyDescriptor: () => _r, has: (r, n) => t.has(n), set: (r, n, i) => t.add(n) && Reflect.set(r, n, i), ownKeys: () => [...t] };
    }
    var cs = Symbol.for("nodejs.util.inspect.custom");
    function be(e, t) {
      let r = Yu(t), n = /* @__PURE__ */ new Set(), i = new Proxy(e, { get(o, s) {
        if (n.has(s))
          return o[s];
        let a = r.get(s);
        return a ? a.getPropertyValue(s) : o[s];
      }, has(o, s) {
        if (n.has(s))
          return true;
        let a = r.get(s);
        return a ? a.has?.(s) ?? true : Reflect.has(o, s);
      }, ownKeys(o) {
        let s = ps(Reflect.ownKeys(o), r), a = ps(Array.from(r.keys()), r);
        return [.../* @__PURE__ */ new Set([...s, ...a, ...n])];
      }, set(o, s, a) {
        return r.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
      }, getOwnPropertyDescriptor(o, s) {
        let a = Reflect.getOwnPropertyDescriptor(o, s);
        if (a && !a.configurable)
          return a;
        let l = r.get(s);
        return l ? l.getPropertyDescriptor ? { ..._r, ...l?.getPropertyDescriptor(s) } : _r : a;
      }, defineProperty(o, s, a) {
        return n.add(s), Reflect.defineProperty(o, s, a);
      } });
      return i[cs] = function(o, s, a = ds.inspect) {
        let l = { ...this };
        return delete l[cs], a(l, s);
      }, i;
    }
    function Yu(e) {
      let t = /* @__PURE__ */ new Map();
      for (let r of e) {
        let n = r.getKeys();
        for (let i of n)
          t.set(i, r);
      }
      return t;
    }
    function ps(e, t) {
      return e.filter((r) => t.get(r)?.has?.(r) ?? true);
    }
    function Vt(e) {
      return { getKeys() {
        return e;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    var dt = class {
      constructor(t = 0, r) {
        this.context = r;
        this.lines = [];
        this.currentLine = "";
        this.currentIndent = 0;
        this.currentIndent = t;
      }
      write(t) {
        return typeof t == "string" ? this.currentLine += t : t.write(this), this;
      }
      writeJoined(t, r) {
        let n = r.length - 1;
        for (let i = 0; i < r.length; i++)
          this.write(r[i]), i !== n && this.write(t);
        return this;
      }
      writeLine(t) {
        return this.write(t).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let t = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, t?.(), this;
      }
      withIndent(t) {
        return this.indent(), t(this), this.unindent(), this;
      }
      afterNextNewline(t) {
        return this.afterNextNewLineCallback = t, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(t) {
        return this.marginSymbol = t, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let t = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + t.slice(1) : t;
      }
    };
    var Lr = Symbol();
    var ci = /* @__PURE__ */ new WeakMap();
    var Ae = class {
      constructor(t) {
        t === Lr ? ci.set(this, `Prisma.${this._getName()}`) : ci.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return ci.get(this);
      }
    };
    var jt = class extends Ae {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var Bt = class extends jt {
    };
    pi(Bt, "DbNull");
    var Ut = class extends jt {
    };
    pi(Ut, "JsonNull");
    var Kt = class extends jt {
    };
    pi(Kt, "AnyNull");
    var $r = { classes: { DbNull: Bt, JsonNull: Ut, AnyNull: Kt }, instances: { DbNull: new Bt(Lr), JsonNull: new Ut(Lr), AnyNull: new Kt(Lr) } };
    function pi(e, t) {
      Object.defineProperty(e, "name", { value: t, configurable: true });
    }
    function mt(e) {
      return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
    }
    function qr(e) {
      return e.toString() !== "Invalid Date";
    }
    var ft = 9e15;
    var Le = 1e9;
    var di = "0123456789abcdef";
    var jr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var Br = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var mi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -ft, maxE: ft, crypto: false };
    var ys;
    var Re;
    var w = true;
    var Kr = "[DecimalError] ";
    var Ne = Kr + "Invalid argument: ";
    var hs = Kr + "Precision limit exceeded";
    var xs = Kr + "crypto unavailable";
    var bs = "[object Decimal]";
    var ee = Math.floor;
    var j = Math.pow;
    var Zu = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var Xu = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var ec = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var Es = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var ge = 1e7;
    var b = 7;
    var tc = 9007199254740991;
    var rc = jr.length - 1;
    var fi = Br.length - 1;
    var m = { toStringTag: bs };
    m.absoluteValue = m.abs = function() {
      var e = new this.constructor(this);
      return e.s < 0 && (e.s = 1), h(e);
    };
    m.ceil = function() {
      return h(new this.constructor(this), this.e + 1, 2);
    };
    m.clampedTo = m.clamp = function(e, t) {
      var r, n = this, i = n.constructor;
      if (e = new i(e), t = new i(t), !e.s || !t.s)
        return new i(NaN);
      if (e.gt(t))
        throw Error(Ne + t);
      return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
    };
    m.comparedTo = m.cmp = function(e) {
      var t, r, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
      if (!s || !a)
        return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
      if (!s[0] || !a[0])
        return s[0] ? l : a[0] ? -u : 0;
      if (l !== u)
        return l;
      if (o.e !== e.e)
        return o.e > e.e ^ l < 0 ? 1 : -1;
      for (n = s.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
        if (s[t] !== a[t])
          return s[t] > a[t] ^ l < 0 ? 1 : -1;
      return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
    };
    m.cosine = m.cos = function() {
      var e, t, r = this, n = r.constructor;
      return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = nc(n, Cs(n, r)), n.precision = e, n.rounding = t, h(Re == 2 || Re == 3 ? r.neg() : r, e, t, true)) : new n(1) : new n(NaN);
    };
    m.cubeRoot = m.cbrt = function() {
      var e, t, r, n, i, o, s, a, l, u, c = this, p = c.constructor;
      if (!c.isFinite() || c.isZero())
        return new p(c);
      for (w = false, o = c.s * j(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (r = W(c.d), e = c.e, (o = (e - r.length + 1) % 3) && (r += o == 1 || o == -2 ? "0" : "00"), o = j(r, 1 / 3), e = ee((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? r = "5e" + e : (r = o.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new p(r), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3; ; )
        if (a = n, l = a.times(a).times(a), u = l.plus(c), n = O(u.plus(c).times(a), u.plus(l), s + 2, 1), W(a.d).slice(0, s) === (r = W(n.d)).slice(0, s))
          if (r = r.slice(s - 3, s + 1), r == "9999" || !i && r == "4999") {
            if (!i && (h(a, e + 1, 0), a.times(a).times(a).eq(c))) {
              n = a;
              break;
            }
            s += 4, i = 1;
          } else {
            (!+r || !+r.slice(1) && r.charAt(0) == "5") && (h(n, e + 1, 1), t = !n.times(n).times(n).eq(c));
            break;
          }
      return w = true, h(n, e, p.rounding, t);
    };
    m.decimalPlaces = m.dp = function() {
      var e, t = this.d, r = NaN;
      if (t) {
        if (e = t.length - 1, r = (e - ee(this.e / b)) * b, e = t[e], e)
          for (; e % 10 == 0; e /= 10)
            r--;
        r < 0 && (r = 0);
      }
      return r;
    };
    m.dividedBy = m.div = function(e) {
      return O(this, new this.constructor(e));
    };
    m.dividedToIntegerBy = m.divToInt = function(e) {
      var t = this, r = t.constructor;
      return h(O(t, new r(e), 0, 1, 1), r.precision, r.rounding);
    };
    m.equals = m.eq = function(e) {
      return this.cmp(e) === 0;
    };
    m.floor = function() {
      return h(new this.constructor(this), this.e + 1, 3);
    };
    m.greaterThan = m.gt = function(e) {
      return this.cmp(e) > 0;
    };
    m.greaterThanOrEqualTo = m.gte = function(e) {
      var t = this.cmp(e);
      return t == 1 || t === 0;
    };
    m.hyperbolicCosine = m.cosh = function() {
      var e, t, r, n, i, o = this, s = o.constructor, a = new s(1);
      if (!o.isFinite())
        return new s(o.s ? 1 / 0 : NaN);
      if (o.isZero())
        return a;
      r = s.precision, n = s.rounding, s.precision = r + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Jr(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), o = gt(s, 1, o.times(t), new s(1), true);
      for (var l, u = e, c = new s(8); u--; )
        l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
      return h(o, s.precision = r, s.rounding = n, true);
    };
    m.hyperbolicSine = m.sinh = function() {
      var e, t, r, n, i = this, o = i.constructor;
      if (!i.isFinite() || i.isZero())
        return new o(i);
      if (t = o.precision, r = o.rounding, o.precision = t + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
        i = gt(o, 2, i, i, true);
      else {
        e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Jr(5, e)), i = gt(o, 2, i, i, true);
        for (var s, a = new o(5), l = new o(16), u = new o(20); e--; )
          s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
      }
      return o.precision = t, o.rounding = r, h(i, t, r, true);
    };
    m.hyperbolicTangent = m.tanh = function() {
      var e, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, O(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
    };
    m.inverseCosine = m.acos = function() {
      var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, o = r.rounding;
      return n !== -1 ? n === 0 ? t.isNeg() ? fe(r, i, o) : new r(0) : new r(NaN) : t.isZero() ? fe(r, i + 4, o).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = fe(r, i + 4, o).times(0.5), r.precision = i, r.rounding = o, e.minus(t));
    };
    m.inverseHyperbolicCosine = m.acosh = function() {
      var e, t, r = this, n = r.constructor;
      return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, w = false, r = r.times(r).minus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln()) : new n(r);
    };
    m.inverseHyperbolicSine = m.asinh = function() {
      var e, t, r = this, n = r.constructor;
      return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, w = false, r = r.times(r).plus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln());
    };
    m.inverseHyperbolicTangent = m.atanh = function() {
      var e, t, r, n, i = this, o = i.constructor;
      return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, t = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? h(new o(i), e, t, true) : (o.precision = r = n - i.e, i = O(i.plus(1), new o(1).minus(i), r + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = t, i.times(0.5))) : new o(NaN);
    };
    m.inverseSine = m.asin = function() {
      var e, t, r, n, i = this, o = i.constructor;
      return i.isZero() ? new o(i) : (t = i.abs().cmp(1), r = o.precision, n = o.rounding, t !== -1 ? t === 0 ? (e = fe(o, r + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = r + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = r, o.rounding = n, i.times(2)));
    };
    m.inverseTangent = m.atan = function() {
      var e, t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
      if (u.isFinite()) {
        if (u.isZero())
          return new c(u);
        if (u.abs().eq(1) && p + 4 <= fi)
          return s = fe(c, p + 4, d).times(0.25), s.s = u.s, s;
      } else {
        if (!u.s)
          return new c(NaN);
        if (p + 4 <= fi)
          return s = fe(c, p + 4, d).times(0.5), s.s = u.s, s;
      }
      for (c.precision = a = p + 10, c.rounding = 1, r = Math.min(28, a / b + 2 | 0), e = r; e; --e)
        u = u.div(u.times(u).plus(1).sqrt().plus(1));
      for (w = false, t = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u; e !== -1; )
        if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[t] !== void 0)
          for (e = t; s.d[e] === o.d[e] && e--; )
            ;
      return r && (s = s.times(2 << r - 1)), w = true, h(s, c.precision = p, c.rounding = d, true);
    };
    m.isFinite = function() {
      return !!this.d;
    };
    m.isInteger = m.isInt = function() {
      return !!this.d && ee(this.e / b) > this.d.length - 2;
    };
    m.isNaN = function() {
      return !this.s;
    };
    m.isNegative = m.isNeg = function() {
      return this.s < 0;
    };
    m.isPositive = m.isPos = function() {
      return this.s > 0;
    };
    m.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    m.lessThan = m.lt = function(e) {
      return this.cmp(e) < 0;
    };
    m.lessThanOrEqualTo = m.lte = function(e) {
      return this.cmp(e) < 1;
    };
    m.logarithm = m.log = function(e) {
      var t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
      if (e == null)
        e = new c(10), t = true;
      else {
        if (e = new c(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
          return new c(NaN);
        t = e.eq(10);
      }
      if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
        return new c(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
      if (t)
        if (r.length > 1)
          o = true;
        else {
          for (i = r[0]; i % 10 === 0; )
            i /= 10;
          o = i !== 1;
        }
      if (w = false, a = p + f, s = _e(u, a), n = t ? Ur(c, a + 10) : _e(e, a), l = O(s, n, a, 1), Qt(l.d, i = p, d))
        do
          if (a += 10, s = _e(u, a), n = t ? Ur(c, a + 10) : _e(e, a), l = O(s, n, a, 1), !o) {
            +W(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = h(l, p + 1, 0));
            break;
          }
        while (Qt(l.d, i += 10, d));
      return w = true, h(l, p, d);
    };
    m.minus = m.sub = function(e) {
      var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.constructor;
      if (e = new y(e), !f.d || !e.d)
        return !f.s || !e.s ? e = new y(NaN) : f.d ? e.s = -e.s : e = new y(e.d || f.s !== e.s ? f : NaN), e;
      if (f.s != e.s)
        return e.s = -e.s, f.plus(e);
      if (u = f.d, d = e.d, a = y.precision, l = y.rounding, !u[0] || !d[0]) {
        if (d[0])
          e.s = -e.s;
        else if (u[0])
          e = new y(f);
        else
          return new y(l === 3 ? -0 : 0);
        return w ? h(e, a, l) : e;
      }
      if (r = ee(e.e / b), c = ee(f.e / b), u = u.slice(), o = c - r, o) {
        for (p = o < 0, p ? (t = u, o = -o, s = d.length) : (t = d, r = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, t.length = 1), t.reverse(), n = o; n--; )
          t.push(0);
        t.reverse();
      } else {
        for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0; n < s; n++)
          if (u[n] != d[n]) {
            p = u[n] < d[n];
            break;
          }
        o = 0;
      }
      for (p && (t = u, u = d, d = t, e.s = -e.s), s = u.length, n = d.length - s; n > 0; --n)
        u[s++] = 0;
      for (n = d.length; n > o; ) {
        if (u[--n] < d[n]) {
          for (i = n; i && u[--i] === 0; )
            u[i] = ge - 1;
          --u[i], u[n] += ge;
        }
        u[n] -= d[n];
      }
      for (; u[--s] === 0; )
        u.pop();
      for (; u[0] === 0; u.shift())
        --r;
      return u[0] ? (e.d = u, e.e = Qr(u, r), w ? h(e, a, l) : e) : new y(l === 3 ? -0 : 0);
    };
    m.modulo = m.mod = function(e) {
      var t, r = this, n = r.constructor;
      return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? h(new n(r), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (t = O(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = O(r, e, 0, n.modulo, 1), t = t.times(e), w = true, r.minus(t));
    };
    m.naturalExponential = m.exp = function() {
      return gi(this);
    };
    m.naturalLogarithm = m.ln = function() {
      return _e(this);
    };
    m.negated = m.neg = function() {
      var e = new this.constructor(this);
      return e.s = -e.s, h(e);
    };
    m.plus = m.add = function(e) {
      var t, r, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
      if (e = new d(e), !p.d || !e.d)
        return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
      if (p.s != e.s)
        return e.s = -e.s, p.minus(e);
      if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0])
        return c[0] || (e = new d(p)), w ? h(e, a, l) : e;
      if (o = ee(p.e / b), n = ee(e.e / b), u = u.slice(), i = o - n, i) {
        for (i < 0 ? (r = u, i = -i, s = c.length) : (r = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, r.length = 1), r.reverse(); i--; )
          r.push(0);
        r.reverse();
      }
      for (s = u.length, i = c.length, s - i < 0 && (i = s, r = c, c = u, u = r), t = 0; i; )
        t = (u[--i] = u[i] + c[i] + t) / ge | 0, u[i] %= ge;
      for (t && (u.unshift(t), ++n), s = u.length; u[--s] == 0; )
        u.pop();
      return e.d = u, e.e = Qr(u, n), w ? h(e, a, l) : e;
    };
    m.precision = m.sd = function(e) {
      var t, r = this;
      if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)
        throw Error(Ne + e);
      return r.d ? (t = ws(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
    };
    m.round = function() {
      var e = this, t = e.constructor;
      return h(new t(e), e.e + 1, t.rounding);
    };
    m.sine = m.sin = function() {
      var e, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = oc(n, Cs(n, r)), n.precision = e, n.rounding = t, h(Re > 2 ? r.neg() : r, e, t, true)) : new n(NaN);
    };
    m.squareRoot = m.sqrt = function() {
      var e, t, r, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
      if (u !== 1 || !a || !a[0])
        return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
      for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (t = W(a), (t.length + l) % 2 == 0 && (t += "0"), u = Math.sqrt(t), l = ee((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? t = "5e" + l : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new c(t)) : n = new c(u.toString()), r = (l = c.precision) + 3; ; )
        if (o = n, n = o.plus(O(s, o, r + 2, 1)).times(0.5), W(o.d).slice(0, r) === (t = W(n.d)).slice(0, r))
          if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
            if (!i && (h(o, l + 1, 0), o.times(o).eq(s))) {
              n = o;
              break;
            }
            r += 4, i = 1;
          } else {
            (!+t || !+t.slice(1) && t.charAt(0) == "5") && (h(n, l + 1, 1), e = !n.times(n).eq(s));
            break;
          }
      return w = true, h(n, l, c.rounding, e);
    };
    m.tangent = m.tan = function() {
      var e, t, r = this, n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = O(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, h(Re == 2 || Re == 4 ? r.neg() : r, e, t, true)) : new n(NaN);
    };
    m.times = m.mul = function(e) {
      var t, r, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
      if (e.s *= c.s, !d || !d[0] || !f || !f[0])
        return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
      for (r = ee(c.e / b) + ee(e.e / b), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s; n--; )
        o.push(0);
      for (n = u; --n >= 0; ) {
        for (t = 0, i = l + n; i > n; )
          a = o[i] + f[n] * d[i - n - 1] + t, o[i--] = a % ge | 0, t = a / ge | 0;
        o[i] = (o[i] + t) % ge | 0;
      }
      for (; !o[--s]; )
        o.pop();
      return t ? ++r : o.shift(), e.d = o, e.e = Qr(o, r), w ? h(e, p.precision, p.rounding) : e;
    };
    m.toBinary = function(e, t) {
      return hi(this, 2, e, t);
    };
    m.toDecimalPlaces = m.toDP = function(e, t) {
      var r = this, n = r.constructor;
      return r = new n(r), e === void 0 ? r : (se(e, 0, Le), t === void 0 ? t = n.rounding : se(t, 0, 8), h(r, e + r.e + 1, t));
    };
    m.toExponential = function(e, t) {
      var r, n = this, i = n.constructor;
      return e === void 0 ? r = Ee(n, true) : (se(e, 0, Le), t === void 0 ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e + 1, t), r = Ee(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    m.toFixed = function(e, t) {
      var r, n, i = this, o = i.constructor;
      return e === void 0 ? r = Ee(i) : (se(e, 0, Le), t === void 0 ? t = o.rounding : se(t, 0, 8), n = h(new o(i), e + i.e + 1, t), r = Ee(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
    };
    m.toFraction = function(e) {
      var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.d, g = f.constructor;
      if (!y)
        return new g(f);
      if (u = r = new g(1), n = l = new g(0), t = new g(n), o = t.e = ws(y) - f.e - 1, s = o % b, t.d[0] = j(10, s < 0 ? b + s : s), e == null)
        e = o > 0 ? t : u;
      else {
        if (a = new g(e), !a.isInt() || a.lt(u))
          throw Error(Ne + a);
        e = a.gt(t) ? o > 0 ? t : u : a;
      }
      for (w = false, a = new g(W(y)), c = g.precision, g.precision = o = y.length * b * 2; p = O(a, t, 0, 1, 1), i = r.plus(p.times(n)), i.cmp(e) != 1; )
        r = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = t, t = a.minus(p.times(i)), a = i;
      return i = O(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(u)), r = r.plus(i.times(n)), l.s = u.s = f.s, d = O(u, n, o, 1).minus(f).abs().cmp(O(l, r, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, r], g.precision = c, w = true, d;
    };
    m.toHexadecimal = m.toHex = function(e, t) {
      return hi(this, 16, e, t);
    };
    m.toNearest = function(e, t) {
      var r = this, n = r.constructor;
      if (r = new n(r), e == null) {
        if (!r.d)
          return r;
        e = new n(1), t = n.rounding;
      } else {
        if (e = new n(e), t === void 0 ? t = n.rounding : se(t, 0, 8), !r.d)
          return e.s ? r : e;
        if (!e.d)
          return e.s && (e.s = r.s), e;
      }
      return e.d[0] ? (w = false, r = O(r, e, 0, t, 1).times(e), w = true, h(r)) : (e.s = r.s, r = e), r;
    };
    m.toNumber = function() {
      return +this;
    };
    m.toOctal = function(e, t) {
      return hi(this, 8, e, t);
    };
    m.toPower = m.pow = function(e) {
      var t, r, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
      if (!a.d || !e.d || !a.d[0] || !e.d[0])
        return new l(j(+a, u));
      if (a = new l(a), a.eq(1))
        return a;
      if (n = l.precision, o = l.rounding, e.eq(1))
        return h(a, n, o);
      if (t = ee(e.e / b), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= tc)
        return i = Ps(l, a, r, n), e.s < 0 ? new l(1).div(i) : h(i, n, o);
      if (s = a.s, s < 0) {
        if (t < e.d.length - 1)
          return new l(NaN);
        if (e.d[t] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
          return a.s = s, a;
      }
      return r = j(+a, u), t = r == 0 || !isFinite(r) ? ee(u * (Math.log("0." + W(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = gi(e.times(_e(a, n + r)), n), i.d && (i = h(i, n + 5, 1), Qt(i.d, n, o) && (t = n + 10, i = h(gi(e.times(_e(a, t + r)), t), t + 5, 1), +W(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = h(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, h(i, n, o));
    };
    m.toPrecision = function(e, t) {
      var r, n = this, i = n.constructor;
      return e === void 0 ? r = Ee(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e, 1, Le), t === void 0 ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e, t), r = Ee(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
    };
    m.toSignificantDigits = m.toSD = function(e, t) {
      var r = this, n = r.constructor;
      return e === void 0 ? (e = n.precision, t = n.rounding) : (se(e, 1, Le), t === void 0 ? t = n.rounding : se(t, 0, 8)), h(new n(r), e, t);
    };
    m.toString = function() {
      var e = this, t = e.constructor, r = Ee(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
      return e.isNeg() && !e.isZero() ? "-" + r : r;
    };
    m.truncated = m.trunc = function() {
      return h(new this.constructor(this), this.e + 1, 1);
    };
    m.valueOf = m.toJSON = function() {
      var e = this, t = e.constructor, r = Ee(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
      return e.isNeg() ? "-" + r : r;
    };
    function W(e) {
      var t, r, n, i = e.length - 1, o = "", s = e[0];
      if (i > 0) {
        for (o += s, t = 1; t < i; t++)
          n = e[t] + "", r = b - n.length, r && (o += De(r)), o += n;
        s = e[t], n = s + "", r = b - n.length, r && (o += De(r));
      } else if (s === 0)
        return "0";
      for (; s % 10 === 0; )
        s /= 10;
      return o + s;
    }
    function se(e, t, r) {
      if (e !== ~~e || e < t || e > r)
        throw Error(Ne + e);
    }
    function Qt(e, t, r, n) {
      var i, o, s, a;
      for (o = e[0]; o >= 10; o /= 10)
        --t;
      return --t < 0 ? (t += b, i = 0) : (i = Math.ceil((t + 1) / b), t %= b), o = j(10, b - t), a = e[i] % o | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), s = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : s = (r < 4 && a + 1 == o || r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == j(10, t - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), s = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : s = ((n || r < 4) && a + 1 == o || !n && r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1e3 | 0) == j(10, t - 3) - 1, s;
    }
    function Vr(e, t, r) {
      for (var n, i = [0], o, s = 0, a = e.length; s < a; ) {
        for (o = i.length; o--; )
          i[o] *= t;
        for (i[0] += di.indexOf(e.charAt(s++)), n = 0; n < i.length; n++)
          i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
      }
      return i.reverse();
    }
    function nc(e, t) {
      var r, n, i;
      if (t.isZero())
        return t;
      n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Jr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = gt(e, 1, t.times(i), new e(1));
      for (var o = r; o--; ) {
        var s = t.times(t);
        t = s.times(s).minus(s).times(8).plus(1);
      }
      return e.precision -= r, t;
    }
    var O = function() {
      function e(n, i, o) {
        var s, a = 0, l = n.length;
        for (n = n.slice(); l--; )
          s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
        return a && n.unshift(a), n;
      }
      function t(n, i, o, s) {
        var a, l;
        if (o != s)
          l = o > s ? 1 : -1;
        else
          for (a = l = 0; a < o; a++)
            if (n[a] != i[a]) {
              l = n[a] > i[a] ? 1 : -1;
              break;
            }
        return l;
      }
      function r(n, i, o, s) {
        for (var a = 0; o--; )
          n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
        for (; !n[0] && n.length > 1; )
          n.shift();
      }
      return function(n, i, o, s, a, l) {
        var u, c, p, d, f, y, g, P, T, C, x, R, ce, G, Ue, $, z, Te, Y, et, gr = n.constructor, Pn = n.s == i.s ? 1 : -1, Z = n.d, F = i.d;
        if (!Z || !Z[0] || !F || !F[0])
          return new gr(!n.s || !i.s || (Z ? F && Z[0] == F[0] : !F) ? NaN : Z && Z[0] == 0 || !F ? Pn * 0 : Pn / 0);
        for (l ? (f = 1, c = n.e - i.e) : (l = ge, f = b, c = ee(n.e / f) - ee(i.e / f)), Y = F.length, z = Z.length, T = new gr(Pn), C = T.d = [], p = 0; F[p] == (Z[p] || 0); p++)
          ;
        if (F[p] > (Z[p] || 0) && c--, o == null ? (G = o = gr.precision, s = gr.rounding) : a ? G = o + (n.e - i.e) + 1 : G = o, G < 0)
          C.push(1), y = true;
        else {
          if (G = G / f + 2 | 0, p = 0, Y == 1) {
            for (d = 0, F = F[0], G++; (p < z || d) && G--; p++)
              Ue = d * l + (Z[p] || 0), C[p] = Ue / F | 0, d = Ue % F | 0;
            y = d || p < z;
          } else {
            for (d = l / (F[0] + 1) | 0, d > 1 && (F = e(F, d, l), Z = e(Z, d, l), Y = F.length, z = Z.length), $ = Y, x = Z.slice(0, Y), R = x.length; R < Y; )
              x[R++] = 0;
            et = F.slice(), et.unshift(0), Te = F[0], F[1] >= l / 2 && ++Te;
            do
              d = 0, u = t(F, x, Y, R), u < 0 ? (ce = x[0], Y != R && (ce = ce * l + (x[1] || 0)), d = ce / Te | 0, d > 1 ? (d >= l && (d = l - 1), g = e(F, d, l), P = g.length, R = x.length, u = t(g, x, P, R), u == 1 && (d--, r(g, Y < P ? et : F, P, l))) : (d == 0 && (u = d = 1), g = F.slice()), P = g.length, P < R && g.unshift(0), r(x, g, R, l), u == -1 && (R = x.length, u = t(F, x, Y, R), u < 1 && (d++, r(x, Y < R ? et : F, R, l))), R = x.length) : u === 0 && (d++, x = [0]), C[p++] = d, u && x[0] ? x[R++] = Z[$] || 0 : (x = [Z[$]], R = 1);
            while (($++ < z || x[0] !== void 0) && G--);
            y = x[0] !== void 0;
          }
          C[0] || C.shift();
        }
        if (f == 1)
          T.e = c, ys = y;
        else {
          for (p = 1, d = C[0]; d >= 10; d /= 10)
            p++;
          T.e = p + c * f - 1, h(T, a ? o + T.e + 1 : o, s, y);
        }
        return T;
      };
    }();
    function h(e, t, r, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor;
      e:
        if (t != null) {
          if (p = e.d, !p)
            return e;
          for (i = 1, a = p[0]; a >= 10; a /= 10)
            i++;
          if (o = t - i, o < 0)
            o += b, s = t, c = p[d = 0], l = c / j(10, i - s - 1) % 10 | 0;
          else if (d = Math.ceil((o + 1) / b), a = p.length, d >= a)
            if (n) {
              for (; a++ <= d; )
                p.push(0);
              c = l = 0, i = 1, o %= b, s = o - b + 1;
            } else
              break e;
          else {
            for (c = a = p[d], i = 1; a >= 10; a /= 10)
              i++;
            o %= b, s = o - b + i, l = s < 0 ? 0 : c / j(10, i - s - 1) % 10 | 0;
          }
          if (n = n || t < 0 || p[d + 1] !== void 0 || (s < 0 ? c : c % j(10, i - s - 1)), u = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && (o > 0 ? s > 0 ? c / j(10, i - s) : 0 : p[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !p[0])
            return p.length = 0, u ? (t -= e.e + 1, p[0] = j(10, (b - t % b) % b), e.e = -t || 0) : p[0] = e.e = 0, e;
          if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = j(10, b - o), p[d] = s > 0 ? (c / j(10, i - s) % j(10, s) | 0) * a : 0), u)
            for (; ; )
              if (d == 0) {
                for (o = 1, s = p[0]; s >= 10; s /= 10)
                  o++;
                for (s = p[0] += a, a = 1; s >= 10; s /= 10)
                  a++;
                o != a && (e.e++, p[0] == ge && (p[0] = 1));
                break;
              } else {
                if (p[d] += a, p[d] != ge)
                  break;
                p[d--] = 0, a = 1;
              }
          for (o = p.length; p[--o] === 0; )
            p.pop();
        }
      return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
    }
    function Ee(e, t, r) {
      if (!e.isFinite())
        return Ts(e);
      var n, i = e.e, o = W(e.d), s = o.length;
      return t ? (r && (n = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + De(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + De(-i - 1) + o, r && (n = r - s) > 0 && (o += De(n))) : i >= s ? (o += De(i + 1 - s), r && (n = r - i - 1) > 0 && (o = o + "." + De(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (o += "."), o += De(n))), o;
    }
    function Qr(e, t) {
      var r = e[0];
      for (t *= b; r >= 10; r /= 10)
        t++;
      return t;
    }
    function Ur(e, t, r) {
      if (t > rc)
        throw w = true, r && (e.precision = r), Error(hs);
      return h(new e(jr), t, 1, true);
    }
    function fe(e, t, r) {
      if (t > fi)
        throw Error(hs);
      return h(new e(Br), t, r, true);
    }
    function ws(e) {
      var t = e.length - 1, r = t * b + 1;
      if (t = e[t], t) {
        for (; t % 10 == 0; t /= 10)
          r--;
        for (t = e[0]; t >= 10; t /= 10)
          r++;
      }
      return r;
    }
    function De(e) {
      for (var t = ""; e--; )
        t += "0";
      return t;
    }
    function Ps(e, t, r, n) {
      var i, o = new e(1), s = Math.ceil(n / b + 4);
      for (w = false; ; ) {
        if (r % 2 && (o = o.times(t), fs(o.d, s) && (i = true)), r = ee(r / 2), r === 0) {
          r = o.d.length - 1, i && o.d[r] === 0 && ++o.d[r];
          break;
        }
        t = t.times(t), fs(t.d, s);
      }
      return w = true, o;
    }
    function ms(e) {
      return e.d[e.d.length - 1] & 1;
    }
    function vs(e, t, r) {
      for (var n, i = new e(t[0]), o = 0; ++o < t.length; )
        if (n = new e(t[o]), n.s)
          i[r](n) && (i = n);
        else {
          i = n;
          break;
        }
      return i;
    }
    function gi(e, t) {
      var r, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, y = d.precision;
      if (!e.d || !e.d[0] || e.e > 17)
        return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
      for (t == null ? (w = false, l = y) : l = t, a = new d(0.03125); e.e > -2; )
        e = e.times(a), p += 5;
      for (n = Math.log(j(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, r = o = s = new d(1), d.precision = l; ; ) {
        if (o = h(o.times(e), l, 1), r = r.times(++c), a = s.plus(O(o, r, l, 1)), W(a.d).slice(0, l) === W(s.d).slice(0, l)) {
          for (i = p; i--; )
            s = h(s.times(s), l, 1);
          if (t == null)
            if (u < 3 && Qt(s.d, l - n, f, u))
              d.precision = l += 10, r = o = a = new d(1), c = 0, u++;
            else
              return h(s, d.precision = y, f, w = true);
          else
            return d.precision = y, s;
        }
        s = a;
      }
    }
    function _e(e, t) {
      var r, n, i, o, s, a, l, u, c, p, d, f = 1, y = 10, g = e, P = g.d, T = g.constructor, C = T.rounding, x = T.precision;
      if (g.s < 0 || !P || !P[0] || !g.e && P[0] == 1 && P.length == 1)
        return new T(P && !P[0] ? -1 / 0 : g.s != 1 ? NaN : P ? 0 : g);
      if (t == null ? (w = false, c = x) : c = t, T.precision = c += y, r = W(P), n = r.charAt(0), Math.abs(o = g.e) < 15e14) {
        for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
          g = g.times(e), r = W(g.d), n = r.charAt(0), f++;
        o = g.e, n > 1 ? (g = new T("0." + r), o++) : g = new T(n + "." + r.slice(1));
      } else
        return u = Ur(T, c + 2, x).times(o + ""), g = _e(new T(n + "." + r.slice(1)), c - y).plus(u), T.precision = x, t == null ? h(g, x, C, w = true) : g;
      for (p = g, l = s = g = O(g.minus(1), g.plus(1), c, 1), d = h(g.times(g), c, 1), i = 3; ; ) {
        if (s = h(s.times(d), c, 1), u = l.plus(O(s, new T(i), c, 1)), W(u.d).slice(0, c) === W(l.d).slice(0, c))
          if (l = l.times(2), o !== 0 && (l = l.plus(Ur(T, c + 2, x).times(o + ""))), l = O(l, new T(f), c, 1), t == null)
            if (Qt(l.d, c - y, C, a))
              T.precision = c += y, u = s = g = O(p.minus(1), p.plus(1), c, 1), d = h(g.times(g), c, 1), i = a = 1;
            else
              return h(l, T.precision = x, C, w = true);
          else
            return T.precision = x, l;
        l = u, i += 2;
      }
    }
    function Ts(e) {
      return String(e.s * e.s / 0);
    }
    function yi(e, t) {
      var r, n, i;
      for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++)
        ;
      for (i = t.length; t.charCodeAt(i - 1) === 48; --i)
        ;
      if (t = t.slice(n, i), t) {
        if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % b, r < 0 && (n += b), n < i) {
          for (n && e.d.push(+t.slice(0, n)), i -= b; n < i; )
            e.d.push(+t.slice(n, n += b));
          t = t.slice(n), n = b - t.length;
        } else
          n -= i;
        for (; n--; )
          t += "0";
        e.d.push(+t), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
      } else
        e.e = 0, e.d = [0];
      return e;
    }
    function ic(e, t) {
      var r, n, i, o, s, a, l, u, c;
      if (t.indexOf("_") > -1) {
        if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Es.test(t))
          return yi(e, t);
      } else if (t === "Infinity" || t === "NaN")
        return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
      if (Xu.test(t))
        r = 16, t = t.toLowerCase();
      else if (Zu.test(t))
        r = 2;
      else if (ec.test(t))
        r = 8;
      else
        throw Error(Ne + t);
      for (o = t.search(/p/i), o > 0 ? (l = +t.slice(o + 1), t = t.substring(2, o)) : t = t.slice(2), o = t.indexOf("."), s = o >= 0, n = e.constructor, s && (t = t.replace(".", ""), a = t.length, o = a - o, i = Ps(n, new n(r), o, o * 2)), u = Vr(t, r, ge), c = u.length - 1, o = c; u[o] === 0; --o)
        u.pop();
      return o < 0 ? new n(e.s * 0) : (e.e = Qr(u, c), e.d = u, w = false, s && (e = O(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? j(2, l) : We.pow(2, l))), w = true, e);
    }
    function oc(e, t) {
      var r, n = t.d.length;
      if (n < 3)
        return t.isZero() ? t : gt(e, 2, t, t);
      r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Jr(5, r)), t = gt(e, 2, t, t);
      for (var i, o = new e(5), s = new e(16), a = new e(20); r--; )
        i = t.times(t), t = t.times(o.plus(i.times(s.times(i).minus(a))));
      return t;
    }
    function gt(e, t, r, n, i) {
      var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
      for (w = false, l = r.times(r), a = new e(n); ; ) {
        if (s = O(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e(t++ * t++), c, 1), s = a.plus(n), s.d[p] !== void 0) {
          for (o = p; s.d[o] === a.d[o] && o--; )
            ;
          if (o == -1)
            break;
        }
        o = a, a = n, n = s, s = o, u++;
      }
      return w = true, s.d.length = p + 1, s;
    }
    function Jr(e, t) {
      for (var r = e; --t; )
        r *= e;
      return r;
    }
    function Cs(e, t) {
      var r, n = t.s < 0, i = fe(e, e.precision, 1), o = i.times(0.5);
      if (t = t.abs(), t.lte(o))
        return Re = n ? 4 : 1, t;
      if (r = t.divToInt(i), r.isZero())
        Re = n ? 3 : 2;
      else {
        if (t = t.minus(r.times(i)), t.lte(o))
          return Re = ms(r) ? n ? 2 : 3 : n ? 4 : 1, t;
        Re = ms(r) ? n ? 1 : 4 : n ? 3 : 2;
      }
      return t.minus(i).abs();
    }
    function hi(e, t, r, n) {
      var i, o, s, a, l, u, c, p, d, f = e.constructor, y = r !== void 0;
      if (y ? (se(r, 1, Le), n === void 0 ? n = f.rounding : se(n, 0, 8)) : (r = f.precision, n = f.rounding), !e.isFinite())
        c = Ts(e);
      else {
        for (c = Ee(e), s = c.indexOf("."), y ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = Vr(Ee(d), 10, i), d.e = d.d.length), p = Vr(c, 10, i), o = l = p.length; p[--l] == 0; )
          p.pop();
        if (!p[0])
          c = y ? "0p+0" : "0";
        else {
          if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = O(e, d, r, n, 0, i), p = e.d, o = e.e, u = ys), s = p[r], a = i / 2, u = u || p[r + 1] !== void 0, u = n < 4 ? (s !== void 0 || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = r, u)
            for (; ++p[--r] > i - 1; )
              p[r] = 0, r || (++o, p.unshift(1));
          for (l = p.length; !p[l - 1]; --l)
            ;
          for (s = 0, c = ""; s < l; s++)
            c += di.charAt(p[s]);
          if (y) {
            if (l > 1)
              if (t == 16 || t == 8) {
                for (s = t == 16 ? 4 : 3, --l; l % s; l++)
                  c += "0";
                for (p = Vr(c, i, t), l = p.length; !p[l - 1]; --l)
                  ;
                for (s = 1, c = "1."; s < l; s++)
                  c += di.charAt(p[s]);
              } else
                c = c.charAt(0) + "." + c.slice(1);
            c = c + (o < 0 ? "p" : "p+") + o;
          } else if (o < 0) {
            for (; ++o; )
              c = "0" + c;
            c = "0." + c;
          } else if (++o > l)
            for (o -= l; o--; )
              c += "0";
          else
            o < l && (c = c.slice(0, o) + "." + c.slice(o));
        }
        c = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + c;
      }
      return e.s < 0 ? "-" + c : c;
    }
    function fs(e, t) {
      if (e.length > t)
        return e.length = t, true;
    }
    function sc(e) {
      return new this(e).abs();
    }
    function ac(e) {
      return new this(e).acos();
    }
    function lc(e) {
      return new this(e).acosh();
    }
    function uc(e, t) {
      return new this(e).plus(t);
    }
    function cc(e) {
      return new this(e).asin();
    }
    function pc(e) {
      return new this(e).asinh();
    }
    function dc(e) {
      return new this(e).atan();
    }
    function mc(e) {
      return new this(e).atanh();
    }
    function fc(e, t) {
      e = new this(e), t = new this(t);
      var r, n = this.precision, i = this.rounding, o = n + 4;
      return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = fe(this, o, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? fe(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = fe(this, o, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = o, this.rounding = 1, r = this.atan(O(e, t, o, 1)), t = fe(this, o, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(O(e, t, o, 1)), r;
    }
    function gc(e) {
      return new this(e).cbrt();
    }
    function yc(e) {
      return h(e = new this(e), e.e + 1, 2);
    }
    function hc(e, t, r) {
      return new this(e).clamp(t, r);
    }
    function xc(e) {
      if (!e || typeof e != "object")
        throw Error(Kr + "Object expected");
      var t, r, n, i = e.defaults === true, o = ["precision", 1, Le, "rounding", 0, 8, "toExpNeg", -ft, 0, "toExpPos", 0, ft, "maxE", 0, ft, "minE", -ft, 0, "modulo", 0, 9];
      for (t = 0; t < o.length; t += 3)
        if (r = o[t], i && (this[r] = mi[r]), (n = e[r]) !== void 0)
          if (ee(n) === n && n >= o[t + 1] && n <= o[t + 2])
            this[r] = n;
          else
            throw Error(Ne + r + ": " + n);
      if (r = "crypto", i && (this[r] = mi[r]), (n = e[r]) !== void 0)
        if (n === true || n === false || n === 0 || n === 1)
          if (n)
            if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
              this[r] = true;
            else
              throw Error(xs);
          else
            this[r] = false;
        else
          throw Error(Ne + r + ": " + n);
      return this;
    }
    function bc(e) {
      return new this(e).cos();
    }
    function Ec(e) {
      return new this(e).cosh();
    }
    function As(e) {
      var t, r, n;
      function i(o) {
        var s, a, l, u = this;
        if (!(u instanceof i))
          return new i(o);
        if (u.constructor = i, gs(o)) {
          u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
          return;
        }
        if (l = typeof o, l === "number") {
          if (o === 0) {
            u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
            return;
          }
          if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
            for (s = 0, a = o; a >= 10; a /= 10)
              s++;
            w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
            return;
          } else if (o * 0 !== 0) {
            o || (u.s = NaN), u.e = NaN, u.d = null;
            return;
          }
          return yi(u, o.toString());
        } else if (l !== "string")
          throw Error(Ne + o);
        return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Es.test(o) ? yi(u, o) : ic(u, o);
      }
      if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = xc, i.clone = As, i.isDecimal = gs, i.abs = sc, i.acos = ac, i.acosh = lc, i.add = uc, i.asin = cc, i.asinh = pc, i.atan = dc, i.atanh = mc, i.atan2 = fc, i.cbrt = gc, i.ceil = yc, i.clamp = hc, i.cos = bc, i.cosh = Ec, i.div = wc, i.exp = Pc, i.floor = vc, i.hypot = Tc, i.ln = Cc, i.log = Ac, i.log10 = Mc, i.log2 = Rc, i.max = Sc, i.min = Ic, i.mod = Fc, i.mul = kc, i.pow = Oc, i.random = Dc, i.round = _c, i.sign = Nc, i.sin = Lc, i.sinh = $c, i.sqrt = qc, i.sub = Vc, i.sum = jc, i.tan = Bc, i.tanh = Uc, i.trunc = Kc, e === void 0 && (e = {}), e && e.defaults !== true)
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; )
          e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
      return i.config(e), i;
    }
    function wc(e, t) {
      return new this(e).div(t);
    }
    function Pc(e) {
      return new this(e).exp();
    }
    function vc(e) {
      return h(e = new this(e), e.e + 1, 3);
    }
    function Tc() {
      var e, t, r = new this(0);
      for (w = false, e = 0; e < arguments.length; )
        if (t = new this(arguments[e++]), t.d)
          r.d && (r = r.plus(t.times(t)));
        else {
          if (t.s)
            return w = true, new this(1 / 0);
          r = t;
        }
      return w = true, r.sqrt();
    }
    function gs(e) {
      return e instanceof We || e && e.toStringTag === bs || false;
    }
    function Cc(e) {
      return new this(e).ln();
    }
    function Ac(e, t) {
      return new this(e).log(t);
    }
    function Rc(e) {
      return new this(e).log(2);
    }
    function Mc(e) {
      return new this(e).log(10);
    }
    function Sc() {
      return vs(this, arguments, "lt");
    }
    function Ic() {
      return vs(this, arguments, "gt");
    }
    function Fc(e, t) {
      return new this(e).mod(t);
    }
    function kc(e, t) {
      return new this(e).mul(t);
    }
    function Oc(e, t) {
      return new this(e).pow(t);
    }
    function Dc(e) {
      var t, r, n, i, o = 0, s = new this(1), a = [];
      if (e === void 0 ? e = this.precision : se(e, 1, Le), n = Math.ceil(e / b), this.crypto)
        if (crypto.getRandomValues)
          for (t = crypto.getRandomValues(new Uint32Array(n)); o < n; )
            i = t[o], i >= 429e7 ? t[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
        else if (crypto.randomBytes) {
          for (t = crypto.randomBytes(n *= 4); o < n; )
            i = t[o] + (t[o + 1] << 8) + (t[o + 2] << 16) + ((t[o + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, o) : (a.push(i % 1e7), o += 4);
          o = n / 4;
        } else
          throw Error(xs);
      else
        for (; o < n; )
          a[o++] = Math.random() * 1e7 | 0;
      for (n = a[--o], e %= b, n && e && (i = j(10, b - e), a[o] = (n / i | 0) * i); a[o] === 0; o--)
        a.pop();
      if (o < 0)
        r = 0, a = [0];
      else {
        for (r = -1; a[0] === 0; r -= b)
          a.shift();
        for (n = 1, i = a[0]; i >= 10; i /= 10)
          n++;
        n < b && (r -= b - n);
      }
      return s.e = r, s.d = a, s;
    }
    function _c(e) {
      return h(e = new this(e), e.e + 1, this.rounding);
    }
    function Nc(e) {
      return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
    }
    function Lc(e) {
      return new this(e).sin();
    }
    function $c(e) {
      return new this(e).sinh();
    }
    function qc(e) {
      return new this(e).sqrt();
    }
    function Vc(e, t) {
      return new this(e).sub(t);
    }
    function jc() {
      var e = 0, t = arguments, r = new this(t[e]);
      for (w = false; r.s && ++e < t.length; )
        r = r.plus(t[e]);
      return w = true, h(r, this.precision, this.rounding);
    }
    function Bc(e) {
      return new this(e).tan();
    }
    function Uc(e) {
      return new this(e).tanh();
    }
    function Kc(e) {
      return h(e = new this(e), e.e + 1, 1);
    }
    m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
    m[Symbol.toStringTag] = "Decimal";
    var We = m.constructor = As(mi);
    jr = new We(jr);
    Br = new We(Br);
    var we = We;
    function yt(e) {
      return We.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
    }
    var Jt = class {
      constructor(t, r, n, i, o) {
        this.modelName = t, this.name = r, this.typeName = n, this.isList = i, this.isEnum = o;
      }
      _toGraphQLInputType() {
        let t = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
        return `${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function ht(e) {
      return e instanceof Jt;
    }
    var Gr = class {
      constructor(t) {
        this.value = t;
      }
      write(t) {
        t.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    var Hr = (e) => e;
    var Wr = { bold: Hr, red: Hr, green: Hr, dim: Hr };
    var Rs = { bold: ne, red: me, green: Qe, dim: ke };
    var xt = { write(e) {
      e.writeLine(",");
    } };
    var Pe = class {
      constructor(t) {
        this.contents = t;
        this.isUnderlined = false;
        this.color = (t2) => t2;
      }
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(t) {
        return this.color = t, this;
      }
      write(t) {
        let r = t.getCurrentLineLength();
        t.write(this.color(this.contents)), this.isUnderlined && t.afterNextNewline(() => {
          t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    var $e = class {
      constructor() {
        this.hasError = false;
      }
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var bt = class extends $e {
      constructor() {
        super(...arguments);
        this.items = [];
      }
      addItem(r) {
        return this.items.push(new Gr(r)), this;
      }
      getField(r) {
        return this.items[r];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
      }
      write(r) {
        if (this.items.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithItems(r);
      }
      writeEmpty(r) {
        let n = new Pe("[]");
        this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
      }
      writeWithItems(r) {
        let { colors: n } = r.context;
        r.writeLine("[").withIndent(() => r.writeJoined(xt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(n.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var Ms = ": ";
    var zr = class {
      constructor(t, r) {
        this.name = t;
        this.value = r;
        this.hasError = false;
      }
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + Ms.length;
      }
      write(t) {
        let r = new Pe(this.name);
        this.hasError && r.underline().setColor(t.context.colors.red), t.write(r).write(Ms).write(this.value);
      }
    };
    var Q = class e extends $e {
      constructor() {
        super(...arguments);
        this.fields = {};
        this.suggestions = [];
      }
      addField(r) {
        this.fields[r.name] = r;
      }
      addSuggestion(r) {
        this.suggestions.push(r);
      }
      getField(r) {
        return this.fields[r];
      }
      getDeepField(r) {
        let [n, ...i] = r, o = this.getField(n);
        if (!o)
          return;
        let s = o;
        for (let a of i) {
          let l;
          if (s.value instanceof e ? l = s.value.getField(a) : s.value instanceof bt && (l = s.value.getField(Number(a))), !l)
            return;
          s = l;
        }
        return s;
      }
      getDeepFieldValue(r) {
        return r.length === 0 ? this : this.getDeepField(r)?.value;
      }
      hasField(r) {
        return !!this.getField(r);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(r) {
        delete this.fields[r];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(r) {
        return this.getField(r)?.value;
      }
      getDeepSubSelectionValue(r) {
        let n = this;
        for (let i of r) {
          if (!(n instanceof e))
            return;
          let o = n.getSubSelectionValue(i);
          if (!o)
            return;
          n = o;
        }
        return n;
      }
      getDeepSelectionParent(r) {
        let n = this.getSelectionParent();
        if (!n)
          return;
        let i = n;
        for (let o of r) {
          let s = i.value.getFieldValue(o);
          if (!s || !(s instanceof e))
            return;
          let a = s.getSelectionParent();
          if (!a)
            return;
          i = a;
        }
        return i;
      }
      getSelectionParent() {
        let r = this.getField("select");
        if (r?.value instanceof e)
          return { kind: "select", value: r.value };
        let n = this.getField("include");
        if (n?.value instanceof e)
          return { kind: "include", value: n.value };
      }
      getSubSelectionValue(r) {
        return this.getSelectionParent()?.value.fields[r].value;
      }
      getPrintWidth() {
        let r = Object.values(this.fields);
        return r.length == 0 ? 2 : Math.max(...r.map((i) => i.getPrintWidth())) + 2;
      }
      write(r) {
        let n = Object.values(this.fields);
        if (n.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(r);
          return;
        }
        this.writeWithContents(r, n);
      }
      writeEmpty(r) {
        let n = new Pe("{}");
        this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
      }
      writeWithContents(r, n) {
        r.writeLine("{").withIndent(() => {
          r.writeJoined(xt, [...n, ...this.suggestions]).newLine();
        }), r.write("}"), this.hasError && r.afterNextNewline(() => {
          r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    var J = class extends $e {
      constructor(r) {
        super();
        this.text = r;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r) {
        let n = new Pe(this.text);
        this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
      }
    };
    var xi = class {
      constructor(t) {
        this.errorMessages = [];
        this.arguments = t;
      }
      write(t) {
        t.write(this.arguments);
      }
      addErrorMessage(t) {
        this.errorMessages.push(t);
      }
      renderAllMessages(t) {
        return this.errorMessages.map((r) => r(t)).join(`
`);
      }
    };
    function Yr(e) {
      return new xi(Ss(e));
    }
    function Ss(e) {
      let t = new Q();
      for (let [r, n] of Object.entries(e)) {
        let i = new zr(r, Is(n));
        t.addField(i);
      }
      return t;
    }
    function Is(e) {
      if (typeof e == "string")
        return new J(JSON.stringify(e));
      if (typeof e == "number" || typeof e == "boolean")
        return new J(String(e));
      if (typeof e == "bigint")
        return new J(`${e}n`);
      if (e === null)
        return new J("null");
      if (e === void 0)
        return new J("undefined");
      if (yt(e))
        return new J(`new Prisma.Decimal("${e.toFixed()}")`);
      if (e instanceof Uint8Array)
        return Buffer.isBuffer(e) ? new J(`Buffer.alloc(${e.byteLength})`) : new J(`new Uint8Array(${e.byteLength})`);
      if (e instanceof Date) {
        let t = qr(e) ? e.toISOString() : "Invalid Date";
        return new J(`new Date("${t}")`);
      }
      return e instanceof Ae ? new J(`Prisma.${e._getName()}`) : ht(e) ? new J(`prisma.${to(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? Jc(e) : typeof e == "object" ? Ss(e) : new J(Object.prototype.toString.call(e));
    }
    function Jc(e) {
      let t = new bt();
      for (let r of e)
        t.addItem(Is(r));
      return t;
    }
    function Fs(e) {
      if (e === void 0)
        return "";
      let t = Yr(e);
      return new dt(0, { colors: Wr }).write(t).toString();
    }
    var Gt = "<unknown>";
    function ks(e) {
      var t = e.split(`
`);
      return t.reduce(function(r, n) {
        var i = Wc(n) || Yc(n) || ep(n) || ip(n) || rp(n);
        return i && r.push(i), r;
      }, []);
    }
    var Gc = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var Hc = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function Wc(e) {
      var t = Gc.exec(e);
      if (!t)
        return null;
      var r = t[2] && t[2].indexOf("native") === 0, n = t[2] && t[2].indexOf("eval") === 0, i = Hc.exec(t[2]);
      return n && i != null && (t[2] = i[1], t[3] = i[2], t[4] = i[3]), { file: r ? null : t[2], methodName: t[1] || Gt, arguments: r ? [t[2]] : [], lineNumber: t[3] ? +t[3] : null, column: t[4] ? +t[4] : null };
    }
    var zc = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function Yc(e) {
      var t = zc.exec(e);
      return t ? { file: t[2], methodName: t[1] || Gt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
    }
    var Zc = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var Xc = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function ep(e) {
      var t = Zc.exec(e);
      if (!t)
        return null;
      var r = t[3] && t[3].indexOf(" > eval") > -1, n = Xc.exec(t[3]);
      return r && n != null && (t[3] = n[1], t[4] = n[2], t[5] = null), { file: t[3], methodName: t[1] || Gt, arguments: t[2] ? t[2].split(",") : [], lineNumber: t[4] ? +t[4] : null, column: t[5] ? +t[5] : null };
    }
    var tp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function rp(e) {
      var t = tp.exec(e);
      return t ? { file: t[3], methodName: t[1] || Gt, arguments: [], lineNumber: +t[4], column: t[5] ? +t[5] : null } : null;
    }
    var np = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function ip(e) {
      var t = np.exec(e);
      return t ? { file: t[2], methodName: t[1] || Gt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
    }
    var bi = class {
      getLocation() {
        return null;
      }
    };
    var Ei = class {
      constructor() {
        this._error = new Error();
      }
      getLocation() {
        let t = this._error.stack;
        if (!t)
          return null;
        let n = ks(t).find((i) => {
          if (!i.file)
            return false;
          let o = Zn(i.file);
          return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
        });
        return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
      }
    };
    function qe(e) {
      return e === "minimal" ? new bi() : new Ei();
    }
    var Os = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function Et(e = {}) {
      let t = sp(e);
      return Object.entries(t).reduce((n, [i, o]) => (Os[i] !== void 0 ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
    }
    function sp(e = {}) {
      return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
    }
    function Zr(e = {}) {
      return (t) => (typeof e._count == "boolean" && (t._count = t._count._all), t);
    }
    function Ds(e, t) {
      let r = Zr(e);
      return t({ action: "aggregate", unpacker: r, argsMapper: Et })(e);
    }
    function ap(e = {}) {
      let { select: t, ...r } = e;
      return typeof t == "object" ? Et({ ...r, _count: t }) : Et({ ...r, _count: { _all: true } });
    }
    function lp(e = {}) {
      return typeof e.select == "object" ? (t) => Zr(e)(t)._count : (t) => Zr(e)(t)._count._all;
    }
    function _s(e, t) {
      return t({ action: "count", unpacker: lp(e), argsMapper: ap })(e);
    }
    function up(e = {}) {
      let t = Et(e);
      if (Array.isArray(t.by))
        for (let r of t.by)
          typeof r == "string" && (t.select[r] = true);
      else
        typeof t.by == "string" && (t.select[t.by] = true);
      return t;
    }
    function cp(e = {}) {
      return (t) => (typeof e?._count == "boolean" && t.forEach((r) => {
        r._count = r._count._all;
      }), t);
    }
    function Ns(e, t) {
      return t({ action: "groupBy", unpacker: cp(e), argsMapper: up })(e);
    }
    function Ls(e, t, r) {
      if (t === "aggregate")
        return (n) => Ds(n, r);
      if (t === "count")
        return (n) => _s(n, r);
      if (t === "groupBy")
        return (n) => Ns(n, r);
    }
    function $s(e, t) {
      let r = t.fields.filter((i) => !i.relationName), n = oi(r, (i) => i.name);
      return new Proxy({}, { get(i, o) {
        if (o in i || typeof o == "symbol")
          return i[o];
        let s = n[o];
        if (s)
          return new Jt(e, o, s.type, s.isList, s.kind === "enum");
      }, ...Nr(Object.keys(n)) });
    }
    var qs = (e) => Array.isArray(e) ? e : e.split(".");
    var wi = (e, t) => qs(t).reduce((r, n) => r && r[n], e);
    var Vs = (e, t, r) => qs(t).reduceRight((n, i, o, s) => Object.assign({}, wi(e, s.slice(0, o)), { [i]: n }), r);
    function pp(e, t) {
      return e === void 0 || t === void 0 ? [] : [...t, "select", e];
    }
    function dp(e, t, r) {
      return t === void 0 ? e ?? {} : Vs(t, r, e || true);
    }
    function Pi(e, t, r, n, i, o) {
      let a = e._runtimeDataModel.models[t].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
      return (l) => {
        let u = qe(e._errorFormat), c = pp(n, i), p = dp(l, o, c), d = r({ dataPath: c, callsite: u })(p), f = mp(e, t);
        return new Proxy(d, { get(y, g) {
          if (!f.includes(g))
            return y[g];
          let T = [a[g].type, r, g], C = [c, p];
          return Pi(e, ...T, ...C);
        }, ...Nr([...f, ...Object.getOwnPropertyNames(d)]) });
      };
    }
    function mp(e, t) {
      return e._runtimeDataModel.models[t].fields.filter((r) => r.kind === "object").map((r) => r.name);
    }
    var Js = S(Xn());
    var Qs = S(require("fs"));
    var js = { keyword: Oe, entity: Oe, value: (e) => ne(it(e)), punctuation: it, directive: Oe, function: Oe, variable: (e) => ne(it(e)), string: (e) => ne(Qe(e)), boolean: he, number: Oe, comment: vr };
    var fp = (e) => e;
    var Xr = {};
    var gp = 0;
    var v = { manual: Xr.Prism && Xr.Prism.manual, disableWorkerMessageHandler: Xr.Prism && Xr.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
      if (e instanceof ye) {
        let t = e;
        return new ye(t.type, v.util.encode(t.content), t.alias);
      } else
        return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e) {
      return Object.prototype.toString.call(e).slice(8, -1);
    }, objId: function(e) {
      return e.__id || Object.defineProperty(e, "__id", { value: ++gp }), e.__id;
    }, clone: function e(t, r) {
      let n, i, o = v.util.type(t);
      switch (r = r || {}, o) {
        case "Object":
          if (i = v.util.objId(t), r[i])
            return r[i];
          n = {}, r[i] = n;
          for (let s in t)
            t.hasOwnProperty(s) && (n[s] = e(t[s], r));
          return n;
        case "Array":
          return i = v.util.objId(t), r[i] ? r[i] : (n = [], r[i] = n, t.forEach(function(s, a) {
            n[a] = e(s, r);
          }), n);
        default:
          return t;
      }
    } }, languages: { extend: function(e, t) {
      let r = v.util.clone(v.languages[e]);
      for (let n in t)
        r[n] = t[n];
      return r;
    }, insertBefore: function(e, t, r, n) {
      n = n || v.languages;
      let i = n[e], o = {};
      for (let a in i)
        if (i.hasOwnProperty(a)) {
          if (a == t)
            for (let l in r)
              r.hasOwnProperty(l) && (o[l] = r[l]);
          r.hasOwnProperty(a) || (o[a] = i[a]);
        }
      let s = n[e];
      return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
        l === s && a != e && (this[a] = o);
      }), o;
    }, DFS: function e(t, r, n, i) {
      i = i || {};
      let o = v.util.objId;
      for (let s in t)
        if (t.hasOwnProperty(s)) {
          r.call(t, s, t[s], n || s);
          let a = t[s], l = v.util.type(a);
          l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, r, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, r, s, i));
        }
    } }, plugins: {}, highlight: function(e, t, r) {
      let n = { code: e, grammar: t, language: r };
      return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ye.stringify(v.util.encode(n.tokens), n.language);
    }, matchGrammar: function(e, t, r, n, i, o, s) {
      for (let g in r) {
        if (!r.hasOwnProperty(g) || !r[g])
          continue;
        if (g == s)
          return;
        let P = r[g];
        P = v.util.type(P) === "Array" ? P : [P];
        for (let T = 0; T < P.length; ++T) {
          let C = P[T], x = C.inside, R = !!C.lookbehind, ce = !!C.greedy, G = 0, Ue = C.alias;
          if (ce && !C.pattern.global) {
            let $ = C.pattern.toString().match(/[imuy]*$/)[0];
            C.pattern = RegExp(C.pattern.source, $ + "g");
          }
          C = C.pattern || C;
          for (let $ = n, z = i; $ < t.length; z += t[$].length, ++$) {
            let Te = t[$];
            if (t.length > e.length)
              return;
            if (Te instanceof ye)
              continue;
            if (ce && $ != t.length - 1) {
              C.lastIndex = z;
              var p = C.exec(e);
              if (!p)
                break;
              var c = p.index + (R ? p[1].length : 0), d = p.index + p[0].length, a = $, l = z;
              for (let F = t.length; a < F && (l < d || !t[a].type && !t[a - 1].greedy); ++a)
                l += t[a].length, c >= l && (++$, z = l);
              if (t[$] instanceof ye)
                continue;
              u = a - $, Te = e.slice(z, l), p.index -= z;
            } else {
              C.lastIndex = 0;
              var p = C.exec(Te), u = 1;
            }
            if (!p) {
              if (o)
                break;
              continue;
            }
            R && (G = p[1] ? p[1].length : 0);
            var c = p.index + G, p = p[0].slice(G), d = c + p.length, f = Te.slice(0, c), y = Te.slice(d);
            let Y = [$, u];
            f && (++$, z += f.length, Y.push(f));
            let et = new ye(g, x ? v.tokenize(p, x) : p, Ue, p, ce);
            if (Y.push(et), y && Y.push(y), Array.prototype.splice.apply(t, Y), u != 1 && v.matchGrammar(e, t, r, $, z, true, g), o)
              break;
          }
        }
      }
    }, tokenize: function(e, t) {
      let r = [e], n = t.rest;
      if (n) {
        for (let i in n)
          t[i] = n[i];
        delete t.rest;
      }
      return v.matchGrammar(e, r, t, 0, 0, false), r;
    }, hooks: { all: {}, add: function(e, t) {
      let r = v.hooks.all;
      r[e] = r[e] || [], r[e].push(t);
    }, run: function(e, t) {
      let r = v.hooks.all[e];
      if (!(!r || !r.length))
        for (var n = 0, i; i = r[n++]; )
          i(t);
    } }, Token: ye };
    v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
    v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
    v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
    v.languages.js = v.languages.javascript;
    v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
    v.languages.ts = v.languages.typescript;
    function ye(e, t, r, n, i) {
      this.type = e, this.content = t, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!i;
    }
    ye.stringify = function(e, t) {
      return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
        return ye.stringify(r, t);
      }).join("") : yp(e.type)(e.content);
    };
    function yp(e) {
      return js[e] || fp;
    }
    function Bs(e) {
      return hp(e, v.languages.javascript);
    }
    function hp(e, t) {
      return v.tokenize(e, t).map((n) => ye.stringify(n)).join("");
    }
    var Us = S(Ho());
    function Ks(e) {
      return (0, Us.default)(e);
    }
    var en = class e {
      static read(t) {
        let r;
        try {
          r = Qs.default.readFileSync(t, "utf-8");
        } catch {
          return null;
        }
        return e.fromContent(r);
      }
      static fromContent(t) {
        let r = t.split(/\r?\n/);
        return new e(1, r);
      }
      constructor(t, r) {
        this.firstLineNumber = t, this.lines = r;
      }
      get lastLineNumber() {
        return this.firstLineNumber + this.lines.length - 1;
      }
      mapLineAt(t, r) {
        if (t < this.firstLineNumber || t > this.lines.length + this.firstLineNumber)
          return this;
        let n = t - this.firstLineNumber, i = [...this.lines];
        return i[n] = r(i[n]), new e(this.firstLineNumber, i);
      }
      mapLines(t) {
        return new e(this.firstLineNumber, this.lines.map((r, n) => t(r, this.firstLineNumber + n)));
      }
      lineAt(t) {
        return this.lines[t - this.firstLineNumber];
      }
      prependSymbolAt(t, r) {
        return this.mapLines((n, i) => i === t ? `${r} ${n}` : `  ${n}`);
      }
      slice(t, r) {
        let n = this.lines.slice(t - 1, r).join(`
`);
        return new e(t, Ks(n).split(`
`));
      }
      highlight() {
        let t = Bs(this.toString());
        return new e(this.firstLineNumber, t.split(`
`));
      }
      toString() {
        return this.lines.join(`
`);
      }
    };
    var xp = { red: me, gray: vr, dim: ke, bold: ne, underline: te, highlightSource: (e) => e.highlight() };
    var bp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
    function Ep({ callsite: e, message: t, originalMethod: r, isPanic: n, callArguments: i }, o) {
      let s = { functionName: `prisma.${r}()`, message: t, isPanic: n ?? false, callArguments: i };
      if (!e || typeof window < "u" || process.env.NODE_ENV === "production")
        return s;
      let a = e.getLocation();
      if (!a || !a.lineNumber || !a.columnNumber)
        return s;
      let l = Math.max(1, a.lineNumber - 3), u = en.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
      if (u && c) {
        let p = Pp(c), d = wp(c);
        if (!d)
          return s;
        s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (y) => y.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
        let f = String(u.lastLineNumber).length;
        if (s.contextLines = u.mapLines((y, g) => o.gray(String(g).padStart(f)) + " " + y).mapLines((y) => o.dim(y)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
          let y = p + f + 1;
          y += 2, s.callArguments = (0, Js.default)(i, y).slice(y);
        }
      }
      return s;
    }
    function wp(e) {
      let t = Object.keys(pe.ModelAction).join("|"), n = new RegExp(String.raw`\.(${t})\(`).exec(e);
      if (n) {
        let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
        return { code: e.slice(o, i), openingBraceIndex: i };
      }
      return null;
    }
    function Pp(e) {
      let t = 0;
      for (let r = 0; r < e.length; r++) {
        if (e.charAt(r) !== " ")
          return t;
        t++;
      }
      return t;
    }
    function vp({ functionName: e, location: t, message: r, isPanic: n, contextLines: i, callArguments: o }, s) {
      let a = [""], l = t ? " in" : ":";
      if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), t && a.push(s.underline(Tp(t))), i) {
        a.push("");
        let u = [i.toString()];
        o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
      } else
        a.push(""), o && a.push(o), a.push("");
      return a.push(r), a.join(`
`);
    }
    function Tp(e) {
      let t = [e.fileName];
      return e.lineNumber && t.push(String(e.lineNumber)), e.columnNumber && t.push(String(e.columnNumber)), t.join(":");
    }
    function wt(e) {
      let t = e.showColors ? xp : bp, r = Ep(e, t);
      return vp(r, t);
    }
    function Gs(e, t, r, n) {
      return e === pe.ModelAction.findFirstOrThrow || e === pe.ModelAction.findUniqueOrThrow ? Cp(t, r, n) : n;
    }
    function Cp(e, t, r) {
      return async (n) => {
        if ("rejectOnNotFound" in n.args) {
          let o = wt({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
          throw new X(o, { clientVersion: t });
        }
        return await r(n).catch((o) => {
          throw o instanceof U && o.code === "P2025" ? new Ce(`No ${e} found`, t) : o;
        });
      };
    }
    function ve(e) {
      return e.replace(/^./, (t) => t.toLowerCase());
    }
    var Ap = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var Rp = ["aggregate", "count", "groupBy"];
    function vi(e, t) {
      let r = e._extensions.getAllModelExtensions(t) ?? {}, n = [Mp(e, t), Ip(e, t), qt(r), re("name", () => t), re("$name", () => t), re("$parent", () => e._appliedParent)];
      return be({}, n);
    }
    function Mp(e, t) {
      let r = ve(t), n = Object.keys(pe.ModelAction).concat("count");
      return { getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = i, s = (l) => e._request(l);
        s = Gs(o, t, e._clientVersion, s);
        let a = (l) => (u) => {
          let c = qe(e._errorFormat);
          return e._createPrismaPromise((p) => {
            let d = { args: u, dataPath: [], action: o, model: t, clientMethod: `${r}.${i}`, jsModelName: r, transaction: p, callsite: c };
            return s({ ...d, ...l });
          });
        };
        return Ap.includes(o) ? Pi(e, t, a) : Sp(i) ? Ls(e, i, a) : a({});
      } };
    }
    function Sp(e) {
      return Rp.includes(e);
    }
    function Ip(e, t) {
      return He(re("fields", () => {
        let r = e._runtimeDataModel.models[t];
        return $s(t, r);
      }));
    }
    function Hs(e) {
      return e.replace(/^./, (t) => t.toUpperCase());
    }
    var Ti = Symbol();
    function Ht(e) {
      let t = [Fp(e), re(Ti, () => e), re("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
      return r && t.push(qt(r)), be(e, t);
    }
    function Fp(e) {
      let t = Object.keys(e._runtimeDataModel.models), r = t.map(ve), n = [...new Set(t.concat(r))];
      return He({ getKeys() {
        return n;
      }, getPropertyValue(i) {
        let o = Hs(i);
        if (e._runtimeDataModel.models[o] !== void 0)
          return vi(e, o);
        if (e._runtimeDataModel.models[i] !== void 0)
          return vi(e, i);
      }, getPropertyDescriptor(i) {
        if (!r.includes(i))
          return { enumerable: false };
      } });
    }
    function tn(e) {
      return e[Ti] ? e[Ti] : e;
    }
    function Ws(e) {
      if (typeof e == "function")
        return e(this);
      let t = tn(this), r = Object.create(t, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: void 0 }, $on: { value: void 0 } });
      return Ht(r);
    }
    function zs({ result: e, modelName: t, select: r, extensions: n }) {
      let i = n.getAllComputedFields(t);
      if (!i)
        return e;
      let o = [], s = [];
      for (let a of Object.values(i)) {
        if (r) {
          if (!r[a.name])
            continue;
          let l = a.needs.filter((u) => !r[u]);
          l.length > 0 && s.push(Vt(l));
        }
        kp(e, a.needs) && o.push(Op(a, be(e, o)));
      }
      return o.length > 0 || s.length > 0 ? be(e, [...o, ...s]) : e;
    }
    function kp(e, t) {
      return t.every((r) => ii(e, r));
    }
    function Op(e, t) {
      return He(re(e.name, () => e.compute(t)));
    }
    function rn({ visitor: e, result: t, args: r, runtimeDataModel: n, modelName: i }) {
      if (Array.isArray(t)) {
        for (let s = 0; s < t.length; s++)
          t[s] = rn({ result: t[s], args: r, modelName: i, runtimeDataModel: n, visitor: e });
        return t;
      }
      let o = e(t, i, r) ?? t;
      return r.include && Ys({ includeOrSelect: r.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), r.select && Ys({ includeOrSelect: r.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
    }
    function Ys({ includeOrSelect: e, result: t, parentModelName: r, runtimeDataModel: n, visitor: i }) {
      for (let [o, s] of Object.entries(e)) {
        if (!s || t[o] == null)
          continue;
        let l = n.models[r].fields.find((c) => c.name === o);
        if (!l || l.kind !== "object" || !l.relationName)
          continue;
        let u = typeof s == "object" ? s : {};
        t[o] = rn({ visitor: i, result: t[o], args: u, modelName: l.type, runtimeDataModel: n });
      }
    }
    function Zs({ result: e, modelName: t, args: r, extensions: n, runtimeDataModel: i }) {
      return n.isEmpty() || e == null || typeof e != "object" || !i.models[t] ? e : rn({ result: e, args: r ?? {}, modelName: t, runtimeDataModel: i, visitor: (s, a, l) => zs({ result: s, modelName: ve(a), select: l.select, extensions: n }) });
    }
    function Xs(e) {
      if (e instanceof oe)
        return Dp(e);
      if (Array.isArray(e)) {
        let r = [e[0]];
        for (let n = 1; n < e.length; n++)
          r[n] = Wt(e[n]);
        return r;
      }
      let t = {};
      for (let r in e)
        t[r] = Wt(e[r]);
      return t;
    }
    function Dp(e) {
      return new oe(e.strings, e.values);
    }
    function Wt(e) {
      if (typeof e != "object" || e == null || e instanceof Ae || ht(e))
        return e;
      if (yt(e))
        return new we(e.toFixed());
      if (mt(e))
        return /* @__PURE__ */ new Date(+e);
      if (ArrayBuffer.isView(e))
        return e.slice(0);
      if (Array.isArray(e)) {
        let t = e.length, r;
        for (r = Array(t); t--; )
          r[t] = Wt(e[t]);
        return r;
      }
      if (typeof e == "object") {
        let t = {};
        for (let r in e)
          r === "__proto__" ? Object.defineProperty(t, r, { value: Wt(e[r]), configurable: true, enumerable: true, writable: true }) : t[r] = Wt(e[r]);
        return t;
      }
      Ge(e, "Unknown value");
    }
    function ta(e, t, r, n = 0) {
      return e._createPrismaPromise((i) => {
        let o = t.customDataProxyFetch;
        return "transaction" in t && i !== void 0 && (t.transaction?.kind === "batch" && t.transaction.lock.then(), t.transaction = i), n === r.length ? e._executeRequest(t) : r[n]({ model: t.model, operation: t.model ? t.action : t.clientMethod, args: Xs(t.args ?? {}), __internalParams: t, query: (s, a = t) => {
          let l = a.customDataProxyFetch;
          return a.customDataProxyFetch = oa(o, l), a.args = s, ta(e, a, r, n + 1);
        } });
      });
    }
    function ra(e, t) {
      let { jsModelName: r, action: n, clientMethod: i } = t, o = r ? n : i;
      if (e._extensions.isEmpty())
        return e._executeRequest(t);
      let s = e._extensions.getAllQueryCallbacks(r ?? "$none", o);
      return ta(e, t, s);
    }
    function na(e) {
      return (t) => {
        let r = { requests: t }, n = t[0].extensions.getAllBatchQueryCallbacks();
        return n.length ? ia(r, n, 0, e) : e(r);
      };
    }
    function ia(e, t, r, n) {
      if (r === t.length)
        return n(e);
      let i = e.customDataProxyFetch, o = e.requests[0].transaction;
      return t[r]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : void 0 } : void 0 }, __internalParams: e, query(s, a = e) {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = oa(i, l), ia(a, t, r + 1, n);
      } });
    }
    var ea = (e) => e;
    function oa(e = ea, t = ea) {
      return (r) => e(t(r));
    }
    function aa(e, t, r) {
      let n = ve(r);
      return !t.result || !(t.result.$allModels || t.result[n]) ? e : _p({ ...e, ...sa(t.name, e, t.result.$allModels), ...sa(t.name, e, t.result[n]) });
    }
    function _p(e) {
      let t = new xe(), r = (n, i) => t.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => r(o, i)) : [n]));
      return ct(e, (n) => ({ ...n, needs: r(n.name, /* @__PURE__ */ new Set()) }));
    }
    function sa(e, t, r) {
      return r ? ct(r, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Np(t, o, i) })) : {};
    }
    function Np(e, t, r) {
      let n = e?.[t]?.compute;
      return n ? (i) => r({ ...i, [t]: n(i) }) : r;
    }
    function la(e, t) {
      if (!t)
        return e;
      let r = { ...e };
      for (let n of Object.values(t))
        if (e[n.name])
          for (let i of n.needs)
            r[i] = true;
      return r;
    }
    var nn = class {
      constructor(t, r) {
        this.extension = t;
        this.previous = r;
        this.computedFieldsCache = new xe();
        this.modelExtensionsCache = new xe();
        this.queryCallbacksCache = new xe();
        this.clientExtensions = $t(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
        this.batchCallbacks = $t(() => {
          let t2 = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
          return r2 ? t2.concat(r2) : t2;
        });
      }
      getAllComputedFields(t) {
        return this.computedFieldsCache.getOrCreate(t, () => aa(this.previous?.getAllComputedFields(t), this.extension, t));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(t) {
        return this.modelExtensionsCache.getOrCreate(t, () => {
          let r = ve(t);
          return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t) : { ...this.previous?.getAllModelExtensions(t), ...this.extension.model.$allModels, ...this.extension.model[r] };
        });
      }
      getAllQueryCallbacks(t, r) {
        return this.queryCallbacksCache.getOrCreate(`${t}:${r}`, () => {
          let n = this.previous?.getAllQueryCallbacks(t, r) ?? [], i = [], o = this.extension.query;
          return !o || !(o[t] || o.$allModels || o[r] || o.$allOperations) ? n : (o[t] !== void 0 && (o[t][r] !== void 0 && i.push(o[t][r]), o[t].$allOperations !== void 0 && i.push(o[t].$allOperations)), t !== "$none" && o.$allModels !== void 0 && (o.$allModels[r] !== void 0 && i.push(o.$allModels[r]), o.$allModels.$allOperations !== void 0 && i.push(o.$allModels.$allOperations)), o[r] !== void 0 && i.push(o[r]), o.$allOperations !== void 0 && i.push(o.$allOperations), n.concat(i));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var on = class e {
      constructor(t) {
        this.head = t;
      }
      static empty() {
        return new e();
      }
      static single(t) {
        return new e(new nn(t));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(t) {
        return new e(new nn(t, this.head));
      }
      getAllComputedFields(t) {
        return this.head?.getAllComputedFields(t);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(t) {
        return this.head?.getAllModelExtensions(t);
      }
      getAllQueryCallbacks(t, r) {
        return this.head?.getAllQueryCallbacks(t, r) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    var ua = D("prisma:client");
    var ca = { Vercel: "vercel", "Netlify CI": "netlify" };
    function pa({ postinstall: e, ciName: t, clientVersion: r }) {
      if (ua("checkPlatformCaching:postinstall", e), ua("checkPlatformCaching:ciName", t), e === true && t && t in ca) {
        let n = `Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ca[t]}-build`;
        throw console.error(n), new k(n, r);
      }
    }
    function da(e, t) {
      return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t[0]]: { url: e.datasourceUrl } } : {} : {};
    }
    function zt({ error: e, user_facing_error: t }, r) {
      return t.error_code ? new U(t.message, { code: t.error_code, clientVersion: r, meta: t.meta, batchRequestIdx: t.batch_request_idx }) : new K(e, { clientVersion: r, batchRequestIdx: t.batch_request_idx });
    }
    var Pt = class {
    };
    var ha = S(require("fs"));
    var Yt = S(require("path"));
    function sn(e) {
      let { runtimeBinaryTarget: t } = e;
      return `Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Lp(e)}`;
    }
    function Lp(e) {
      let { generator: t, generatorBinaryTargets: r, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...r, i];
      return ti({ ...t, binaryTargets: o });
    }
    function Ve(e) {
      let { runtimeBinaryTarget: t } = e;
      return `Prisma Client could not locate the Query Engine for runtime "${t}".`;
    }
    function je(e) {
      let { searchedLocations: t } = e;
      return `The following locations have been searched:
${[...new Set(t)].map((i) => `  ${i}`).join(`
`)}`;
    }
    function ma(e) {
      let { runtimeBinaryTarget: t } = e;
      return `${Ve(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".
${sn(e)}

${je(e)}`;
    }
    function an(e) {
      return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
    }
    function fa(e) {
      let { queryEngineName: t } = e;
      return `${Ve(e)}

This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.
Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".

${an("engine-not-found-bundler-investigation")}

${je(e)}`;
    }
    function ga(e) {
      let { runtimeBinaryTarget: t, generatorBinaryTargets: r } = e, n = r.find((i) => i.native);
      return `${Ve(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${t}".
${sn(e)}

${je(e)}`;
    }
    function ya(e) {
      let { queryEngineName: t } = e;
      return `${Ve(e)}

This is likely caused by tooling that has not copied "${t}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".

${an("engine-not-found-tooling-investigation")}

${je(e)}`;
    }
    var $p = D("prisma:client:engines:resolveEnginePath");
    var qp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
    async function xa(e, t) {
      let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t.prismaPath;
      if (r !== void 0)
        return r;
      let { enginePath: n, searchedLocations: i } = await Vp(e, t);
      if ($p("enginePath", n), n !== void 0 && e === "binary" && zn(n), n !== void 0)
        return t.prismaPath = n;
      let o = await lt(), s = t.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = __filename.match(qp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: t.generator, runtimeBinaryTarget: o, queryEngineName: ba(e, o), expectedLocation: Yt.default.relative(process.cwd(), t.dirname) }, p;
      throw a && l ? p = ga(c) : l ? p = ma(c) : u ? p = fa(c) : p = ya(c), new k(p, t.clientVersion);
    }
    async function Vp(engineType, config) {
      let binaryTarget = await lt(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, Yt.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Yt.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
      __filename.includes("resolveEnginePath") && searchLocations.push(zo());
      for (let e of searchLocations) {
        let t = ba(engineType, binaryTarget), r = Yt.default.join(e, t);
        if (searchedLocations.push(e), ha.default.existsSync(r))
          return { enginePath: r, searchedLocations };
      }
      return { enginePath: void 0, searchedLocations };
    }
    function ba(e, t) {
      return e === "library" ? Nn(t, "fs") : `query-engine-${t}${t === "windows" ? ".exe" : ""}`;
    }
    function ln(e, t) {
      return { batch: e, transaction: t?.kind === "batch" ? { isolationLevel: t.options.isolationLevel } : void 0 };
    }
    var Ci = S(ni());
    function Ea(e) {
      return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t) => `${t[0]}5`) : "";
    }
    function wa(e) {
      return e.split(`
`).map((t) => t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    var Pa = S(is());
    function va({ title: e, user: t = "prisma", repo: r = "prisma", template: n = "bug_report.md", body: i }) {
      return (0, Pa.default)({ user: t, repo: r, template: n, title: e, body: i });
    }
    function Ta({ version: e, platform: t, title: r, description: n, engineVersion: i, database: o, query: s }) {
      let a = mo(6e3 - (s?.length ?? 0)), l = wa((0, Ci.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Ci.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? Ea(s) : ""}
\`\`\`
`), p = va({ title: r, body: c });
      return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${te(p)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    function un({ inlineDatasources: e, overrideDatasources: t, env: r, clientVersion: n }) {
      let i, o = Object.keys(e)[0], s = e[o]?.url, a = t[o]?.url;
      if (o === void 0 ? i = void 0 : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = r[s.fromEnvVar]), s?.fromEnvVar !== void 0 && i === void 0)
        throw new k(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
      if (i === void 0)
        throw new k("error: Missing URL environment variable, value, or override.", n);
      return i;
    }
    var cn = class extends Error {
      constructor(r, n) {
        super(r);
        this.clientVersion = n.clientVersion, this.cause = n.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var ae = class extends cn {
      constructor(r, n) {
        super(r, n);
        this.isRetryable = n.isRetryable ?? true;
      }
    };
    function M(e, t) {
      return { ...e, isRetryable: t };
    }
    var vt = class extends ae {
      constructor(r) {
        super("This request must be retried", M(r, true));
        this.name = "ForcedRetryError";
        this.code = "P5001";
      }
    };
    E(vt, "ForcedRetryError");
    var ze = class extends ae {
      constructor(r, n) {
        super(r, M(n, false));
        this.name = "InvalidDatasourceError";
        this.code = "P5002";
      }
    };
    E(ze, "InvalidDatasourceError");
    var Ye = class extends ae {
      constructor(r, n) {
        super(r, M(n, false));
        this.name = "NotImplementedYetError";
        this.code = "P5004";
      }
    };
    E(Ye, "NotImplementedYetError");
    var L = class extends ae {
      constructor(r, n) {
        super(r, n);
        this.response = n.response;
        let i = this.response.headers.get("prisma-request-id");
        if (i) {
          let o = `(The request id was: ${i})`;
          this.message = this.message + " " + o;
        }
      }
    };
    var Ze = class extends L {
      constructor(r) {
        super("Schema needs to be uploaded", M(r, true));
        this.name = "SchemaMissingError";
        this.code = "P5005";
      }
    };
    E(Ze, "SchemaMissingError");
    var Ai = "This request could not be understood by the server";
    var Zt = class extends L {
      constructor(r, n, i) {
        super(n || Ai, M(r, false));
        this.name = "BadRequestError";
        this.code = "P5000";
        i && (this.code = i);
      }
    };
    E(Zt, "BadRequestError");
    var Xt = class extends L {
      constructor(r, n) {
        super("Engine not started: healthcheck timeout", M(r, true));
        this.name = "HealthcheckTimeoutError";
        this.code = "P5013";
        this.logs = n;
      }
    };
    E(Xt, "HealthcheckTimeoutError");
    var er = class extends L {
      constructor(r, n, i) {
        super(n, M(r, true));
        this.name = "EngineStartupError";
        this.code = "P5014";
        this.logs = i;
      }
    };
    E(er, "EngineStartupError");
    var tr = class extends L {
      constructor(r) {
        super("Engine version is not supported", M(r, false));
        this.name = "EngineVersionNotSupportedError";
        this.code = "P5012";
      }
    };
    E(tr, "EngineVersionNotSupportedError");
    var Ri = "Request timed out";
    var rr = class extends L {
      constructor(r, n = Ri) {
        super(n, M(r, false));
        this.name = "GatewayTimeoutError";
        this.code = "P5009";
      }
    };
    E(rr, "GatewayTimeoutError");
    var jp = "Interactive transaction error";
    var nr = class extends L {
      constructor(r, n = jp) {
        super(n, M(r, false));
        this.name = "InteractiveTransactionError";
        this.code = "P5015";
      }
    };
    E(nr, "InteractiveTransactionError");
    var Bp = "Request parameters are invalid";
    var ir = class extends L {
      constructor(r, n = Bp) {
        super(n, M(r, false));
        this.name = "InvalidRequestError";
        this.code = "P5011";
      }
    };
    E(ir, "InvalidRequestError");
    var Mi = "Requested resource does not exist";
    var or = class extends L {
      constructor(r, n = Mi) {
        super(n, M(r, false));
        this.name = "NotFoundError";
        this.code = "P5003";
      }
    };
    E(or, "NotFoundError");
    var Si = "Unknown server error";
    var Tt = class extends L {
      constructor(r, n, i) {
        super(n || Si, M(r, true));
        this.name = "ServerError";
        this.code = "P5006";
        this.logs = i;
      }
    };
    E(Tt, "ServerError");
    var Ii = "Unauthorized, check your connection string";
    var sr = class extends L {
      constructor(r, n = Ii) {
        super(n, M(r, false));
        this.name = "UnauthorizedError";
        this.code = "P5007";
      }
    };
    E(sr, "UnauthorizedError");
    var Fi = "Usage exceeded, retry again later";
    var ar = class extends L {
      constructor(r, n = Fi) {
        super(n, M(r, true));
        this.name = "UsageExceededError";
        this.code = "P5008";
      }
    };
    E(ar, "UsageExceededError");
    async function Up(e) {
      let t;
      try {
        t = await e.text();
      } catch {
        return { type: "EmptyError" };
      }
      try {
        let r = JSON.parse(t);
        if (typeof r == "string")
          switch (r) {
            case "InternalDataProxyError":
              return { type: "DataProxyError", body: r };
            default:
              return { type: "UnknownTextError", body: r };
          }
        if (typeof r == "object" && r !== null) {
          if ("is_panic" in r && "message" in r && "error_code" in r)
            return { type: "QueryEngineError", body: r };
          if ("EngineNotStarted" in r || "InteractiveTransactionMisrouted" in r || "InvalidRequestError" in r) {
            let n = Object.values(r)[0].reason;
            return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
          }
        }
        return { type: "UnknownJsonError", body: r };
      } catch {
        return t === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t };
      }
    }
    async function lr(e, t) {
      if (e.ok)
        return;
      let r = { clientVersion: t, response: e }, n = await Up(e);
      if (n.type === "QueryEngineError")
        throw new U(n.body.message, { code: n.body.error_code, clientVersion: t });
      if (n.type === "DataProxyError") {
        if (n.body === "InternalDataProxyError")
          throw new Tt(r, "Internal Data Proxy error");
        if ("EngineNotStarted" in n.body) {
          if (n.body.EngineNotStarted.reason === "SchemaMissing")
            return new Ze(r);
          if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
            throw new tr(r);
          if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
            throw new er(r, i, o);
          }
          if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
            let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
            throw new k(i, t, o);
          }
          if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
            let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
            throw new Xt(r, i);
          }
        }
        if ("InteractiveTransactionMisrouted" in n.body) {
          let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
          throw new nr(r, i[n.body.InteractiveTransactionMisrouted.reason]);
        }
        if ("InvalidRequestError" in n.body)
          throw new ir(r, n.body.InvalidRequestError.reason);
      }
      if (e.status === 401 || e.status === 403)
        throw new sr(r, Ct(Ii, n));
      if (e.status === 404)
        return new or(r, Ct(Mi, n));
      if (e.status === 429)
        throw new ar(r, Ct(Fi, n));
      if (e.status === 504)
        throw new rr(r, Ct(Ri, n));
      if (e.status >= 500)
        throw new Tt(r, Ct(Si, n));
      if (e.status >= 400)
        throw new Zt(r, Ct(Ai, n));
    }
    function Ct(e, t) {
      return t.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t)}`;
    }
    function Ca(e) {
      let t = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t) - Math.ceil(t / 2), n = t + r;
      return new Promise((i) => setTimeout(() => i(n), n));
    }
    function Aa(e) {
      if (!!e.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
        throw new k("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
    }
    var Ra = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.3.1-2.61e140623197a131c2a6189271ffee05a7aa9a59", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.75", "@swc/jest": "0.2.29", "@types/jest": "29.5.4", "@types/node": "18.17.12", execa: "5.1.1", jest: "29.6.4", typescript: "5.2.2" };
    var ur = class extends ae {
      constructor(r, n) {
        super(`Cannot fetch data from service:
${r}`, M(n, true));
        this.name = "RequestError";
        this.code = "P5010";
      }
    };
    E(ur, "RequestError");
    async function Xe(e, t, r = (n) => n) {
      let n = t.clientVersion;
      try {
        return typeof fetch == "function" ? await r(fetch)(e, t) : await r(ki)(e, t);
      } catch (i) {
        console.log(e);
        let o = i.message ?? "Unknown error";
        throw new ur(o, { clientVersion: n });
      }
    }
    function Qp(e) {
      return { ...e.headers, "Content-Type": "application/json" };
    }
    function Jp(e) {
      return { method: e.method, headers: Qp(e) };
    }
    function Gp(e, t) {
      return { text: () => Promise.resolve(Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e).toString())), ok: t.statusCode >= 200 && t.statusCode <= 299, status: t.statusCode, url: t.url, headers: new Oi(t.headers) };
    }
    async function ki(e, t = {}) {
      let r = Hp("https"), n = Jp(t), i = [], { origin: o } = new URL(e);
      return new Promise((s, a) => {
        let l = r.request(e, n, (u) => {
          let { statusCode: c, headers: { location: p } } = u;
          c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(ki(`${o}${p}`, t)) : s(ki(p, t))), u.on("data", (d) => i.push(d)), u.on("end", () => s(Gp(i, u))), u.on("error", a);
        });
        l.on("error", a), l.end(t.body ?? "");
      });
    }
    var Hp = typeof require < "u" ? require : () => {
    };
    var Oi = class {
      constructor(t = {}) {
        this.headers = /* @__PURE__ */ new Map();
        for (let [r, n] of Object.entries(t))
          if (typeof n == "string")
            this.headers.set(r, n);
          else if (Array.isArray(n))
            for (let i of n)
              this.headers.set(r, i);
      }
      append(t, r) {
        this.headers.set(t, r);
      }
      delete(t) {
        this.headers.delete(t);
      }
      get(t) {
        return this.headers.get(t) ?? null;
      }
      has(t) {
        return this.headers.has(t);
      }
      set(t, r) {
        this.headers.set(t, r);
      }
      forEach(t, r) {
        for (let [n, i] of this.headers)
          t.call(r, i, n, this);
      }
    };
    var Wp = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var Ma = D("prisma:client:dataproxyEngine");
    async function zp(e, t) {
      let r = Ra["@prisma/engines-version"], n = t.clientVersion ?? "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
        return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
        return n;
      let [i, o] = n?.split("-") ?? [];
      if (o === void 0 && Wp.test(i))
        return i;
      if (o !== void 0 || n === "0.0.0" || n === "in-memory") {
        if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
          return "0.0.0";
        let [s] = r.split("-") ?? [], [a, l, u] = s.split("."), c = Yp(`<=${a}.${l}.${u}`), p = await Xe(c, { clientVersion: n });
        if (!p.ok)
          throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
        let d = await p.text();
        Ma("length of body fetched from unpkg.com", d.length);
        let f;
        try {
          f = JSON.parse(d);
        } catch (y) {
          throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), y;
        }
        return f.version;
      }
      throw new Ye("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
    }
    async function Sa(e, t) {
      let r = await zp(e, t);
      return Ma("version", r), r;
    }
    function Yp(e) {
      return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
    }
    var Ia = 3;
    var Di = D("prisma:client:dataproxyEngine");
    var _i = class {
      constructor({ apiKey: t, tracingHelper: r, logLevel: n, logQueries: i }) {
        this.apiKey = t, this.tracingHelper = r, this.logLevel = n, this.logQueries = i;
      }
      build({ traceparent: t, interactiveTransaction: r } = {}) {
        let n = { Authorization: `Bearer ${this.apiKey}` };
        this.tracingHelper.isEnabled() && (n.traceparent = t ?? this.tracingHelper.getTraceParent()), r && (n["X-transaction-id"] = r.id);
        let i = this.buildCaptureSettings();
        return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
      }
      buildCaptureSettings() {
        let t = [];
        return this.tracingHelper.isEnabled() && t.push("tracing"), this.logLevel && t.push(this.logLevel), this.logQueries && t.push("query"), t;
      }
    };
    var cr = class extends Pt {
      constructor(r) {
        super();
        Aa(r), this.config = r, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = r.inlineSchema ?? "", this.inlineDatasources = r.inlineDatasources ?? {}, this.inlineSchemaHash = r.inlineSchemaHash ?? "", this.clientVersion = r.clientVersion ?? "unknown", this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
      }
      apiKey() {
        return this.headerBuilder.apiKey;
      }
      version() {
        return "unknown";
      }
      async start() {
        this.startPromise !== void 0 && await this.startPromise, this.startPromise = (async () => {
          let [r, n] = this.extractHostAndApiKey();
          this.host = r, this.headerBuilder = new _i({ apiKey: n, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries }), this.remoteClientVersion = await Sa(r, this.config), Di("host", this.host);
        })(), await this.startPromise;
      }
      async stop() {
      }
      propagateResponseExtensions(r) {
        r?.logs?.length && r.logs.forEach((n) => {
          switch (n.level) {
            case "debug":
            case "error":
            case "trace":
            case "warn":
            case "info":
              break;
            case "query": {
              let i = typeof n.attributes.query == "string" ? n.attributes.query : "";
              if (!this.tracingHelper.isEnabled()) {
                let [o] = i.split("/* traceparent");
                i = o;
              }
              this.logEmitter.emit("query", { query: i, timestamp: n.timestamp, duration: n.attributes.duration_ms, params: n.attributes.params, target: n.attributes.target });
            }
          }
        }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
      }
      on(r, n) {
        if (r === "beforeExit")
          throw new Error('"beforeExit" hook is not applicable to the remote query engine');
        this.logEmitter.on(r, n);
      }
      async url(r) {
        return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
      }
      async uploadSchema() {
        let r = { name: "schemaUpload", internal: true };
        return this.tracingHelper.runInChildSpan(r, async () => {
          let n = await Xe(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
          n.ok || Di("schema response status", n.status);
          let i = await lr(n, this.clientVersion);
          if (i)
            throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${i.message}` }), i;
          this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
        });
      }
      request(r, { traceparent: n, interactiveTransaction: i, customDataProxyFetch: o }) {
        return this.requestInternal({ body: r, traceparent: n, interactiveTransaction: i, customDataProxyFetch: o });
      }
      async requestBatch(r, { traceparent: n, transaction: i, customDataProxyFetch: o }) {
        let s = i?.kind === "itx" ? i.options : void 0, a = ln(r, i), { batchResult: l, elapsed: u } = await this.requestInternal({ body: a, customDataProxyFetch: o, interactiveTransaction: s, traceparent: n });
        return l.map((c) => "errors" in c && c.errors.length > 0 ? zt(c.errors[0], this.clientVersion) : { data: c, elapsed: u });
      }
      requestInternal({ body: r, traceparent: n, customDataProxyFetch: i, interactiveTransaction: o }) {
        return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s }) => {
          let a = o ? `${o.payload.endpoint}/graphql` : await this.url("graphql");
          s(a);
          let l = await Xe(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n, interactiveTransaction: o }), body: JSON.stringify(r), clientVersion: this.clientVersion }, i);
          l.ok || Di("graphql response status", l.status), await this.handleError(await lr(l, this.clientVersion));
          let u = await l.json(), c = u.extensions;
          if (c && this.propagateResponseExtensions(c), u.errors)
            throw u.errors.length === 1 ? zt(u.errors[0], this.config.clientVersion) : new K(u.errors, { clientVersion: this.config.clientVersion });
          return u;
        } });
      }
      async transaction(r, n, i) {
        let o = { start: "starting", commit: "committing", rollback: "rolling back" };
        return this.withRetry({ actionGerund: `${o[r]} transaction`, callback: async ({ logHttpCall: s }) => {
          if (r === "start") {
            let a = JSON.stringify({ max_wait: i?.maxWait ?? 2e3, timeout: i?.timeout ?? 5e3, isolation_level: i?.isolationLevel }), l = await this.url("transaction/start");
            s(l);
            let u = await Xe(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), body: a, clientVersion: this.clientVersion });
            await this.handleError(await lr(u, this.clientVersion));
            let c = await u.json(), p = c.extensions;
            p && this.propagateResponseExtensions(p);
            let d = c.id, f = c["data-proxy"].endpoint;
            return { id: d, payload: { endpoint: f } };
          } else {
            let a = `${i.payload.endpoint}/${r}`;
            s(a);
            let l = await Xe(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), clientVersion: this.clientVersion });
            await this.handleError(await lr(l, this.clientVersion));
            let c = (await l.json()).extensions;
            c && this.propagateResponseExtensions(c);
            return;
          }
        } });
      }
      extractHostAndApiKey() {
        let r = { clientVersion: this.clientVersion }, n = Object.keys(this.inlineDatasources)[0], i = un({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), o;
        try {
          o = new URL(i);
        } catch {
          throw new ze(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
        }
        let { protocol: s, host: a, searchParams: l } = o;
        if (s !== "prisma:")
          throw new ze(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
        let u = l.get("api_key");
        if (u === null || u.length < 1)
          throw new ze(`Error validating datasource \`${n}\`: the URL must contain a valid API key`, r);
        return [a, u];
      }
      metrics() {
        throw new Ye("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
      }
      async withRetry(r) {
        for (let n = 0; ; n++) {
          let i = (o) => {
            this.logEmitter.emit("info", { message: `Calling ${o} (n=${n})` });
          };
          try {
            return await r.callback({ logHttpCall: i });
          } catch (o) {
            if (!(o instanceof ae) || !o.isRetryable)
              throw o;
            if (n >= Ia)
              throw o instanceof vt ? o.cause : o;
            this.logEmitter.emit("warn", { message: `Attempt ${n + 1}/${Ia} failed for ${r.actionGerund}: ${o.message ?? "(unknown)"}` });
            let s = await Ca(n);
            this.logEmitter.emit("warn", { message: `Retrying after ${s}ms` });
          }
        }
      }
      async handleError(r) {
        if (r instanceof Ze)
          throw await this.uploadSchema(), new vt({ clientVersion: this.clientVersion, cause: r });
        if (r)
          throw r;
      }
    };
    var _a = S(require("fs"));
    function Fa(e) {
      if (e?.kind === "itx")
        return e.options.id;
    }
    var Li = S(require("os"));
    var ka = S(require("path"));
    var Ni = Symbol("PrismaLibraryEngineCache");
    function Zp() {
      let e = globalThis;
      return e[Ni] === void 0 && (e[Ni] = {}), e[Ni];
    }
    function Xp(e) {
      let t = Zp();
      if (t[e] !== void 0)
        return t[e];
      let r = ka.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
      return process.platform !== "win32" && (i = Li.default.constants.dlopen.RTLD_LAZY | Li.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, r, i), t[e] = n.exports, n.exports;
    }
    var pn = class {
      constructor(t) {
        this.config = t;
      }
      async loadLibrary() {
        let t = await Bn(), r = await xa("library", this.config);
        try {
          return this.config.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => Xp(r));
        } catch (n) {
          let i = Yn({ e: n, platformInfo: t, id: r });
          throw new k(i, this.config.clientVersion);
        }
      }
    };
    var Me = D("prisma:client:libraryEngine");
    function ed(e) {
      return e.item_type === "query" && "query" in e;
    }
    function td(e) {
      return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
    }
    var Oa = [...Un, "native"];
    var Da = 0;
    var pr = class extends Pt {
      constructor(r, n = new pn(r)) {
        super();
        try {
          this.datamodel = _a.default.readFileSync(r.datamodelPath, "utf-8");
        } catch (s) {
          throw s.stack.match(/\/\.next|\/next@|\/next\//) ? new k(`Your schema.prisma could not be found, and we detected that you are using Next.js.
Find out why and learn how to fix this: https://pris.ly/d/schema-not-found-nextjs`, r.clientVersion) : r.isBundled === true ? new k("Prisma Client could not find its `schema.prisma`. This is likely caused by a bundling step, which leads to `schema.prisma` not being copied near the resulting bundle. We would appreciate if you could take the time to share some information with us.\nPlease help us by answering a few questions: https://pris.ly/bundler-investigation-error", r.clientVersion) : s;
        }
        this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.libraryLoader = n, this.logEmitter = r.logEmitter, r.enableDebugLogs && (this.logLevel = "debug");
        let i = Object.keys(r.overrideDatasources)[0], o = r.overrideDatasources[i]?.url;
        i !== void 0 && o !== void 0 && (this.datasourceOverrides = { [i]: o }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
      }
      checkForTooManyEngines() {
        Da === 10 && console.warn(`${he("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
      }
      async transaction(r, n, i) {
        await this.start();
        let o = JSON.stringify(n), s;
        if (r === "start") {
          let l = JSON.stringify({ max_wait: i?.maxWait ?? 2e3, timeout: i?.timeout ?? 5e3, isolation_level: i?.isolationLevel });
          s = await this.engine?.startTransaction(l, o);
        } else
          r === "commit" ? s = await this.engine?.commitTransaction(i.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(i.id, o));
        let a = this.parseEngineResponse(s);
        if (a.error_code)
          throw new U(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
        return a;
      }
      async instantiateLibrary() {
        if (Me("internalSetup"), this.libraryInstantiationPromise)
          return this.libraryInstantiationPromise;
        _n(), this.platform = await this.getPlatform(), await this.loadEngine(), this.version();
      }
      async getPlatform() {
        if (this.platform)
          return this.platform;
        let r = await lt();
        if (!Oa.includes(r))
          throw new k(`Unknown ${me("PRISMA_QUERY_ENGINE_LIBRARY")} ${me(ne(r))}. Possible binaryTargets: ${Qe(Oa.join(", "))} or a path to the query engine library.
You may have to run ${Qe("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return r;
      }
      parseEngineResponse(r) {
        if (!r)
          throw new K("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
        try {
          return JSON.parse(r);
        } catch {
          throw new K("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
        }
      }
      async loadEngine() {
        if (!this.engine) {
          this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(), this.QueryEngineConstructor = this.library.QueryEngine);
          try {
            let r = new WeakRef(this);
            this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n) => {
              r.deref()?.logger(n);
            }), Da++;
          } catch (r) {
            let n = r, i = this.parseInitError(n.message);
            throw typeof i == "string" ? n : new k(i.message, this.config.clientVersion, i.error_code);
          }
        }
      }
      logger(r) {
        let n = this.parseEngineResponse(r);
        if (n) {
          if ("span" in n) {
            this.config.tracingHelper.createEngineSpan(n);
            return;
          }
          n.level = n?.level.toLowerCase() ?? "unknown", ed(n) ? this.logEmitter.emit("query", { timestamp: /* @__PURE__ */ new Date(), query: n.query, params: n.params, duration: Number(n.duration_ms), target: n.module_path }) : td(n) ? this.loggerRustPanic = new ue(this.getErrorMessageWithLink(`${n.message}: ${n.reason} in ${n.file}:${n.line}:${n.column}`), this.config.clientVersion) : this.logEmitter.emit(n.level, { timestamp: /* @__PURE__ */ new Date(), message: n.message, target: n.module_path });
        }
      }
      getErrorMessageWithLink(r) {
        return Ta({ platform: this.platform, title: r, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
      }
      parseInitError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      parseRequestError(r) {
        try {
          return JSON.parse(r);
        } catch {
        }
        return r;
      }
      on(r, n) {
        if (r === "beforeExit")
          throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
        this.logEmitter.on(r, n);
      }
      async start() {
        if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
          return Me(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
        if (this.libraryStarted)
          return;
        let r = async () => {
          Me("library starting");
          try {
            let n = { traceparent: this.config.tracingHelper.getTraceParent() };
            await this.engine?.connect(JSON.stringify(n)), this.libraryStarted = true, Me("library started");
          } catch (n) {
            let i = this.parseInitError(n.message);
            throw typeof i == "string" ? n : new k(i.message, this.config.clientVersion, i.error_code);
          } finally {
            this.libraryStartingPromise = void 0;
          }
        };
        return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
      }
      async stop() {
        if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
          return Me("library is already stopping"), this.libraryStoppingPromise;
        if (!this.libraryStarted)
          return;
        let r = async () => {
          await new Promise((i) => setTimeout(i, 5)), Me("library stopping");
          let n = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.disconnect(JSON.stringify(n)), this.libraryStarted = false, this.libraryStoppingPromise = void 0, Me("library stopped");
        };
        return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
      }
      version() {
        return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
      }
      debugPanic(r) {
        return this.library?.debugPanic(r);
      }
      async request(r, { traceparent: n, interactiveTransaction: i }) {
        Me(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        let o = JSON.stringify({ traceparent: n }), s = JSON.stringify(r);
        try {
          await this.start(), this.executingQueryPromise = this.engine?.query(s, o, i?.id), this.lastQuery = s;
          let a = this.parseEngineResponse(await this.executingQueryPromise);
          if (a.errors)
            throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
          if (this.loggerRustPanic)
            throw this.loggerRustPanic;
          return { data: a, elapsed: 0 };
        } catch (a) {
          if (a instanceof k)
            throw a;
          if (a.code === "GenericFailure" && a.message?.startsWith("PANIC:"))
            throw new ue(this.getErrorMessageWithLink(a.message), this.config.clientVersion);
          let l = this.parseRequestError(a.message);
          throw typeof l == "string" ? a : new K(`${l.message}
${l.backtrace}`, { clientVersion: this.config.clientVersion });
        }
      }
      async requestBatch(r, { transaction: n, traceparent: i }) {
        Me("requestBatch");
        let o = ln(r, n);
        await this.start(), this.lastQuery = JSON.stringify(o), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: i }), Fa(n));
        let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
        if (a.errors)
          throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        let { batchResult: l, errors: u } = a;
        if (Array.isArray(l))
          return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0]) : { data: c, elapsed: 0 });
        throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
      }
      buildQueryError(r) {
        return r.user_facing_error.is_panic ? new ue(this.getErrorMessageWithLink(r.user_facing_error.message), this.config.clientVersion) : zt(r, this.config.clientVersion);
      }
      async metrics(r) {
        await this.start();
        let n = await this.engine.metrics(JSON.stringify(r));
        return r.format === "prometheus" ? n : this.parseEngineResponse(n);
      }
    };
    function Na(e, t) {
      let r;
      try {
        r = un({ inlineDatasources: t.inlineDatasources, overrideDatasources: t.overrideDatasources, env: { ...t.env, ...process.env }, clientVersion: t.clientVersion });
      } catch {
      }
      e.noEngine !== true && r?.startsWith("prisma://") && Lt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
      let n = Gn(t.generator);
      if (r?.startsWith("prisma://") || e.noEngine)
        return new cr(t);
      if (n === "library")
        return new pr(t);
      throw "binary", new X("Invalid client engine type, please use `library` or `binary`", { clientVersion: t.clientVersion });
    }
    var Ba = S($i());
    function Va(e, t) {
      let r = ja(e), n = rd(r), i = id(n);
      i ? dn(i, t) : t.addErrorMessage(() => "Unknown error");
    }
    function ja(e) {
      return e.errors.flatMap((t) => t.kind === "Union" ? ja(t) : [t]);
    }
    function rd(e) {
      let t = /* @__PURE__ */ new Map(), r = [];
      for (let n of e) {
        if (n.kind !== "InvalidArgumentType") {
          r.push(n);
          continue;
        }
        let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = t.get(i);
        o ? t.set(i, { ...n, argument: { ...n.argument, typeNames: nd(o.argument.typeNames, n.argument.typeNames) } }) : t.set(i, n);
      }
      return r.push(...t.values()), r;
    }
    function nd(e, t) {
      return [...new Set(e.concat(t))];
    }
    function id(e) {
      return si(e, (t, r) => {
        let n = $a(t), i = $a(r);
        return n !== i ? n - i : qa(t) - qa(r);
      });
    }
    function $a(e) {
      let t = 0;
      return Array.isArray(e.selectionPath) && (t += e.selectionPath.length), Array.isArray(e.argumentPath) && (t += e.argumentPath.length), t;
    }
    function qa(e) {
      switch (e.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    var Se = class {
      constructor(t, r) {
        this.name = t;
        this.value = r;
        this.isRequired = false;
      }
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(t) {
        let { colors: { green: r } } = t.context;
        t.addMarginSymbol(r(this.isRequired ? "+" : "?")), t.write(r(this.name)), this.isRequired || t.write(r("?")), t.write(r(": ")), typeof this.value == "string" ? t.write(r(this.value)) : t.write(this.value);
      }
    };
    var mn = class {
      constructor() {
        this.fields = [];
      }
      addField(t, r) {
        return this.fields.push({ write(n) {
          let { green: i, dim: o } = n.context.colors;
          n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")));
        } }), this;
      }
      write(t) {
        let { colors: { green: r } } = t.context;
        t.writeLine(r("{")).withIndent(() => {
          t.writeJoined(xt, this.fields).newLine();
        }).write(r("}")).addMarginSymbol(r("+"));
      }
    };
    function dn(e, t) {
      switch (e.kind) {
        case "IncludeAndSelect":
          od(e, t);
          break;
        case "IncludeOnScalar":
          sd(e, t);
          break;
        case "EmptySelection":
          ad(e, t);
          break;
        case "UnknownSelectionField":
          ld(e, t);
          break;
        case "UnknownArgument":
          ud(e, t);
          break;
        case "UnknownInputField":
          cd(e, t);
          break;
        case "RequiredArgumentMissing":
          pd(e, t);
          break;
        case "InvalidArgumentType":
          dd(e, t);
          break;
        case "InvalidArgumentValue":
          md(e, t);
          break;
        case "ValueTooLarge":
          fd(e, t);
          break;
        case "SomeFieldsMissing":
          gd(e, t);
          break;
        case "TooManyFieldsGiven":
          yd(e, t);
          break;
        case "Union":
          Va(e, t);
          break;
        default:
          throw new Error("not implemented: " + e.kind);
      }
    }
    function od(e, t) {
      let r = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      r && r instanceof Q && (r.getField("include")?.markAsError(), r.getField("select")?.markAsError()), t.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
    }
    function sd(e, t) {
      let [r, n] = fn(e.selectionPath), i = e.outputType, o = t.arguments.getDeepSelectionParent(r)?.value;
      if (o && (o.getField(n)?.markAsError(), i))
        for (let s of i.fields)
          s.isRelation && o.addSuggestion(new Se(s.name, "true"));
      t.addErrorMessage((s) => {
        let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
        return i ? a += ` on model ${s.bold(i.name)}. ${dr(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
      });
    }
    function ad(e, t) {
      let r = e.outputType, n = t.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
      n && (n.removeAllFields(), Qa(n, r)), t.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${dr(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`);
    }
    function ld(e, t) {
      let [r, n] = fn(e.selectionPath), i = t.arguments.getDeepSelectionParent(r);
      i && (i.value.getField(n)?.markAsError(), Qa(i.value, e.outputType)), t.addErrorMessage((o) => {
        let s = [`Unknown field ${o.red(`\`${n}\``)}`];
        return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e.outputType.name}\``)}.`), s.push(dr(o)), s.join(" ");
      });
    }
    function ud(e, t) {
      let r = e.argumentPath[0], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof Q && (n.getField(r)?.markAsError(), hd(n, e.arguments)), t.addErrorMessage((i) => Ua(i, r, e.arguments.map((o) => o.name)));
    }
    function cd(e, t) {
      let [r, n] = fn(e.argumentPath), i = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (i instanceof Q) {
        i.getDeepField(e.argumentPath)?.markAsError();
        let o = i.getDeepFieldValue(r);
        o instanceof Q && Ja(o, e.inputType);
      }
      t.addErrorMessage((o) => Ua(o, n, e.inputType.fields.map((s) => s.name)));
    }
    function Ua(e, t, r) {
      let n = [`Unknown argument \`${e.red(t)}\`.`], i = bd(t, r);
      return i && n.push(`Did you mean \`${e.green(i)}\`?`), r.length > 0 && n.push(dr(e)), n.join(" ");
    }
    function pd(e, t) {
      let r;
      t.addErrorMessage((l) => r?.value instanceof J && r.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
      let n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (!(n instanceof Q))
        return;
      let [i, o] = fn(e.argumentPath), s = new mn(), a = n.getDeepFieldValue(i);
      if (a instanceof Q)
        if (r = a.getField(o), r && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
          for (let l of e.inputTypes[0].fields)
            s.addField(l.name, l.typeNames.join(" | "));
          a.addSuggestion(new Se(o, s).makeRequired());
        } else {
          let l = e.inputTypes.map(Ka).join(" | ");
          a.addSuggestion(new Se(o, l).makeRequired());
        }
    }
    function Ka(e) {
      return e.kind === "list" ? `${Ka(e.elementType)}[]` : e.name;
    }
    function dd(e, t) {
      let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
        let o = gn("or", e.argument.typeNames.map((s) => i.green(s)));
        return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
      });
    }
    function md(e, t) {
      let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
        let o = [`Invalid value for argument \`${i.bold(r)}\``];
        if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
          let s = gn("or", e.argument.typeNames.map((a) => i.green(a)));
          o.push(` Expected ${s}.`);
        }
        return o.join("");
      });
    }
    function fd(e, t) {
      let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i;
      if (n instanceof Q) {
        let s = n.getDeepField(e.argumentPath)?.value;
        s?.markAsError(), s instanceof J && (i = s.text);
      }
      t.addErrorMessage((o) => {
        let s = ["Unable to fit value"];
        return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``), s.join(" ");
      });
    }
    function gd(e, t) {
      let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
      if (n instanceof Q) {
        let i = n.getDeepFieldValue(e.argumentPath);
        i instanceof Q && Ja(i, e.inputType);
      }
      t.addErrorMessage((i) => {
        let o = [`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${gn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(dr(i)), o.join(" ");
      });
    }
    function yd(e, t) {
      let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i = [];
      if (n instanceof Q) {
        let o = n.getDeepFieldValue(e.argumentPath);
        o instanceof Q && (o.markAsError(), i = Object.keys(o.getFields()));
      }
      t.addErrorMessage((o) => {
        let s = [`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];
        return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${gn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
      });
    }
    function Qa(e, t) {
      for (let r of t.fields)
        e.hasField(r.name) || e.addSuggestion(new Se(r.name, "true"));
    }
    function hd(e, t) {
      for (let r of t)
        e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
    }
    function Ja(e, t) {
      if (t.kind === "object")
        for (let r of t.fields)
          e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
    }
    function fn(e) {
      let t = [...e], r = t.pop();
      if (!r)
        throw new Error("unexpected empty path");
      return [t, r];
    }
    function dr({ green: e }) {
      return `Available options are listed in ${e("green")}.`;
    }
    function gn(e, t) {
      if (t.length === 1)
        return t[0];
      let r = [...t], n = r.pop();
      return `${r.join(", ")} ${e} ${n}`;
    }
    var xd = 3;
    function bd(e, t) {
      let r = 1 / 0, n;
      for (let i of t) {
        let o = (0, Ba.default)(e, i);
        o > xd || o < r && (r = o, n = i);
      }
      return n;
    }
    function yn({ args: e, errors: t, errorFormat: r, callsite: n, originalMethod: i, clientVersion: o }) {
      let s = Yr(e);
      for (let p of t)
        dn(p, s);
      let a = r === "pretty" ? Rs : Wr, l = s.renderAllMessages(a), u = new dt(0, { colors: a }).write(s).toString(), c = wt({ message: l, callsite: n, originalMethod: i, showColors: r === "pretty", callArguments: u });
      throw new X(c, { clientVersion: o });
    }
    var Ed = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    function Ga({ modelName: e, action: t, args: r, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a, clientVersion: l }) {
      let u = new qi({ runtimeDataModel: n, modelName: e, action: t, rootArgs: r, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l });
      return { modelName: e, action: Ed[t], query: Vi(r, u) };
    }
    function Vi({ select: e, include: t, ...r } = {}, n) {
      return { arguments: Wa(r, n), selection: wd(e, t, n) };
    }
    function wd(e, t, r) {
      return e && t && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e ? Td(e, r) : Pd(r, t);
    }
    function Pd(e, t) {
      let r = {};
      return e.model && !e.isRawAction() && (r.$composites = true, r.$scalars = true), t && vd(r, t, e), r;
    }
    function vd(e, t, r) {
      for (let [n, i] of Object.entries(t)) {
        let o = r.findField(n);
        o && o?.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), i === true ? e[n] = true : typeof i == "object" && (e[n] = Vi(i, r.nestSelection(n)));
      }
    }
    function Td(e, t) {
      let r = {}, n = t.getComputedFields(), i = la(e, n);
      for (let [o, s] of Object.entries(i)) {
        let a = t.findField(o);
        n?.[o] && !a || (s === true ? r[o] = true : typeof s == "object" && (r[o] = Vi(s, t.nestSelection(o))));
      }
      return r;
    }
    function Ha(e, t) {
      if (e === null)
        return null;
      if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
        return e;
      if (typeof e == "bigint")
        return { $type: "BigInt", value: String(e) };
      if (mt(e)) {
        if (qr(e))
          return { $type: "DateTime", value: e.toISOString() };
        t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (ht(e))
        return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
      if (Array.isArray(e))
        return Cd(e, t);
      if (ArrayBuffer.isView(e))
        return { $type: "Bytes", value: Buffer.from(e).toString("base64") };
      if (Ad(e))
        return e.values;
      if (yt(e))
        return { $type: "Decimal", value: e.toFixed() };
      if (e instanceof Ae) {
        if (e !== $r.instances[e._getName()])
          throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e._getName() };
      }
      if (Rd(e))
        return e.toJSON();
      if (typeof e == "object")
        return Wa(e, t);
      t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function Wa(e, t) {
      if (e.$type)
        return { $type: "Json", value: JSON.stringify(e) };
      let r = {};
      for (let n in e) {
        let i = e[n];
        i !== void 0 && (r[n] = Ha(i, t.nestArgument(n)));
      }
      return r;
    }
    function Cd(e, t) {
      let r = [];
      for (let n = 0; n < e.length; n++) {
        let i = t.nestArgument(String(n)), o = e[n];
        o === void 0 && t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(Ha(o, i));
      }
      return r;
    }
    function Ad(e) {
      return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
    }
    function Rd(e) {
      return typeof e == "object" && e !== null && typeof e.toJSON == "function";
    }
    var qi = class e {
      constructor(t) {
        this.params = t;
        this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
      }
      throwValidationError(t) {
        yn({ errors: [t], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.model))
          return { name: this.params.modelName, fields: this.model.fields.map((t) => ({ name: t.name, typeName: "boolean", isRelation: t.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      getComputedFields() {
        if (this.params.modelName)
          return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(t) {
        return this.model?.fields.find((r) => r.name === t);
      }
      nestSelection(t) {
        let r = this.findField(t), n = r?.kind === "object" ? r.type : void 0;
        return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(t) });
      }
      nestArgument(t) {
        return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t) });
      }
    };
    var za = (e) => ({ command: e });
    var Ya = (e) => e.strings.reduce((t, r, n) => `${t}@P${n}${r}`);
    function mr(e) {
      try {
        return Za(e, "fast");
      } catch {
        return Za(e, "slow");
      }
    }
    function Za(e, t) {
      return JSON.stringify(e.map((r) => Md(r, t)));
    }
    function Md(e, t) {
      return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : mt(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : we.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Sd(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") } : typeof e == "object" && t === "slow" ? el(e) : e;
    }
    function Sd(e) {
      return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function el(e) {
      if (typeof e != "object" || e === null)
        return e;
      if (typeof e.toJSON == "function")
        return e.toJSON();
      if (Array.isArray(e))
        return e.map(Xa);
      let t = {};
      for (let r of Object.keys(e))
        t[r] = Xa(e[r]);
      return t;
    }
    function Xa(e) {
      return typeof e == "bigint" ? e.toString() : el(e);
    }
    var Id = /^(\s*alter\s)/i;
    var tl = D("prisma:client");
    function ji(e, t, r, n) {
      if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Id.exec(t))
        throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var Bi = (e, t) => (r) => {
      let n = "", i;
      if (Array.isArray(r)) {
        let [o, ...s] = r;
        n = o, i = { values: mr(s || []), __prismaRawParameters__: true };
      } else
        switch (e) {
          case "sqlite":
          case "mysql": {
            n = r.sql, i = { values: mr(r.values), __prismaRawParameters__: true };
            break;
          }
          case "cockroachdb":
          case "postgresql": {
            n = r.text, i = { values: mr(r.values), __prismaRawParameters__: true };
            break;
          }
          case "sqlserver": {
            n = Ya(r), i = { values: mr(r.values), __prismaRawParameters__: true };
            break;
          }
          default:
            throw new Error(`The ${e} provider does not support ${t}`);
        }
      return i?.values ? tl(`prisma.${t}(${n}, ${i.values})`) : tl(`prisma.${t}(${n})`), { query: n, parameters: i };
    };
    var rl = { requestArgsToMiddlewareArgs(e) {
      return [e.strings, ...e.values];
    }, middlewareArgsToRequestArgs(e) {
      let [t, ...r] = e;
      return new oe(t, r);
    } };
    var nl = { requestArgsToMiddlewareArgs(e) {
      return [e];
    }, middlewareArgsToRequestArgs(e) {
      return e[0];
    } };
    function Ui(e) {
      return function(r) {
        let n, i = (o = e) => {
          try {
            return o === void 0 || o?.kind === "itx" ? n ?? (n = il(r(o))) : il(r(o));
          } catch (s) {
            return Promise.reject(s);
          }
        };
        return { then(o, s) {
          return i().then(o, s);
        }, catch(o) {
          return i().catch(o);
        }, finally(o) {
          return i().finally(o);
        }, requestTransaction(o) {
          let s = i(o);
          return s.requestTransaction ? s.requestTransaction(o) : s;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function il(e) {
      return typeof e.then == "function" ? e : Promise.resolve(e);
    }
    var ol = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, async createEngineSpan() {
    }, getActiveContext() {
    }, runInChildSpan(e, t) {
      return t();
    } };
    var Ki = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(t) {
        return this.getGlobalTracingHelper().getTraceParent(t);
      }
      createEngineSpan(t) {
        return this.getGlobalTracingHelper().createEngineSpan(t);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(t, r) {
        return this.getGlobalTracingHelper().runInChildSpan(t, r);
      }
      getGlobalTracingHelper() {
        return globalThis.PRISMA_INSTRUMENTATION?.helper ?? ol;
      }
    };
    function sl(e) {
      return e.includes("tracing") ? new Ki() : ol;
    }
    function al(e, t = () => {
    }) {
      let r, n = new Promise((i) => r = i);
      return { then(i) {
        return --e === 0 && r(t()), i?.(n);
      } };
    }
    function ll(e) {
      return typeof e == "string" ? e : e.reduce((t, r) => {
        let n = typeof r == "string" ? r : r.level;
        return n === "query" ? t : t && (r === "info" || t === "info") ? "info" : n;
      }, void 0);
    }
    var Fd = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
    var ul = Fd;
    var hn = class {
      constructor() {
        this._middlewares = [];
      }
      use(t) {
        this._middlewares.push(t);
      }
      get(t) {
        return this._middlewares[t];
      }
      has(t) {
        return !!this._middlewares[t];
      }
      length() {
        return this._middlewares.length;
      }
    };
    var pl = S(ni());
    function xn(e) {
      return typeof e.batchRequestIdx == "number";
    }
    function bn(e) {
      return e === null ? e : Array.isArray(e) ? e.map(bn) : typeof e == "object" ? kd(e) ? Od(e) : ct(e, bn) : e;
    }
    function kd(e) {
      return e !== null && typeof e == "object" && typeof e.$type == "string";
    }
    function Od({ $type: e, value: t }) {
      switch (e) {
        case "BigInt":
          return BigInt(t);
        case "Bytes":
          return Buffer.from(t, "base64");
        case "DateTime":
          return new Date(t);
        case "Decimal":
          return new we(t);
        case "Json":
          return JSON.parse(t);
        default:
          Ge(t, "Unknown tagged value");
      }
    }
    function cl(e) {
      if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
        return;
      let t = [];
      return e.modelName && t.push(e.modelName), e.query.arguments && t.push(Qi(e.query.arguments)), t.push(Qi(e.query.selection)), t.join("");
    }
    function Qi(e) {
      return `(${Object.keys(e).sort().map((r) => {
        let n = e[r];
        return typeof n == "object" && n !== null ? `(${r} ${Qi(n)})` : r;
      }).join(" ")})`;
    }
    var Dd = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
    function Ji(e) {
      return Dd[e];
    }
    var En = class {
      constructor(t) {
        this.options = t;
        this.tickActive = false;
        this.batches = {};
      }
      request(t) {
        let r = this.options.batchBy(t);
        return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n, i) => {
          this.batches[r].push({ request: t, resolve: n, reject: i });
        })) : this.options.singleLoader(t);
      }
      dispatchBatches() {
        for (let t in this.batches) {
          let r = this.batches[t];
          delete this.batches[t], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
            n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
          }).catch((n) => {
            r[0].reject(n);
          }) : (r.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
            if (n instanceof Error)
              for (let i = 0; i < r.length; i++)
                r[i].reject(n);
            else
              for (let i = 0; i < r.length; i++) {
                let o = n[i];
                o instanceof Error ? r[i].reject(o) : r[i].resolve(o);
              }
          }).catch((n) => {
            for (let i = 0; i < r.length; i++)
              r[i].reject(n);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    var _d = D("prisma:client:request_handler");
    var wn = class {
      constructor(t, r) {
        this.logEmitter = r, this.client = t, this.dataloader = new En({ batchLoader: na(async ({ requests: n, customDataProxyFetch: i }) => {
          let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Ji(p.protocolQuery.action));
          return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: Nd(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
            if (p instanceof Error)
              return p;
            try {
              return this.mapQueryEngineResult(n[d], p);
            } catch (f) {
              return f;
            }
          });
        }), singleLoader: async (n) => {
          let i = n.transaction?.kind === "itx" ? dl(n.transaction) : void 0, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Ji(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
          return this.mapQueryEngineResult(n, o);
        }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : cl(n.protocolQuery), batchOrder(n, i) {
          return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
        } });
      }
      async request(t) {
        try {
          return await this.dataloader.request(t);
        } catch (r) {
          let { clientMethod: n, callsite: i, transaction: o, args: s } = t;
          this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: i, transaction: o, args: s });
        }
      }
      mapQueryEngineResult({ dataPath: t, unpacker: r }, n) {
        let i = n?.data, o = n?.elapsed, s = this.unpack(i, t, r);
        return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
      }
      handleAndLogRequestError(t) {
        try {
          this.handleRequestError(t);
        } catch (r) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r;
        }
      }
      handleRequestError({ error: t, clientMethod: r, callsite: n, transaction: i, args: o }) {
        if (_d(t), Ld(t, i) || t instanceof Ce)
          throw t;
        if (t instanceof U && $d(t)) {
          let a = ml(t.meta);
          yn({ args: o, errors: [a], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
        }
        let s = t.message;
        throw n && (s = wt({ callsite: n, originalMethod: r, isPanic: t.isPanic, showColors: this.client._errorFormat === "pretty", message: s })), s = this.sanitizeMessage(s), t.code ? new U(s, { code: t.code, clientVersion: this.client._clientVersion, meta: t.meta, batchRequestIdx: t.batchRequestIdx }) : t.isPanic ? new ue(s, this.client._clientVersion) : t instanceof K ? new K(s, { clientVersion: this.client._clientVersion, batchRequestIdx: t.batchRequestIdx }) : t instanceof k ? new k(s, this.client._clientVersion) : t instanceof ue ? new ue(s, this.client._clientVersion) : (t.clientVersion = this.client._clientVersion, t);
      }
      sanitizeMessage(t) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, pl.default)(t) : t;
      }
      unpack(t, r, n) {
        if (!t || (t.data && (t = t.data), !t))
          return t;
        let i = Object.values(t)[0], o = r.filter((a) => a !== "select" && a !== "include"), s = bn(wi(i, o));
        return n ? n(s) : s;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function Nd(e) {
      if (e) {
        if (e.kind === "batch")
          return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
        if (e.kind === "itx")
          return { kind: "itx", options: dl(e) };
        Ge(e, "Unknown transaction kind");
      }
    }
    function dl(e) {
      return { id: e.id, payload: e.payload };
    }
    function Ld(e, t) {
      return xn(e) && t?.kind === "batch" && e.batchRequestIdx !== t.index;
    }
    function $d(e) {
      return e.code === "P2009" || e.code === "P2012";
    }
    function ml(e) {
      if (e.kind === "Union")
        return { kind: "Union", errors: e.errors.map(ml) };
      if (Array.isArray(e.selectionPath)) {
        let [, ...t] = e.selectionPath;
        return { ...e, selectionPath: t };
      }
      return e;
    }
    var fl = "5.3.1";
    var gl = fl;
    function yl(e) {
      return e.map((t) => {
        let r = {};
        for (let n of Object.keys(t))
          r[n] = hl(t[n]);
        return r;
      });
    }
    function hl({ prisma__type: e, prisma__value: t }) {
      switch (e) {
        case "bigint":
          return BigInt(t);
        case "bytes":
          return Buffer.from(t, "base64");
        case "decimal":
          return new we(t);
        case "datetime":
        case "date":
          return new Date(t);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${t}Z`);
        case "array":
          return t.map(hl);
        default:
          return t;
      }
    }
    var wl = S($i());
    var V = class extends Error {
      constructor(t) {
        super(t + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    E(V, "PrismaClientConstructorValidationError");
    var xl = ["datasources", "datasourceUrl", "errorFormat", "log", "__internal"];
    var bl = ["pretty", "colorless", "minimal"];
    var El = ["info", "query", "warn", "error"];
    var Vd = { datasources: (e, t) => {
      if (e) {
        if (typeof e != "object" || Array.isArray(e))
          throw new V(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
        for (let [r, n] of Object.entries(e)) {
          if (!t.includes(r)) {
            let i = At(r, t) || ` Available datasources: ${t.join(", ")}`;
            throw new V(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
          }
          if (typeof n != "object" || Array.isArray(n))
            throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n && typeof n == "object")
            for (let [i, o] of Object.entries(n)) {
              if (i !== "url")
                throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              if (typeof o != "string")
                throw new V(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            }
        }
      }
    }, datasourceUrl: (e) => {
      if (typeof e < "u" && typeof e != "string")
        throw new V(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (e) => {
      if (e) {
        if (typeof e != "string")
          throw new V(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!bl.includes(e)) {
          let t = At(e, bl);
          throw new V(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`);
        }
      }
    }, log: (e) => {
      if (!e)
        return;
      if (!Array.isArray(e))
        throw new V(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
      function t(r) {
        if (typeof r == "string" && !El.includes(r)) {
          let n = At(r, El);
          throw new V(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
        }
      }
      for (let r of e) {
        t(r);
        let n = { level: t, emit: (i) => {
          let o = ["stdout", "event"];
          if (!o.includes(i)) {
            let s = At(i, o);
            throw new V(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
          }
        } };
        if (r && typeof r == "object")
          for (let [i, o] of Object.entries(r))
            if (n[i])
              n[i](o);
            else
              throw new V(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
      }
    }, __internal: (e) => {
      if (!e)
        return;
      let t = ["debug", "hooks", "engine", "measurePerformance"];
      if (typeof e != "object")
        throw new V(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
      for (let [r] of Object.entries(e))
        if (!t.includes(r)) {
          let n = At(r, t);
          throw new V(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
        }
    } };
    function Pl(e, t) {
      for (let [r, n] of Object.entries(e)) {
        if (!xl.includes(r)) {
          let i = At(r, xl);
          throw new V(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
        }
        Vd[r](n, t);
      }
      if (e.datasourceUrl && e.datasources)
        throw new V('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function At(e, t) {
      if (t.length === 0 || typeof e != "string")
        return "";
      let r = jd(e, t);
      return r ? ` Did you mean "${r}"?` : "";
    }
    function jd(e, t) {
      if (t.length === 0)
        return null;
      let r = t.map((i) => ({ value: i, distance: (0, wl.default)(e, i) }));
      r.sort((i, o) => i.distance < o.distance ? -1 : 1);
      let n = r[0];
      return n.distance < 3 ? n.value : null;
    }
    function vl(e) {
      return e.length === 0 ? Promise.resolve([]) : new Promise((t, r) => {
        let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
          o || (s++, s === e.length && (o = true, i ? r(i) : t(n)));
        }, l = (u) => {
          o || (o = true, r(u));
        };
        for (let u = 0; u < e.length; u++)
          e[u].then((c) => {
            n[u] = c, a();
          }, (c) => {
            if (!xn(c)) {
              l(c);
              return;
            }
            c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
          });
      });
    }
    var Be = D("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Bd = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
    var Ud = Symbol.for("prisma.client.transaction.id");
    var Kd = { id: 0, nextId() {
      return ++this.id;
    } };
    function Ml(e) {
      class t {
        constructor(n) {
          this._middlewares = new hn();
          this._createPrismaPromise = Ui();
          this.$extends = Ws;
          pa(e), n && Pl(n, e.datasourceNames);
          let i = new Al.EventEmitter().on("error", () => {
          });
          this._extensions = on.empty(), this._previewFeatures = e.generator?.previewFeatures ?? [], this._clientVersion = e.clientVersion ?? gl, this._activeProvider = e.activeProvider, this._tracingHelper = sl(this._previewFeatures);
          let o = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && fr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && fr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s = Ot(o, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
          try {
            let a = n ?? {}, l = a.__internal ?? {}, u = l.debug === true;
            u && D.enable("prisma:client");
            let c = fr.default.resolve(e.dirname, e.relativePath);
            Rl.default.existsSync(c) || (c = e.dirname), Be("dirname", e.dirname), Be("relativePath", e.relativePath), Be("cwd", c);
            let p = l.engine || {};
            if (a.errorFormat ? this._errorFormat = a.errorFormat : process.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: c, dirname: e.dirname, enableDebugLogs: u, allowTriggerPanic: p.allowTriggerPanic, datamodelPath: fr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: p.binaryPath ?? void 0, engineEndpoint: p.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: a.log && ll(a.log), logQueries: a.log && !!(typeof a.log == "string" ? a.log === "query" : a.log.find((d) => typeof d == "string" ? d === "query" : d.level === "query")), env: s?.parsed ?? {}, flags: [], clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: da(a, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: i, isBundled: e.isBundled }, Be("clientVersion", e.clientVersion), this._engine = Na(e, this._engineConfig), this._requestHandler = new wn(this, i), a.log)
              for (let d of a.log) {
                let f = typeof d == "string" ? d : d.emit === "stdout" ? d.level : null;
                f && this.$on(f, (y) => {
                  Nt.log(`${Nt.tags[f] ?? ""}`, y.message || y.query);
                });
              }
            this._metrics = new pt(this._engine);
          } catch (a) {
            throw a.clientVersion = this._clientVersion, a;
          }
          return this._appliedParent = Ht(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $use(n) {
          this._middlewares.use(n);
        }
        $on(n, i) {
          n === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n, (o) => {
            let s = o.fields;
            return i(n === "query" ? { timestamp: o.timestamp, query: s?.query ?? o.query, params: s?.params ?? o.params, duration: s?.duration_ms ?? o.duration, target: o.target } : { timestamp: o.timestamp, message: s?.message ?? o.message, target: o.target });
          });
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n) {
            throw n.clientVersion = this._clientVersion, n;
          } finally {
            fo();
          }
        }
        $executeRawInternal(n, i, o, s) {
          return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Bi(this._activeProvider, i), callsite: qe(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
        }
        $executeRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0) {
              let [s, a] = Tl(n, i);
              return ji(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
            }
            throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => (ji(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
        }
        $runCommandRaw(n) {
          if (e.activeProvider !== "mongodb")
            throw new X(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: za, callsite: qe(this._errorFormat), transaction: i }));
        }
        async $queryRawInternal(n, i, o, s) {
          return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Bi(this._activeProvider, i), callsite: qe(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(yl);
        }
        $queryRaw(n, ...i) {
          return this._createPrismaPromise((o) => {
            if (n.raw !== void 0 || n.sql !== void 0)
              return this.$queryRawInternal(o, "$queryRaw", ...Tl(n, i));
            throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawUnsafe(n, ...i) {
          return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
        }
        _transactionWithArray({ promises: n, options: i }) {
          let o = Kd.nextId(), s = al(n.length), a = n.map((l, u) => {
            if (l?.[Symbol.toStringTag] !== "PrismaPromise")
              throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let c = i?.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
            return l.requestTransaction?.(p) ?? l;
          });
          return vl(a);
        }
        async _transactionWithCallback({ callback: n, options: i }) {
          let o = { traceparent: this._tracingHelper.getTraceParent() }, s = await this._engine.transaction("start", o, i), a;
          try {
            let l = { kind: "itx", ...s };
            a = await n(this._createItxClient(l)), await this._engine.transaction("commit", o, s);
          } catch (l) {
            throw await this._engine.transaction("rollback", o, s).catch(() => {
            }), l;
          }
          return a;
        }
        _createItxClient(n) {
          return Ht(be(tn(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Ui(n)), re(Ud, () => n.id), Vt(ul)]));
        }
        $transaction(n, i) {
          let o;
          typeof n == "function" ? o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
          let s = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s, o);
        }
        _request(n) {
          n.otelParentCtx = this._tracingHelper.getActiveContext();
          let i = n.middlewareArgsMapper ?? Bd, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
            let c = this._middlewares.get(++a);
            if (c)
              return this._tracingHelper.runInChildSpan(s.middleware, (P) => c(u, (T) => (P?.end(), l(T))));
            let { runInTransaction: p, args: d, ...f } = u, y = { ...n, ...f };
            d && (y.args = i.middlewareArgsToRequestArgs(d)), n.transaction !== void 0 && p === false && delete y.transaction;
            let g = await ra(this, y);
            return y.model ? Zs({ result: g, modelName: y.model, args: y.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
          };
          return this._tracingHelper.runInChildSpan(s.operation, () => new Cl.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
        }
        async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
          try {
            n = u ? u(n) : n;
            let y = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(y, () => Ga({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
            return D.enabled("prisma:client") && (Be("Prisma Client call:"), Be(`prisma.${i}(${Fs(n)})`), Be("Generated request:"), Be(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
          } catch (y) {
            throw y.clientVersion = this._clientVersion, y;
          }
        }
        get $metrics() {
          if (!this._hasPreviewFlag("metrics"))
            throw new X("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
          return this._metrics;
        }
        _hasPreviewFlag(n) {
          return !!this._engineConfig.previewFeatures?.includes(n);
        }
      }
      return t;
    }
    function Tl(e, t) {
      return Qd(e) ? [new oe(e, t), rl] : [e, nl];
    }
    function Qd(e) {
      return Array.isArray(e) && Array.isArray(e.raw);
    }
    var Jd = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function Sl(e) {
      return new Proxy(e, { get(t, r) {
        if (r in t)
          return t[r];
        if (!Jd.has(r))
          throw new TypeError(`Invalid enum value: ${String(r)}`);
      } });
    }
    function Il(e) {
      Ot(e, { conflictCheck: "warn" });
    }
  }
});

// node_modules/.prisma/client/index.js
var require_client = __commonJS({
  "node_modules/.prisma/client/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      NotFoundError: NotFoundError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join3,
      raw: raw2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2
    } = require_library();
    var Prisma = {};
    exports2.Prisma = Prisma;
    exports2.$Enums = {};
    Prisma.prismaVersion = {
      client: "5.3.1",
      engine: "61e140623197a131c2a6189271ffee05a7aa9a59"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.NotFoundError = NotFoundError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join3;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path = require("path");
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports2.Prisma.AccountScalarFieldEnum = {
      id: "id",
      email: "email",
      firstName: "firstName",
      lastName: "lastName",
      userName: "userName",
      fullName: "fullName",
      password: "password",
      phone: "phone",
      isVerified: "isVerified",
      accountType: "accountType",
      emailVerified: "emailVerified",
      image: "image",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      country: "country"
    };
    exports2.Prisma.OAuthClientScalarFieldEnum = {
      id: "id",
      provider: "provider",
      providerAccountId: "providerAccountId",
      accessToken: "accessToken",
      refreshToken: "refreshToken",
      expires: "expires",
      tokenType: "tokenType",
      accountId: "accountId"
    };
    exports2.Prisma.PartnershipScalarFieldEnum = {
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      status: "status",
      affiliateId: "affiliateId",
      companyId: "companyId"
    };
    exports2.Prisma.ApplicantScalarFieldEnum = {
      id: "id",
      experienceYear: "experienceYear",
      education: "education",
      skills: "skills",
      languages: "languages",
      certificates: "certificates",
      coverLetterTemplate: "coverLetterTemplate",
      gender: "gender",
      resume: "resume",
      introVideo: "introVideo",
      github: "github",
      linkedin: "linkedin",
      portfolio: "portfolio",
      about: "about",
      jobPosition: "jobPosition",
      salaryExpectation: "salaryExpectation",
      WorkExperienceYears: "WorkExperienceYears",
      location: "location",
      skillLevel: "skillLevel",
      englishLevel: "englishLevel",
      otherLanguages: "otherLanguages",
      accomplishment: "accomplishment",
      accountId: "accountId"
    };
    exports2.Prisma.CompanyScalarFieldEnum = {
      id: "id",
      companyName: "companyName",
      logo: "logo",
      accountId: "accountId"
    };
    exports2.Prisma.AffiliateScalarFieldEnum = {
      id: "id",
      accountId: "accountId"
    };
    exports2.Prisma.NotificationScalarFieldEnum = {
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      message: "message",
      isRead: "isRead",
      accountId: "accountId"
    };
    exports2.Prisma.JobPostScalarFieldEnum = {
      id: "id",
      title: "title",
      description: "description",
      jobType: "jobType",
      category: "category",
      vacancy: "vacancy",
      applicationDeadline: "applicationDeadline",
      salaryType: "salaryType",
      jobSite: "jobSite",
      salary: "salary",
      email: "email",
      location: "location",
      skills: "skills",
      jobExperience: "jobExperience",
      experienceLevel: "experienceLevel",
      qualifications: "qualifications",
      englishLevel: "englishLevel",
      otherLanguages: "otherLanguages",
      interviewQuestions: "interviewQuestions",
      isVisible: "isVisible",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      companyId: "companyId",
      affiliateId: "affiliateId"
    };
    exports2.Prisma.WorkExperienceScalarFieldEnum = {
      id: "id",
      companyName: "companyName",
      position: "position",
      companyWebsite: "companyWebsite",
      startDate: "startDate",
      endDate: "endDate",
      ongoing: "ongoing",
      accomplishment: "accomplishment",
      skills: "skills",
      applicantId: "applicantId"
    };
    exports2.Prisma.JobApplicationScalarFieldEnum = {
      id: "id",
      status: "status",
      attachment: "attachment",
      coverLetter: "coverLetter",
      resume: "resume",
      email: "email",
      phone: "phone",
      applicantId: "applicantId",
      jobPostId: "jobPostId",
      companyId: "companyId",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      interviewId: "interviewId"
    };
    exports2.Prisma.InterviewScalarFieldEnum = {
      id: "id",
      status: "status",
      attachment: "attachment",
      deadline: "deadline",
      description: "description",
      answerVideo: "answerVideo",
      answerText: "answerText",
      applicantId: "applicantId",
      companyId: "companyId",
      jobPostId: "jobPostId",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      jobApplicationId: "jobApplicationId"
    };
    exports2.Prisma.OfferScalarFieldEnum = {
      id: "id",
      status: "status",
      deadline: "deadline",
      description: "description",
      answerText: "answerText",
      applicantId: "applicantId",
      companyId: "companyId",
      jobPostId: "jobPostId",
      jobApplicationId: "jobApplicationId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.WorkforceScalarFieldEnum = {
      id: "id",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports2.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports2.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports2.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports2.AccountType = exports2.$Enums.AccountType = {
      APPLICANT: "APPLICANT",
      COMPANY: "COMPANY",
      AFFILIATE: "AFFILIATE"
    };
    exports2.RelationStatus = exports2.$Enums.RelationStatus = {
      PENDING: "PENDING",
      ACCEPTED: "ACCEPTED",
      REJECTED: "REJECTED"
    };
    exports2.ExperienceLevel = exports2.$Enums.ExperienceLevel = {
      Beginner: "Beginner",
      Intermediate: "Intermediate",
      Expert: "Expert",
      Junior: "Junior",
      Senior: "Senior"
    };
    exports2.EnglishLevel = exports2.$Enums.EnglishLevel = {
      BASIC: "BASIC",
      CONVERSATIONAL: "CONVERSATIONAL",
      FLUENT: "FLUENT",
      NATIVE: "NATIVE"
    };
    exports2.JobType = exports2.$Enums.JobType = {
      CONTRACTUAL: "CONTRACTUAL",
      INTERNSHIP: "INTERNSHIP",
      FULL_TIME: "FULL_TIME",
      PART_TIME: "PART_TIME"
    };
    exports2.SalaryType = exports2.$Enums.SalaryType = {
      HOURLY: "HOURLY",
      MONTHLY: "MONTHLY",
      YEARLY: "YEARLY",
      ONE_TIME: "ONE_TIME"
    };
    exports2.JobSite = exports2.$Enums.JobSite = {
      ONSITE: "ONSITE",
      REMOTE: "REMOTE",
      HYBRID: "HYBRID"
    };
    exports2.PostStatus = exports2.$Enums.PostStatus = {
      ACTIVE: "ACTIVE",
      DRAFT: "DRAFT",
      INACTIVE: "INACTIVE"
    };
    exports2.ApplicationStatus = exports2.$Enums.ApplicationStatus = {
      PENDING: "PENDING",
      INTERVIEW: "INTERVIEW",
      OFFER: "OFFER",
      ACCEPTED: "ACCEPTED",
      REJECTED: "REJECTED"
    };
    exports2.InterviewStatus = exports2.$Enums.InterviewStatus = {
      PENDING: "PENDING",
      APPLICANT_REFUSED: "APPLICANT_REFUSED",
      APPLICANT_RESPONDED: "APPLICANT_RESPONDED",
      ACCEPTED: "ACCEPTED",
      REJECTED: "REJECTED"
    };
    exports2.OfferStatus = exports2.$Enums.OfferStatus = {
      PENDING: "PENDING",
      APPLICANT_REFUSED: "APPLICANT_REFUSED",
      ACCEPTED: "ACCEPTED"
    };
    exports2.Prisma.ModelName = {
      Account: "Account",
      OAuthClient: "OAuthClient",
      Partnership: "Partnership",
      Applicant: "Applicant",
      Company: "Company",
      Affiliate: "Affiliate",
      Notification: "Notification",
      JobPost: "JobPost",
      WorkExperience: "WorkExperience",
      JobApplication: "JobApplication",
      Interview: "Interview",
      Offer: "Offer",
      Workforce: "Workforce"
    };
    var config2 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/home/odin/WebstormProjects/expert-bloom/expert-bloom-server/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "sdlGenerator": "sdl",
          "engineType": "library"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "debian-openssl-1.0.x",
            "native": true
          }
        ],
        "previewFeatures": []
      },
      "relativeEnvPaths": {
        "rootEnvPath": "../../../.env",
        "schemaEnvPath": "../../../.env"
      },
      "relativePath": "../../../prisma",
      "clientVersion": "5.3.1",
      "engineVersion": "61e140623197a131c2a6189271ffee05a7aa9a59",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "postgresql",
      "postinstall": true,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": "Z2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgICAgID0gInByaXNtYS1jbGllbnQtanMiCiAgc2RsR2VuZXJhdG9yID0gInNkbCIKICAvLyBlbmdpbmVUeXBlICAgID0gImxpYnJhcnkiCiAgLy8gYmluYXJ5VGFyZ2V0cyA9IFsiZGViaWFuLW9wZW5zc2wtMy4wLngiXQp9CgpkYXRhc291cmNlIGRiIHsKICBwcm92aWRlciA9ICJwb3N0Z3Jlc3FsIgogIHVybCAgICAgID0gZW52KCJEQVRBQkFTRV9VUkwiKQp9Cgptb2RlbCBBY2NvdW50IHsKICBpZCAgICAgICAgICAgIFN0cmluZyAgICAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgZW1haWwgICAgICAgICBTdHJpbmcgICAgICBAdW5pcXVlCiAgZmlyc3ROYW1lICAgICBTdHJpbmcKICBsYXN0TmFtZSAgICAgIFN0cmluZwogIHVzZXJOYW1lICAgICAgU3RyaW5nPyAgICAgQHVuaXF1ZQogIGZ1bGxOYW1lICAgICAgU3RyaW5nCiAgcGFzc3dvcmQgICAgICBTdHJpbmcKICBwaG9uZSAgICAgICAgIFN0cmluZz8gICAgIEB1bmlxdWUKICBpc1ZlcmlmaWVkICAgIEJvb2xlYW4gICAgIEBkZWZhdWx0KGZhbHNlKQogIGFjY291bnRUeXBlICAgQWNjb3VudFR5cGUKICBlbWFpbFZlcmlmaWVkIERhdGVUaW1lPwogIGltYWdlICAgICAgICAgU3RyaW5nCiAgY3JlYXRlZEF0ICAgICBEYXRlVGltZSAgICBAZGVmYXVsdChub3coKSkKICB1cGRhdGVkQXQgICAgIERhdGVUaW1lICAgIEB1cGRhdGVkQXQKICBjb3VudHJ5ICAgICAgIFN0cmluZz8KCiAgb0F1dGhDbGllbnQgICBPQXV0aENsaWVudFtdCiAgTm90aWZpY2F0aW9ucyBOb3RpZmljYXRpb25bXQoKICBjb21wYW55ICAgQ29tcGFueT8KICBhcHBsaWNhbnQgQXBwbGljYW50PwogIGFmZmlsaWF0ZSBBZmZpbGlhdGU/Cn0KCm1vZGVsIE9BdXRoQ2xpZW50IHsKICBpZCAgICAgICAgICAgICAgICBTdHJpbmcgICBAaWQgQGRlZmF1bHQoY3VpZCgpKQogIHByb3ZpZGVyICAgICAgICAgIFN0cmluZwogIHByb3ZpZGVyQWNjb3VudElkIFN0cmluZwogIGFjY2Vzc1Rva2VuICAgICAgIFN0cmluZwogIHJlZnJlc2hUb2tlbiAgICAgIFN0cmluZz8KICBleHBpcmVzICAgICAgICAgICBEYXRlVGltZQogIHRva2VuVHlwZSAgICAgICAgIFN0cmluZwoKICBBY2NvdW50ICAgQWNjb3VudD8gQHJlbGF0aW9uKGZpZWxkczogW2FjY291bnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0sIG9uRGVsZXRlOiBDYXNjYWRlKQogIGFjY291bnRJZCBTdHJpbmcgICBAdW5pcXVlCn0KCm1vZGVsIFBhcnRuZXJzaGlwIHsKICBpZCAgICAgICAgSW50ICAgICAgICAgICAgQGlkIEBkZWZhdWx0KGF1dG9pbmNyZW1lbnQoKSkKICBjcmVhdGVkQXQgRGF0ZVRpbWUgICAgICAgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lICAgICAgIEB1cGRhdGVkQXQKICBzdGF0dXMgICAgUmVsYXRpb25TdGF0dXMKCiAgYWZmaWxpYXRlICAgQWZmaWxpYXRlIEByZWxhdGlvbihmaWVsZHM6IFthZmZpbGlhdGVJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgYWZmaWxpYXRlSWQgU3RyaW5nCgogIGNvbXBhbnkgICBDb21wYW55IEByZWxhdGlvbihmaWVsZHM6IFtjb21wYW55SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGNvbXBhbnlJZCBTdHJpbmcKfQoKbW9kZWwgQXBwbGljYW50IHsKICBpZCAgICAgICAgICAgICAgICAgIFN0cmluZyAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgZXhwZXJpZW5jZVllYXIgICAgICBJbnQ/ICAgICBAZGVmYXVsdCgwKQogIGVkdWNhdGlvbiAgICAgICAgICAgU3RyaW5nPwogIHNraWxscyAgICAgICAgICAgICAgU3RyaW5nW10KICBsYW5ndWFnZXMgICAgICAgICAgIFN0cmluZ1tdCiAgY2VydGlmaWNhdGVzICAgICAgICBTdHJpbmdbXQogIGNvdmVyTGV0dGVyVGVtcGxhdGUgU3RyaW5nW10KICBnZW5kZXIgICAgICAgICAgICAgIFN0cmluZz8KCiAgLy8gbGlua3MKICByZXN1bWUgICAgIFN0cmluZz8KICBpbnRyb1ZpZGVvIFN0cmluZz8KICBnaXRodWIgICAgIFN0cmluZz8KICBsaW5rZWRpbiAgIFN0cmluZz8KICBwb3J0Zm9saW8gIFN0cmluZz8KCiAgYWJvdXQgICAgICAgICAgICAgICBTdHJpbmc/CiAgam9iUG9zaXRpb24gICAgICAgICBTdHJpbmc/CiAgc2FsYXJ5RXhwZWN0YXRpb24gICBJbnQ/CiAgV29ya0V4cGVyaWVuY2VZZWFycyBJbnQ/CiAgbG9jYXRpb24gICAgICAgICAgICBTdHJpbmc/CiAgc2tpbGxMZXZlbCAgICAgICAgICBFeHBlcmllbmNlTGV2ZWw/CiAgZW5nbGlzaExldmVsICAgICAgICBFbmdsaXNoTGV2ZWw/CiAgb3RoZXJMYW5ndWFnZXMgICAgICBTdHJpbmdbXQogIGFjY29tcGxpc2htZW50ICAgICAgU3RyaW5nPwoKICAvLyBleHRlcm5hbAogIHNhdmVkSm9icyAgICAgIEpvYlBvc3RbXSAgICAgICAgQHJlbGF0aW9uKCJTYXZlZEJ5IikKICBhcHBsaWNhdGlvbnMgICBKb2JBcHBsaWNhdGlvbltdCiAgd29ya0V4cGVyaWVuY2UgV29ya0V4cGVyaWVuY2VbXQogIGludGVydmlld3MgICAgIEludGVydmlld1tdCiAgb2ZmZXJzICAgICAgICAgT2ZmZXJbXQogIHNhdmVkQnkgICAgICAgIENvbXBhbnlbXQoKICBhY2NvdW50ICAgQWNjb3VudCBAcmVsYXRpb24oZmllbGRzOiBbYWNjb3VudElkXSwgcmVmZXJlbmNlczogW2lkXSwgb25EZWxldGU6IENhc2NhZGUpCiAgYWNjb3VudElkIFN0cmluZyAgQHVuaXF1ZQp9Cgptb2RlbCBDb21wYW55IHsKICBpZCAgICAgICAgICBTdHJpbmcgICAgQGlkIEBkZWZhdWx0KGN1aWQoKSkKICBjb21wYW55TmFtZSBTdHJpbmc/ICAgQHVuaXF1ZQogIGxvZ28gICAgICAgIFN0cmluZz8KICBqb3BQb3N0cyAgICBKb2JQb3N0W10KCiAgYWNjb3VudCAgIEFjY291bnQgQHJlbGF0aW9uKGZpZWxkczogW2FjY291bnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0sIG9uRGVsZXRlOiBDYXNjYWRlKQogIGFjY291bnRJZCBTdHJpbmcgIEB1bmlxdWUKCiAgYWZmaWxpYXRlcyAgICAgIFBhcnRuZXJzaGlwW10KICBzYXZlZEFwcGxpY2FudHMgQXBwbGljYW50W10KICBhcHBsaWNhdGlvbnMgICAgSm9iQXBwbGljYXRpb25bXQoKICBvZmZlcnMgICAgIE9mZmVyW10KICBpbnRlcnZpZXdzIEludGVydmlld1tdCn0KCm1vZGVsIEFmZmlsaWF0ZSB7CiAgaWQgICAgICAgU3RyaW5nICAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgam9wUG9zdHMgSm9iUG9zdFtdCgogIGFjY291bnQgICBBY2NvdW50IEByZWxhdGlvbihmaWVsZHM6IFthY2NvdW50SWRdLCByZWZlcmVuY2VzOiBbaWRdLCBvbkRlbGV0ZTogQ2FzY2FkZSkKICBhY2NvdW50SWQgU3RyaW5nICBAdW5pcXVlCgogIGNvbXBhbmllcyBQYXJ0bmVyc2hpcFtdCn0KCm1vZGVsIE5vdGlmaWNhdGlvbiB7CiAgaWQgICAgICAgIFN0cmluZyAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0CiAgbWVzc2FnZSAgIFN0cmluZwogIGlzUmVhZCAgICBCb29sZWFuICBAZGVmYXVsdChmYWxzZSkKCiAgYWNjb3VudCAgIEFjY291bnQgQHJlbGF0aW9uKGZpZWxkczogW2FjY291bnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0sIG9uRGVsZXRlOiBDYXNjYWRlKQogIGFjY291bnRJZCBTdHJpbmcgIEB1bmlxdWUKfQoKbW9kZWwgSm9iUG9zdCB7CiAgaWQgICAgICAgICAgICAgICAgICBTdHJpbmcgICAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgdGl0bGUgICAgICAgICAgICAgICBTdHJpbmcKICBkZXNjcmlwdGlvbiAgICAgICAgIFN0cmluZwogIGpvYlR5cGUgICAgICAgICAgICAgSm9iVHlwZQogIGNhdGVnb3J5ICAgICAgICAgICAgU3RyaW5nW10KICB2YWNhbmN5ICAgICAgICAgICAgIEludAogIGFwcGxpY2F0aW9uRGVhZGxpbmUgRGF0ZVRpbWUKICBzYWxhcnlUeXBlICAgICAgICAgIFNhbGFyeVR5cGUKICBqb2JTaXRlICAgICAgICAgICAgIEpvYlNpdGUKICBzYWxhcnkgICAgICAgICAgICAgIEludFtdCiAgZW1haWwgICAgICAgICAgICAgICBTdHJpbmcKICBsb2NhdGlvbiAgICAgICAgICAgIFN0cmluZyAgICAgQGRlZmF1bHQoIlVuaXRlZCBTdGF0ZXMiKQoKICBza2lsbHMgICAgICAgICAgICAgU3RyaW5nW10KICBqb2JFeHBlcmllbmNlICAgICAgSW50CiAgZXhwZXJpZW5jZUxldmVsICAgIEV4cGVyaWVuY2VMZXZlbCBAZGVmYXVsdChCZWdpbm5lcikKICBxdWFsaWZpY2F0aW9ucyAgICAgU3RyaW5nW10KICBlbmdsaXNoTGV2ZWwgICAgICAgRW5nbGlzaExldmVsCiAgb3RoZXJMYW5ndWFnZXMgICAgIFN0cmluZ1tdCiAgaW50ZXJ2aWV3UXVlc3Rpb25zIFN0cmluZ1tdCgogIGlzVmlzaWJsZSBCb29sZWFuCiAgc3RhdHVzICAgIFBvc3RTdGF0dXMgQGRlZmF1bHQoQUNUSVZFKQogIGNyZWF0ZWRBdCBEYXRlVGltZSAgIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCBEYXRlVGltZSAgIEB1cGRhdGVkQXQKCiAgYXBwbGljYXRpb25zIEpvYkFwcGxpY2F0aW9uW10KICBzYXZlZEJ5ICAgICAgQXBwbGljYW50W10gICAgICBAcmVsYXRpb24oIlNhdmVkQnkiKQoKICBjb21wYW55ICAgQ29tcGFueSBAcmVsYXRpb24oZmllbGRzOiBbY29tcGFueUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBjb21wYW55SWQgU3RyaW5nCgogIGFmZmlsaWF0ZSAgIEFmZmlsaWF0ZT8gQHJlbGF0aW9uKGZpZWxkczogW2FmZmlsaWF0ZUlkXSwgcmVmZXJlbmNlczogW2lkXSkKICBhZmZpbGlhdGVJZCBTdHJpbmc/CgogIEludGVydmlld3MgSW50ZXJ2aWV3W10KICBPZmZlciAgICAgIE9mZmVyW10KfQoKbW9kZWwgV29ya0V4cGVyaWVuY2UgewogIGlkICAgICAgICAgICAgIFN0cmluZyAgICBAaWQgQGRlZmF1bHQoY3VpZCgpKQogIGNvbXBhbnlOYW1lICAgIFN0cmluZwogIHBvc2l0aW9uICAgICAgIFN0cmluZwogIGNvbXBhbnlXZWJzaXRlIFN0cmluZz8KICBzdGFydERhdGUgICAgICBEYXRlVGltZQogIGVuZERhdGUgICAgICAgIERhdGVUaW1lPwogIG9uZ29pbmcgICAgICAgIEJvb2xlYW4gICBAZGVmYXVsdChmYWxzZSkKICBhY2NvbXBsaXNobWVudCBTdHJpbmcKICBza2lsbHMgICAgICAgICBTdHJpbmdbXQogIC8vIHByb2plY3RzICAgICAgIFN0cmluZ1tdCgogIGFwcGxpY2FudCAgIEFwcGxpY2FudCBAcmVsYXRpb24oZmllbGRzOiBbYXBwbGljYW50SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGFwcGxpY2FudElkIFN0cmluZwp9Cgptb2RlbCBKb2JBcHBsaWNhdGlvbiB7CiAgaWQgICAgICAgICAgU3RyaW5nICAgICAgICAgICAgQGlkIEBkZWZhdWx0KGN1aWQoKSkKICBzdGF0dXMgICAgICBBcHBsaWNhdGlvblN0YXR1cwogIGF0dGFjaG1lbnQgIFN0cmluZz8KICBjb3ZlckxldHRlciBTdHJpbmcKICByZXN1bWUgICAgICBTdHJpbmcKICBlbWFpbCAgICAgICBTdHJpbmcKICBwaG9uZSAgICAgICBTdHJpbmcKCiAgYXBwbGljYW50ICAgQXBwbGljYW50IEByZWxhdGlvbihmaWVsZHM6IFthcHBsaWNhbnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgYXBwbGljYW50SWQgU3RyaW5nCgogIGpvYlBvc3QgICBKb2JQb3N0IEByZWxhdGlvbihmaWVsZHM6IFtqb2JQb3N0SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGpvYlBvc3RJZCBTdHJpbmcKCiAgQ29tcGFueSAgIENvbXBhbnkgQHJlbGF0aW9uKGZpZWxkczogW2NvbXBhbnlJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgY29tcGFueUlkIFN0cmluZwoKICBpbnRlcnZpZXcgSW50ZXJ2aWV3PwogIG9mZmVyICAgICBPZmZlcj8KCiAgY3JlYXRlZEF0ICAgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0ICAgRGF0ZVRpbWUgQHVwZGF0ZWRBdAogIGludGVydmlld0lkIFN0cmluZz8KfQoKbW9kZWwgSW50ZXJ2aWV3IHsKICBpZCAgICAgICAgICBTdHJpbmcgICAgICAgICAgQGlkIEBkZWZhdWx0KGN1aWQoKSkKICBzdGF0dXMgICAgICBJbnRlcnZpZXdTdGF0dXMKICBhdHRhY2htZW50ICBTdHJpbmc/CiAgZGVhZGxpbmUgICAgRGF0ZVRpbWU/CiAgZGVzY3JpcHRpb24gU3RyaW5nCiAgYW5zd2VyVmlkZW8gU3RyaW5nPwogIGFuc3dlclRleHQgIFN0cmluZz8KCiAgYXBwbGljYW50ICAgQXBwbGljYW50IEByZWxhdGlvbihmaWVsZHM6IFthcHBsaWNhbnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgYXBwbGljYW50SWQgU3RyaW5nCgogIGNvbXBhbnkgICBDb21wYW55IEByZWxhdGlvbihmaWVsZHM6IFtjb21wYW55SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGNvbXBhbnlJZCBTdHJpbmcKCiAgam9iUG9zdCAgIEpvYlBvc3QgQHJlbGF0aW9uKGZpZWxkczogW2pvYlBvc3RJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgam9iUG9zdElkIFN0cmluZwoKICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXQKCiAgSm9iQXBwbGljYXRpb24gICBKb2JBcHBsaWNhdGlvbj8gQHJlbGF0aW9uKGZpZWxkczogW2pvYkFwcGxpY2F0aW9uSWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGpvYkFwcGxpY2F0aW9uSWQgU3RyaW5nPyAgICAgICAgIEB1bmlxdWUKfQoKbW9kZWwgT2ZmZXIgewogIGlkICAgICAgICAgIFN0cmluZyAgICAgIEBpZCBAZGVmYXVsdChjdWlkKCkpCiAgc3RhdHVzICAgICAgT2ZmZXJTdGF0dXMKICBkZWFkbGluZSAgICBEYXRlVGltZQogIGRlc2NyaXB0aW9uIFN0cmluZwogIGFuc3dlclRleHQgIFN0cmluZz8KCiAgYXBwbGljYW50ICAgQXBwbGljYW50IEByZWxhdGlvbihmaWVsZHM6IFthcHBsaWNhbnRJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgYXBwbGljYW50SWQgU3RyaW5nCgogIGNvbXBhbnkgICBDb21wYW55IEByZWxhdGlvbihmaWVsZHM6IFtjb21wYW55SWRdLCByZWZlcmVuY2VzOiBbaWRdKQogIGNvbXBhbnlJZCBTdHJpbmcKCiAgam9iUG9zdCAgIEpvYlBvc3QgQHJlbGF0aW9uKGZpZWxkczogW2pvYlBvc3RJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgam9iUG9zdElkIFN0cmluZwoKICBKb2JBcHBsaWNhdGlvbiAgIEpvYkFwcGxpY2F0aW9uPyBAcmVsYXRpb24oZmllbGRzOiBbam9iQXBwbGljYXRpb25JZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgam9iQXBwbGljYXRpb25JZCBTdHJpbmc/ICAgICAgICAgQHVuaXF1ZQoKICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpCiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXQKfQoKbW9kZWwgV29ya2ZvcmNlIHsKICBpZCBTdHJpbmcgQGlkIEBkZWZhdWx0KGN1aWQoKSkKCiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKQogIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0Cn0KCi8vIGVudW0gRGVjbGFyYXRpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgplbnVtIFJlbGF0aW9uU3RhdHVzIHsKICBQRU5ESU5HCiAgQUNDRVBURUQKICBSRUpFQ1RFRAp9CgplbnVtIEpvYlBvc3RlciB7CiAgQ29tcGFueQogIEFmZmlsaWF0ZQp9CgplbnVtIEFjY291bnRUeXBlIHsKICBBUFBMSUNBTlQKICBDT01QQU5ZCiAgQUZGSUxJQVRFCn0KCmVudW0gUG9zdFN0YXR1cyB7CiAgQUNUSVZFCiAgRFJBRlQKICBJTkFDVElWRQp9CgplbnVtIEVuZ2xpc2hMZXZlbCB7CiAgQkFTSUMKICBDT05WRVJTQVRJT05BTAogIEZMVUVOVAogIE5BVElWRQp9CgplbnVtIFNhbGFyeVR5cGUgewogIEhPVVJMWQogIE1PTlRITFkKICBZRUFSTFkKICBPTkVfVElNRQp9CgplbnVtIEpvYlNpdGUgewogIE9OU0lURQogIFJFTU9URQogIEhZQlJJRAp9CgplbnVtIEV4cGVyaWVuY2VMZXZlbCB7CiAgQmVnaW5uZXIKICBJbnRlcm1lZGlhdGUKICBFeHBlcnQKICBKdW5pb3IKICBTZW5pb3IKfQoKZW51bSBKb2JUeXBlIHsKICBDT05UUkFDVFVBTAogIElOVEVSTlNISVAKICBGVUxMX1RJTUUKICBQQVJUX1RJTUUKfQoKZW51bSBBcHBsaWNhdGlvblN0YXR1cyB7CiAgUEVORElORwogIElOVEVSVklFVwogIE9GRkVSCiAgQUNDRVBURUQgLy8gb2ZmZXIgYWNjZXB0ZWQKICBSRUpFQ1RFRAp9CgplbnVtIEludGVydmlld1N0YXR1cyB7CiAgUEVORElORwogIEFQUExJQ0FOVF9SRUZVU0VECiAgQVBQTElDQU5UX1JFU1BPTkRFRAogIEFDQ0VQVEVECiAgUkVKRUNURUQKfQoKZW51bSBPZmZlclN0YXR1cyB7CiAgUEVORElORwogIEFQUExJQ0FOVF9SRUZVU0VECiAgQUNDRVBURUQKfQo=",
      "inlineSchemaHash": "de1aa02da7808cbf92f37683c8615244b4489bd1e7597d6807cd08284d9f2746",
      "noEngine": false
    };
    var fs2 = require("fs");
    config2.dirname = __dirname;
    if (!fs2.existsSync(path.join(__dirname, "schema.prisma"))) {
      const alternativePaths = [
        "node_modules/.prisma/client",
        ".prisma/client"
      ];
      const alternativePath = alternativePaths.find((altPath) => {
        return fs2.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
      }) ?? alternativePaths[0];
      config2.dirname = path.join(process.cwd(), alternativePath);
      config2.isBundled = true;
    }
    config2.runtimeDataModel = JSON.parse('{"models":{"Account":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"firstName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"lastName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"userName","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"fullName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"isVerified","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"accountType","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"AccountType","isGenerated":false,"isUpdatedAt":false},{"name":"emailVerified","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"image","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"country","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"oAuthClient","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OAuthClient","relationName":"AccountToOAuthClient","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"Notifications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Notification","relationName":"AccountToNotification","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"AccountToCompany","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"applicant","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"AccountToApplicant","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"affiliate","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Affiliate","relationName":"AccountToAffiliate","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OAuthClient":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"providerAccountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"accessToken","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"refreshToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"expires","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"tokenType","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"Account","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","relationName":"AccountToOAuthClient","relationFromFields":["accountId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"accountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Partnership":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":{"name":"autoincrement","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"RelationStatus","isGenerated":false,"isUpdatedAt":false},{"name":"affiliate","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Affiliate","relationName":"AffiliateToPartnership","relationFromFields":["affiliateId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"affiliateId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToPartnership","relationFromFields":["companyId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Applicant":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"experienceYear","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Int","default":0,"isGenerated":false,"isUpdatedAt":false},{"name":"education","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"skills","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"languages","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"certificates","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"coverLetterTemplate","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"gender","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"resume","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"introVideo","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"github","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"linkedin","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"portfolio","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"about","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobPosition","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"salaryExpectation","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"WorkExperienceYears","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"location","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"skillLevel","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ExperienceLevel","isGenerated":false,"isUpdatedAt":false},{"name":"englishLevel","kind":"enum","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"EnglishLevel","isGenerated":false,"isUpdatedAt":false},{"name":"otherLanguages","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"accomplishment","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"savedJobs","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"SavedBy","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"applications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobApplication","relationName":"ApplicantToJobApplication","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"workExperience","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"WorkExperience","relationName":"ApplicantToWorkExperience","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"interviews","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Interview","relationName":"ApplicantToInterview","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"offers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","relationName":"ApplicantToOffer","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"savedBy","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"ApplicantToCompany","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"account","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","relationName":"AccountToApplicant","relationFromFields":["accountId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"accountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Company":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"companyName","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"logo","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jopPosts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"CompanyToJobPost","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"account","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","relationName":"AccountToCompany","relationFromFields":["accountId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"accountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"affiliates","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Partnership","relationName":"CompanyToPartnership","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"savedApplicants","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"ApplicantToCompany","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"applications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobApplication","relationName":"CompanyToJobApplication","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"offers","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","relationName":"CompanyToOffer","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"interviews","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Interview","relationName":"CompanyToInterview","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Affiliate":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"jopPosts","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"AffiliateToJobPost","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"account","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","relationName":"AccountToAffiliate","relationFromFields":["accountId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"accountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"companies","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Partnership","relationName":"AffiliateToPartnership","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Notification":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"message","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"isRead","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"account","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Account","relationName":"AccountToNotification","relationFromFields":["accountId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"accountId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"JobPost":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobType","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobType","isGenerated":false,"isUpdatedAt":false},{"name":"category","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"vacancy","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"applicationDeadline","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"salaryType","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"SalaryType","isGenerated":false,"isUpdatedAt":false},{"name":"jobSite","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobSite","isGenerated":false,"isUpdatedAt":false},{"name":"salary","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"location","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"United States","isGenerated":false,"isUpdatedAt":false},{"name":"skills","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobExperience","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"experienceLevel","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"ExperienceLevel","default":"Beginner","isGenerated":false,"isUpdatedAt":false},{"name":"qualifications","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"englishLevel","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"EnglishLevel","isGenerated":false,"isUpdatedAt":false},{"name":"otherLanguages","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"interviewQuestions","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"isVisible","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"PostStatus","default":"ACTIVE","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"applications","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobApplication","relationName":"JobApplicationToJobPost","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"savedBy","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"SavedBy","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToJobPost","relationFromFields":["companyId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"affiliate","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Affiliate","relationName":"AffiliateToJobPost","relationFromFields":["affiliateId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"affiliateId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"Interviews","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Interview","relationName":"InterviewToJobPost","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"Offer","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","relationName":"JobPostToOffer","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"WorkExperience":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"companyName","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"position","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"companyWebsite","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"startDate","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"endDate","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"ongoing","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"Boolean","default":false,"isGenerated":false,"isUpdatedAt":false},{"name":"accomplishment","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"skills","kind":"scalar","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"applicant","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"ApplicantToWorkExperience","relationFromFields":["applicantId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"applicantId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"JobApplication":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"ApplicationStatus","isGenerated":false,"isUpdatedAt":false},{"name":"attachment","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"coverLetter","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"resume","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"phone","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"applicant","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"ApplicantToJobApplication","relationFromFields":["applicantId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"applicantId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobPost","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"JobApplicationToJobPost","relationFromFields":["jobPostId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"jobPostId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"Company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToJobApplication","relationFromFields":["companyId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"interview","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Interview","relationName":"InterviewToJobApplication","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"offer","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Offer","relationName":"JobApplicationToOffer","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"interviewId","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Interview":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"InterviewStatus","isGenerated":false,"isUpdatedAt":false},{"name":"attachment","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"deadline","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"answerVideo","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"answerText","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"applicant","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"ApplicantToInterview","relationFromFields":["applicantId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"applicantId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToInterview","relationFromFields":["companyId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobPost","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"InterviewToJobPost","relationFromFields":["jobPostId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"jobPostId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"JobApplication","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobApplication","relationName":"InterviewToJobApplication","relationFromFields":["jobApplicationId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"jobApplicationId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Offer":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"status","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OfferStatus","isGenerated":false,"isUpdatedAt":false},{"name":"deadline","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"answerText","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"applicant","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Applicant","relationName":"ApplicantToOffer","relationFromFields":["applicantId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"applicantId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToOffer","relationFromFields":["companyId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"jobPost","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobPost","relationName":"JobPostToOffer","relationFromFields":["jobPostId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"jobPostId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"JobApplication","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"JobApplication","relationName":"JobApplicationToOffer","relationFromFields":["jobApplicationId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"jobApplicationId","kind":"scalar","isList":false,"isRequired":false,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Workforce":{"dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"RelationStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"ACCEPTED","dbName":null},{"name":"REJECTED","dbName":null}],"dbName":null},"JobPoster":{"values":[{"name":"Company","dbName":null},{"name":"Affiliate","dbName":null}],"dbName":null},"AccountType":{"values":[{"name":"APPLICANT","dbName":null},{"name":"COMPANY","dbName":null},{"name":"AFFILIATE","dbName":null}],"dbName":null},"PostStatus":{"values":[{"name":"ACTIVE","dbName":null},{"name":"DRAFT","dbName":null},{"name":"INACTIVE","dbName":null}],"dbName":null},"EnglishLevel":{"values":[{"name":"BASIC","dbName":null},{"name":"CONVERSATIONAL","dbName":null},{"name":"FLUENT","dbName":null},{"name":"NATIVE","dbName":null}],"dbName":null},"SalaryType":{"values":[{"name":"HOURLY","dbName":null},{"name":"MONTHLY","dbName":null},{"name":"YEARLY","dbName":null},{"name":"ONE_TIME","dbName":null}],"dbName":null},"JobSite":{"values":[{"name":"ONSITE","dbName":null},{"name":"REMOTE","dbName":null},{"name":"HYBRID","dbName":null}],"dbName":null},"ExperienceLevel":{"values":[{"name":"Beginner","dbName":null},{"name":"Intermediate","dbName":null},{"name":"Expert","dbName":null},{"name":"Junior","dbName":null},{"name":"Senior","dbName":null}],"dbName":null},"JobType":{"values":[{"name":"CONTRACTUAL","dbName":null},{"name":"INTERNSHIP","dbName":null},{"name":"FULL_TIME","dbName":null},{"name":"PART_TIME","dbName":null}],"dbName":null},"ApplicationStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"INTERVIEW","dbName":null},{"name":"OFFER","dbName":null},{"name":"ACCEPTED","dbName":null},{"name":"REJECTED","dbName":null}],"dbName":null},"InterviewStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"APPLICANT_REFUSED","dbName":null},{"name":"APPLICANT_RESPONDED","dbName":null},{"name":"ACCEPTED","dbName":null},{"name":"REJECTED","dbName":null}],"dbName":null},"OfferStatus":{"values":[{"name":"PENDING","dbName":null},{"name":"APPLICANT_REFUSED","dbName":null},{"name":"ACCEPTED","dbName":null}],"dbName":null}},"types":{}}');
    defineDmmfProperty2(exports2.Prisma, config2.runtimeDataModel);
    var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
    warnEnvConflicts2({
      rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config2);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path.join(__dirname, "libquery_engine-debian-openssl-1.0.x.so.node");
    path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-debian-openssl-1.0.x.so.node");
    path.join(__dirname, "schema.prisma");
    path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
  }
});

// node_modules/@prisma/client/index.js
var require_client2 = __commonJS({
  "node_modules/@prisma/client/index.js"(exports2, module2) {
    module2.exports = {
      ...require_client()
    };
  }
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "node_modules/bcryptjs/dist/bcrypt.js"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof require === "function" && typeof module2 === "object" && module2 && module2["exports"])
        module2["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports2, function() {
      "use strict";
      var bcrypt2 = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module2 !== "undefined" && module2 && module2["exports"])
          try {
            return require("crypto")["randomBytes"](len);
          } catch (e) {
          }
        try {
          var a;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len));
          return Array.prototype.slice.call(a);
        } catch (e) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e) {
      }
      randomFallback = null;
      bcrypt2.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt2.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt2.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick(function() {
            try {
              callback2(null, bcrypt2.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt2.hashSync = function(s, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt2.genSaltSync(salt);
        if (typeof s !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
        return _hash(s, salt);
      };
      bcrypt2.hash = function(s, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s === "string" && typeof salt === "number")
            bcrypt2.genSalt(salt, function(err, salt2) {
              _hash(s, salt2, callback2, progressCallback);
            });
          else if (typeof s === "string" && typeof salt === "string")
            _hash(s, salt, callback2, progressCallback);
          else
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i = 0, k2 = known.length; i < k2; ++i) {
          if (known.charCodeAt(i) === unknown.charCodeAt(i))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt2.compareSync = function(s, hash) {
        if (typeof s !== "string" || typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof s + ", " + typeof hash);
        if (hash.length !== 60)
          return false;
        return safeStringCompare(bcrypt2.hashSync(s, hash.substr(0, hash.length - 31)), hash);
      };
      bcrypt2.compare = function(s, hash, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s !== "string" || typeof hash !== "string") {
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash)));
            return;
          }
          if (hash.length !== 60) {
            nextTick(callback2.bind(this, null, false));
            return;
          }
          bcrypt2.hash(s, hash.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve(res);
            });
          });
      };
      bcrypt2.getRounds = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        return parseInt(hash.split("$")[2], 10);
      };
      bcrypt2.getSalt = function(hash) {
        if (typeof hash !== "string")
          throw Error("Illegal arguments: " + typeof hash);
        if (hash.length !== 60)
          throw Error("Illegal hash length: " + hash.length + " != 60");
        return hash.substring(0, 29);
      };
      var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i >= str.length)
            return null;
          return str.charCodeAt(i++);
        }, function(b2) {
          out.push(b2);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b2, len) {
        var off = 0, rs2 = [], c1, c2;
        if (len <= 0 || len > b2.length)
          throw Error("Illegal len: " + len);
        while (off < len) {
          c1 = b2[off++] & 255;
          rs2.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b2[off++] & 255;
          c1 |= c2 >> 4 & 15;
          rs2.push(BASE64_CODE[c1 & 63]);
          c1 = (c2 & 15) << 2;
          if (off >= len) {
            rs2.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b2[off++] & 255;
          c1 |= c2 >> 6 & 3;
          rs2.push(BASE64_CODE[c1 & 63]);
          rs2.push(BASE64_CODE[c2 & 63]);
        }
        return rs2.join("");
      }
      function base64_decode(s, len) {
        var off = 0, slen = s.length, olen = 0, rs2 = [], c1, c2, c3, c4, o, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off < slen - 1 && olen < len) {
          code = s.charCodeAt(off++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s.charCodeAt(off++);
          c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c2 == -1)
            break;
          o = c1 << 2 >>> 0;
          o |= (c2 & 48) >> 4;
          rs2.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o = (c2 & 15) << 4 >>> 0;
          o |= (c3 & 60) >> 2;
          rs2.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s.charCodeAt(off++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o = (c3 & 3) << 6 >>> 0;
          o |= c4;
          rs2.push(stringFromCharCode(o));
          ++olen;
        }
        var res = [];
        for (off = 0; off < olen; off++)
          res.push(rs2[off].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src, dst) {
          var cp2 = null;
          if (typeof src === "number")
            cp2 = src, src = function() {
              return null;
            };
          while (cp2 !== null || (cp2 = src()) !== null) {
            if (cp2 < 128)
              dst(cp2 & 127);
            else if (cp2 < 2048)
              dst(cp2 >> 6 & 31 | 192), dst(cp2 & 63 | 128);
            else if (cp2 < 65536)
              dst(cp2 >> 12 & 15 | 224), dst(cp2 >> 6 & 63 | 128), dst(cp2 & 63 | 128);
            else
              dst(cp2 >> 18 & 7 | 240), dst(cp2 >> 12 & 63 | 128), dst(cp2 >> 6 & 63 | 128), dst(cp2 & 63 | 128);
            cp2 = null;
          }
        };
        utfx2.decodeUTF8 = function(src, dst) {
          var a, b2, c, d, fail = function(b3) {
            b3 = b3.slice(0, b3.indexOf(null));
            var err = Error(b3.toString());
            err.name = "TruncatedError";
            err["bytes"] = b3;
            throw err;
          };
          while ((a = src()) !== null) {
            if ((a & 128) === 0)
              dst(a);
            else if ((a & 224) === 192)
              (b2 = src()) === null && fail([a, b2]), dst((a & 31) << 6 | b2 & 63);
            else if ((a & 240) === 224)
              ((b2 = src()) === null || (c = src()) === null) && fail([a, b2, c]), dst((a & 15) << 12 | (b2 & 63) << 6 | c & 63);
            else if ((a & 248) === 240)
              ((b2 = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b2, c, d]), dst((a & 7) << 18 | (b2 & 63) << 12 | (c & 63) << 6 | d & 63);
            else
              throw RangeError("Illegal starting byte: " + a);
          }
        };
        utfx2.UTF16toUTF8 = function(src, dst) {
          var c1, c2 = null;
          while (true) {
            if ((c1 = c2 !== null ? c2 : src()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c2 = src()) !== null) {
                if (c2 >= 56320 && c2 <= 57343) {
                  dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                  c2 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c2 !== null)
            dst(c2);
        };
        utfx2.UTF8toUTF16 = function(src, dst) {
          var cp2 = null;
          if (typeof src === "number")
            cp2 = src, src = function() {
              return null;
            };
          while (cp2 !== null || (cp2 = src()) !== null) {
            if (cp2 <= 65535)
              dst(cp2);
            else
              cp2 -= 65536, dst((cp2 >> 10) + 55296), dst(cp2 % 1024 + 56320);
            cp2 = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src, dst) {
          utfx2.UTF16toUTF8(src, function(cp2) {
            utfx2.encodeUTF8(cp2, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src, dst) {
          utfx2.decodeUTF8(src, function(cp2) {
            utfx2.UTF8toUTF16(cp2, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp2) {
          return cp2 < 128 ? 1 : cp2 < 2048 ? 2 : cp2 < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src) {
          var cp2, l = 0;
          while ((cp2 = src()) !== null)
            l += utfx2.calculateCodePoint(cp2);
          return l;
        };
        utfx2.calculateUTF16asUTF8 = function(src) {
          var n = 0, l = 0;
          utfx2.UTF16toUTF8(src, function(cp2) {
            ++n;
            l += utfx2.calculateCodePoint(cp2);
          });
          return [n, l];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +/* @__PURE__ */ new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr2, off, P, S2) {
        var n, l = lr2[off], r = lr2[off + 1];
        l ^= P[0];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[1];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[2];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[3];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[4];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[5];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[6];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[7];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[8];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[9];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[10];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[11];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[12];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[13];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[14];
        n = S2[l >>> 24];
        n += S2[256 | l >> 16 & 255];
        n ^= S2[512 | l >> 8 & 255];
        n += S2[768 | l & 255];
        r ^= n ^ P[15];
        n = S2[r >>> 24];
        n += S2[256 | r >> 16 & 255];
        n ^= S2[512 | r >> 8 & 255];
        n += S2[768 | r & 255];
        l ^= n ^ P[16];
        lr2[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr2[off + 1] = l;
        return lr2;
      }
      function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P, S2) {
        var offset = 0, lr2 = [0, 0], plen = P.length, slen = S2.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
          lr2 = _encipher(lr2, 0, P, S2), P[i] = lr2[0], P[i + 1] = lr2[1];
        for (i = 0; i < slen; i += 2)
          lr2 = _encipher(lr2, 0, P, S2), S2[i] = lr2[0], S2[i + 1] = lr2[1];
      }
      function _ekskey(data, key, P, S2) {
        var offp = 0, lr2 = [0, 0], plen = P.length, slen = S2.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr2[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr2[1] ^= sw.key, lr2 = _encipher(lr2, 0, P, S2), P[i] = lr2[0], P[i + 1] = lr2[1];
        for (i = 0; i < slen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr2[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr2[1] ^= sw.key, lr2 = _encipher(lr2, 0, P, S2), S2[i] = lr2[0], S2[i + 1] = lr2[1];
      }
      function _crypt(b2, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P, S2, i = 0, j2;
        if (Int32Array) {
          P = new Int32Array(P_ORIG);
          S2 = new Int32Array(S_ORIG);
        } else {
          P = P_ORIG.slice();
          S2 = S_ORIG.slice();
        }
        _ekskey(salt, b2, P, S2);
        function next() {
          if (progressCallback)
            progressCallback(i / rounds);
          if (i < rounds) {
            var start = Date.now();
            for (; i < rounds; ) {
              i = i + 1;
              _key(b2, P, S2);
              _key(salt, P, S2);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i = 0; i < 64; i++)
              for (j2 = 0; j2 < clen >> 1; j2++)
                _encipher(cdata, j2 << 1, P, S2);
            var ret = [];
            for (i = 0; i < clen; i++)
              ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
            if (callback) {
              callback(null, ret);
              return;
            } else
              return ret;
          }
          if (callback)
            nextTick(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash(s, salt, callback, progressCallback) {
        var err;
        if (typeof s !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes));
          }, progressCallback);
        }
      }
      bcrypt2.encodeBase64 = base64_encode;
      bcrypt2.decodeBase64 = base64_decode;
      return bcrypt2;
    });
  }
});

// node_modules/bcryptjs/index.js
var require_bcryptjs = __commonJS({
  "node_modules/bcryptjs/index.js"(exports2, module2) {
    module2.exports = require_bcrypt();
  }
});

// src/server.ts
var server_exports = {};
__export(server_exports, {
  schema: () => schema
});
module.exports = __toCommonJS(server_exports);

// node_modules/graphql-yoga/esm/error.js
var import_graphql20 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/helpers.js
var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
function compareStrings(a, b2) {
  if (String(a) < String(b2)) {
    return -1;
  }
  if (String(a) > String(b2)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  let name;
  if ("alias" in a) {
    name = a.alias?.value;
  }
  if (name == null && "name" in a) {
    name = a.name?.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b2, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b2);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
var import_graphql3 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/errors.js
var import_graphql = __toESM(require_graphql2(), 1);
function createGraphQLError(message, options) {
  if (import_graphql.versionInfo.major >= 17) {
    return new import_graphql.GraphQLError(message, options);
  }
  return new import_graphql.GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/inspect.js
var import_graphql2 = __toESM(require_graphql2(), 1);
var MAX_RECURSIVE_DEPTH = 3;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatError(value) {
  if (value instanceof import_graphql2.GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isPromise(value) {
  return isObjectLike(value) && typeof value["then"] === "function";
}
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== void 0) {
        coercedValues[name] = defaultValue;
      } else if ((0, import_graphql3.isNonNullType)(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" was not provided.`, {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === import_graphql3.Kind.NULL;
    if (valueNode.kind === import_graphql3.Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (defaultValue !== void 0) {
          coercedValues[name] = defaultValue;
        } else if ((0, import_graphql3.isNonNullType)(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && (0, import_graphql3.isNonNullType)(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`, {
        nodes: [valueNode]
      });
    }
    const coercedValue = (0, import_graphql3.valueFromAST)(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${(0, import_graphql3.print)(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node?.extensions);
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
var import_graphql7 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/astFromType.js
var import_graphql4 = __toESM(require_graphql2(), 1);
function astFromType(type) {
  if ((0, import_graphql4.isNonNullType)(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === import_graphql4.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql4.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if ((0, import_graphql4.isListType)(type)) {
    return {
      kind: import_graphql4.Kind.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: import_graphql4.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql4.Kind.NAME,
      value: type.name
    }
  };
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/astFromValue.js
var import_graphql6 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
var import_graphql5 = __toESM(require_graphql2(), 1);
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: import_graphql5.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql5.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql5.Kind.OBJECT_FIELD,
          name: { kind: import_graphql5.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql5.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql5.Kind.BOOLEAN, value };
  }
  if (typeof value === "bigint") {
    return { kind: import_graphql5.Kind.INT, value: String(value) };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: import_graphql5.Kind.INT, value: stringNum } : { kind: import_graphql5.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql5.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/astFromValue.js
function astFromValue(value, type) {
  if ((0, import_graphql6.isNonNullType)(type)) {
    const astValue = astFromValue(value, type.ofType);
    if (astValue?.kind === import_graphql6.Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return { kind: import_graphql6.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if ((0, import_graphql6.isListType)(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: import_graphql6.Kind.LIST, values: valuesNodes };
    }
    return astFromValue(value, itemType);
  }
  if ((0, import_graphql6.isInputObjectType)(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: import_graphql6.Kind.OBJECT_FIELD,
          name: { kind: import_graphql6.Kind.NAME, value: field.name },
          value: fieldValue
        });
      }
    }
    return { kind: import_graphql6.Kind.OBJECT, fields: fieldNodes };
  }
  if ((0, import_graphql6.isLeafType)(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if ((0, import_graphql6.isEnumType)(type)) {
      return { kind: import_graphql6.Kind.ENUM, value: serialized };
    }
    if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp2.test(serialized)) {
      return { kind: import_graphql6.Kind.INT, value: serialized };
    }
    return astFromValueUntyped(serialized);
  }
  console.assert(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn2) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn2(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize3(fn2) {
  const memoize3Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize3Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const newValue = fn2(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const newValue = fn2(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === void 0) {
      const newValue = fn2(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn2) {
  const memoize5Cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize5Cache.set(a1, cache2);
      const cache32 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache32);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache32.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = /* @__PURE__ */ new WeakMap();
      cache2.set(a2, cache3);
      const cache42 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache42);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache42.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = /* @__PURE__ */ new WeakMap();
      cache3.set(a3, cache4);
      const cache52 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache52);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = /* @__PURE__ */ new WeakMap();
      cache4.set(a4, cache5);
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === void 0) {
      const newValue = fn2(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema2, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema2);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema2) {
  const rootTypes = getRootTypes(schema2);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema2) {
  const rootTypeMap = getRootTypeMap(schema2);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema2) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema2.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema(schema2, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema2.getTypeMap();
  const schemaNode = astFromSchema(schema2, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema2.getDirectives();
  for (const directive of directives) {
    if ((0, import_graphql7.isSpecifiedDirective)(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema2, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = (0, import_graphql7.isSpecifiedScalarType)(type);
    const isIntrospection = (0, import_graphql7.isIntrospectionType)(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if ((0, import_graphql7.isObjectType)(type)) {
      definitions.push(astFromObjectType(type, schema2, pathToDirectivesInExtensions));
    } else if ((0, import_graphql7.isInterfaceType)(type)) {
      definitions.push(astFromInterfaceType(type, schema2, pathToDirectivesInExtensions));
    } else if ((0, import_graphql7.isUnionType)(type)) {
      definitions.push(astFromUnionType(type, schema2, pathToDirectivesInExtensions));
    } else if ((0, import_graphql7.isInputObjectType)(type)) {
      definitions.push(astFromInputObjectType(type, schema2, pathToDirectivesInExtensions));
    } else if ((0, import_graphql7.isEnumType)(type)) {
      definitions.push(astFromEnumType(type, schema2, pathToDirectivesInExtensions));
    } else if ((0, import_graphql7.isScalarType)(type)) {
      definitions.push(astFromScalarType(type, schema2, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: import_graphql7.Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema2, pathToDirectivesInExtensions) {
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema2.astNode != null) {
    nodes.push(schema2.astNode);
  }
  if (schema2.extensionASTNodes != null) {
    for (const extensionASTNode of schema2.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema2);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql7.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema2, schema2, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql7.Kind.SCHEMA_DEFINITION : import_graphql7.Kind.SCHEMA_EXTENSION,
    operationTypes,
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
  schemaNode.description = schema2.astNode?.description ?? schema2.description != null ? {
    kind: import_graphql7.Kind.STRING,
    value: schema2.description,
    block: true
  } : void 0;
  return schemaNode;
}
function astFromDirective(directive, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.DIRECTIVE_DEFINITION,
    description: directive.astNode?.description ?? (directive.description ? {
      kind: import_graphql7.Kind.STRING,
      value: directive.description
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: directive.name
    },
    arguments: directive.args?.map((arg) => astFromArg(arg, schema2, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: directive.locations?.map((location) => ({
      kind: import_graphql7.Kind.NAME,
      value: location
    })) || []
  };
}
function getDirectiveNodes(entity, schema2, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema2, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
function getDeprecatableDirectiveNodes(entity, schema2, pathToDirectivesInExtensions) {
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema2, directivesInExtensions);
  } else {
    directives = entity.astNode?.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = directives.filter((directive) => directive.name.value === "deprecated")?.[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg(arg, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_VALUE_DEFINITION,
    description: arg.astNode?.description ?? (arg.description ? {
      kind: import_graphql7.Kind.STRING,
      value: arg.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    defaultValue: arg.defaultValue !== void 0 ? astFromValue(arg.defaultValue, arg.type) ?? void 0 : void 0,
    directives: getDeprecatableDirectiveNodes(arg, schema2, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.OBJECT_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema2, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema2, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema2, pathToDirectivesInExtensions) {
  const node = {
    kind: import_graphql7.Kind.INTERFACE_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema2, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema2, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.UNION_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema2, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema2, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema2, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.ENUM_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema2, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type, schema2, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema2, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes(schema2, directivesInExtensions) : type.astNode?.directives || [];
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql7.Kind.SCALAR_TYPE_DEFINITION,
    description: type.astNode?.description ?? (type.description ? {
      kind: import_graphql7.Kind.STRING,
      value: type.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: type.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
}
function astFromField(field, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.FIELD_DEFINITION,
    description: field.astNode?.description ?? (field.description ? {
      kind: import_graphql7.Kind.STRING,
      value: field.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema2, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(field, schema2, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.INPUT_VALUE_DEFINITION,
    description: field.astNode?.description ?? (field.description ? {
      kind: import_graphql7.Kind.STRING,
      value: field.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(field, schema2, pathToDirectivesInExtensions),
    defaultValue: astFromValue(field.defaultValue, field.type) ?? void 0
  };
}
function astFromEnumValue(value, schema2, pathToDirectivesInExtensions) {
  return {
    kind: import_graphql7.Kind.ENUM_VALUE_DEFINITION,
    description: value.astNode?.description ?? (value.description ? {
      kind: import_graphql7.Kind.STRING,
      value: value.description,
      block: true
    } : void 0),
    name: {
      kind: import_graphql7.Kind.NAME,
      value: value.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(value, schema2, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, import_graphql7.GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== void 0) {
        const value = astFromValue(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql7.Kind.ARGUMENT,
            name: {
              kind: import_graphql7.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql7.Kind.ARGUMENT,
          name: {
            kind: import_graphql7.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql7.Kind.DIRECTIVE,
    name: {
      kind: import_graphql7.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema2, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema2?.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/comments.js
var import_graphql8 = __toESM(require_graphql2(), 1);
var MAX_LINE_LENGTH = 80;
var commentsRegistry = {};
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  const entityName = node.name?.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys = [entity];
  if (field) {
    keys.push(field);
    if (argument) {
      keys.push(argument);
    }
  }
  const path = keys.join(".");
  if (!commentsRegistry[path]) {
    commentsRegistry[path] = [];
  }
  commentsRegistry[path].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join2(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
  return maybeArray?.some((str) => str.includes("\n")) ?? false;
}
function addDescription(cb) {
  return (node, _key, _parent, path, ancestors) => {
    const keys = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, parent?.name?.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join2(array, "\n"))}
}` : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
var printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  // Document
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join2(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join2(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap("on ", typeCondition), join2(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      `fragment ${name}${wrap("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join2(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join2(args, ", "), ")")
  },
  // Type
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + ": " + type + wrap(" ", join2(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap("= ", defaultValue), join2(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join2(args, "\n")), "\n)") : wrap("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend type",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join2([
      "extend interface",
      name,
      wrap("implements ", join2(interfaces, " & ")),
      join2(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap("= ", join2(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block(fields)], " ")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function printWithComments(ast) {
  return (0, import_graphql8.visit)(ast, printDocASTReducerWithComments);
}
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql8.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "	")) {
    i++;
  }
  return i;
}
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind;
(function(MapperKind3) {
  MapperKind3["TYPE"] = "MapperKind.TYPE";
  MapperKind3["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind3["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind3["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind3["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind3["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind3["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind3["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind3["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind3["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind3["QUERY"] = "MapperKind.QUERY";
  MapperKind3["MUTATION"] = "MapperKind.MUTATION";
  MapperKind3["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind3["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind3["FIELD"] = "MapperKind.FIELD";
  MapperKind3["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind3["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind3["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind3["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind3["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind3["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind3["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind3["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind3["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind3["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/mapSchema.js
var import_graphql13 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
var import_graphql9 = __toESM(require_graphql2(), 1);
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if ((0, import_graphql9.isObjectType)(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/rewire.js
var import_graphql11 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/stub.js
var import_graphql10 = __toESM(require_graphql2(), 1);
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case import_graphql10.GraphQLInt.name:
      return import_graphql10.GraphQLInt;
    case import_graphql10.GraphQLFloat.name:
      return import_graphql10.GraphQLFloat;
    case import_graphql10.GraphQLString.name:
      return import_graphql10.GraphQLString;
    case import_graphql10.GraphQLBoolean.name:
      return import_graphql10.GraphQLBoolean;
    case import_graphql10.GraphQLID.name:
      return import_graphql10.GraphQLID;
    default:
      return type;
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if ((0, import_graphql11.isSpecifiedDirective)(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql11.GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if ((0, import_graphql11.isObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields),
        interfaces: () => rewireNamedTypes(config2.interfaces)
      };
      return new import_graphql11.GraphQLObjectType(newConfig);
    } else if ((0, import_graphql11.isInterfaceType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new import_graphql11.GraphQLInterfaceType(newConfig);
    } else if ((0, import_graphql11.isUnionType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        types: () => rewireNamedTypes(config2.types)
      };
      return new import_graphql11.GraphQLUnionType(newConfig);
    } else if ((0, import_graphql11.isInputObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireInputFields(config2.fields)
      };
      return new import_graphql11.GraphQLInputObjectType(newConfig);
    } else if ((0, import_graphql11.isEnumType)(type)) {
      const enumConfig = type.toConfig();
      return new import_graphql11.GraphQLEnumType(enumConfig);
    } else if ((0, import_graphql11.isScalarType)(type)) {
      if ((0, import_graphql11.isSpecifiedScalarType)(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new import_graphql11.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if ((0, import_graphql11.isListType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql11.GraphQLList(rewiredType) : null;
    } else if ((0, import_graphql11.isNonNullType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql11.GraphQLNonNull(rewiredType) : null;
    } else if ((0, import_graphql11.isNamedType)(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/transformInputValue.js
var import_graphql12 = __toESM(require_graphql2(), 1);
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = (0, import_graphql12.getNullableType)(type);
  if ((0, import_graphql12.isLeafType)(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if ((0, import_graphql12.isListType)(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if ((0, import_graphql12.isInputObjectType)(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t, v2) => {
    try {
      return t.serialize(v2);
    } catch {
      return v2;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t, v2) => {
    try {
      return t.parseValue(v2);
    } catch {
      return v2;
    }
  });
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema(schema2, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema2.getTypeMap(), schema2, serializeInputValue), schema2, schemaMapper, (type) => (0, import_graphql13.isLeafType)(type)), schema2, schemaMapper), schema2, parseInputValue), schema2, schemaMapper, (type) => !(0, import_graphql13.isLeafType)(type)), schema2, schemaMapper), schema2, schemaMapper);
  const originalDirectives = schema2.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema2, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new import_graphql13.GraphQLSchema({
    ...schema2.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
function mapTypes(originalTypeMap, schema2, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema2, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema2);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema2, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema2, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config2 = type.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema2, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new import_graphql13.GraphQLEnumType({
        ...config2,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => (0, import_graphql13.isEnumType)(type));
}
function mapDefaultValues(originalTypeMap, schema2, fn2) {
  const newTypeMap = mapArguments(originalTypeMap, schema2, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema2, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
function getNewType(newTypeMap, type) {
  if ((0, import_graphql13.isListType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql13.GraphQLList(newType) : null;
  } else if ((0, import_graphql13.isNonNullType)(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new import_graphql13.GraphQLNonNull(newType) : null;
  } else if ((0, import_graphql13.isNamedType)(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql13.isObjectType)(originalType) && !(0, import_graphql13.isInterfaceType)(originalType) && !(0, import_graphql13.isInputObjectType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema2, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema2);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if ((0, import_graphql13.isObjectType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else if ((0, import_graphql13.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new import_graphql13.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql13.isObjectType)(originalType) && !(0, import_graphql13.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema2);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if ((0, import_graphql13.isObjectType)(originalType)) {
        newTypeMap[typeName] = new import_graphql13.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else if ((0, import_graphql13.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = new import_graphql13.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql13.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema2, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema2);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema2, typeName) {
  const type = schema2.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if ((0, import_graphql13.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === schema2.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === schema2.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === schema2.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if ((0, import_graphql13.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if ((0, import_graphql13.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if ((0, import_graphql13.isUnionType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if ((0, import_graphql13.isEnumType)(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if ((0, import_graphql13.isScalarType)(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema2, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema2, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema2, typeName) {
  const type = schema2.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if ((0, import_graphql13.isObjectType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === schema2.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === schema2.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === schema2.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if ((0, import_graphql13.isInterfaceType)(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if ((0, import_graphql13.isInputObjectType)(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema2, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema2, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper ?? null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type) {
  if ((0, import_graphql13.isObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql13.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql13.GraphQLObjectType(config2);
  } else if ((0, import_graphql13.isInterfaceType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql13.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql13.GraphQLInterfaceType(config2);
  } else if ((0, import_graphql13.isInputObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql13.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql13.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql13.GraphQLInputObjectType(config2);
  } else if ((0, import_graphql13.isEnumType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        values
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new import_graphql13.GraphQLEnumType(config2);
  } else {
    return type;
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/heal.js
var import_graphql14 = __toESM(require_graphql2(), 1);
function healSchema(schema2) {
  healTypes(schema2.getTypeMap(), schema2.getDirectives());
  return schema2;
}
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if ((0, import_graphql14.isObjectType)(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if ((0, import_graphql14.isInterfaceType)(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if ((0, import_graphql14.isUnionType)(type)) {
      healUnderlyingTypes(type);
      return;
    } else if ((0, import_graphql14.isInputObjectType)(type)) {
      healInputFields(type);
      return;
    } else if ((0, import_graphql14.isLeafType)(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if ((0, import_graphql14.isListType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql14.GraphQLList(healedType) : null;
    } else if ((0, import_graphql14.isNonNullType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql14.GraphQLNonNull(healedType) : null;
    } else if ((0, import_graphql14.isNamedType)(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/forEachField.js
var import_graphql15 = __toESM(require_graphql2(), 1);
function forEachField(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql15.getNamedType)(type).name.startsWith("__") && (0, import_graphql15.isObjectType)(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn2(field, typeName, fieldName);
      }
    }
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
var import_graphql16 = __toESM(require_graphql2(), 1);
function forEachDefaultValue(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql16.getNamedType)(type).name.startsWith("__")) {
      if ((0, import_graphql16.isObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn2(arg.type, arg.defaultValue);
          }
        }
      } else if ((0, import_graphql16.isInputObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn2(field.type, field.defaultValue);
        }
      }
    }
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/mergeDeep.js
function mergeDeep(sources, respectPrototype = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    }
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, callback, rejectCallback) {
  let $return;
  let abruptClose;
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (rejectCallback) {
    const reject = rejectCallback;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function asyncMapValue(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
}
function iteratorResult(value) {
  return { value, done: false };
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/collectFields.js
var import_graphql18 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
var AccumulatorMap = class extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === void 0) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
};

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/directives.js
var import_graphql17 = __toESM(require_graphql2(), 1);
var GraphQLDeferDirective = new import_graphql17.GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [import_graphql17.DirectiveLocation.FRAGMENT_SPREAD, import_graphql17.DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new import_graphql17.GraphQLNonNull(import_graphql17.GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: import_graphql17.GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new import_graphql17.GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [import_graphql17.DirectiveLocation.FIELD],
  args: {
    if: {
      type: new import_graphql17.GraphQLNonNull(import_graphql17.GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: import_graphql17.GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: import_graphql17.GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/collectFields.js
function collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case import_graphql18.Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey(selection), selection);
        break;
      }
      case import_graphql18.Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case import_graphql18.Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap();
          collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
}
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap();
  const patches = [];
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
  return { fields, patches };
}
function shouldIncludeNode(variableValues, node) {
  const skip = (0, import_graphql18.getDirectiveValues)(import_graphql18.GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = (0, import_graphql18.getDirectiveValues)(import_graphql18.GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = (0, import_graphql18.typeFromAST)(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if ((0, import_graphql18.isAbstractType)(conditionalType)) {
    const possibleTypes = schema2.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = (0, import_graphql18.getDirectiveValues)(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : void 0
  };
}
var collectSubFields = memoize5(function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/isDocumentNode.js
var import_graphql19 = __toESM(require_graphql2(), 1);
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql19.Kind.DOCUMENT;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/utils/esm/Path.js
function addPath(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// node_modules/graphql-yoga/esm/error.js
function isAggregateError(obj) {
  return obj != null && typeof obj === "object" && "errors" in obj;
}
function hasToString(obj) {
  return obj != null && typeof obj.toString === "function";
}
function isGraphQLError(val) {
  return val instanceof import_graphql20.GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof import_graphql20.GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors = /* @__PURE__ */ new Set();
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors.add(error);
  } else if (error instanceof Error) {
    errors.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if ("extensions" in result && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if ("errors" in result && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && // if one item in the array is a GraphQLError, we're good
  obj.some(isGraphQLError);
}

// node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = '<!DOCTYPE html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.0/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from"https://unpkg.com/@graphql-yoga/graphiql@4.1.0/dist/yoga-graphiql.es.js";renderYogaGraphiQL(root,__OPTS__)</script></body></html>';

// node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));
function useGraphiQL(config2) {
  const logger = config2.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config2?.options === "function") {
    graphiqlOptionsFactory = config2?.options;
  } else if (typeof config2?.options === "object") {
    graphiqlOptionsFactory = () => config2?.options;
  } else if (config2?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config2?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config2.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse: endResponse2, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config2.graphqlEndpoint) || url.pathname === config2.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse2(response);
        }
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-schema.js
var import_graphql21 = __toESM(require_graphql2(), 1);
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if ((0, import_graphql21.isSchema)(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema2;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema2 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema2) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema2);
      }
    };
  }
  const schemaByRequest = /* @__PURE__ */ new WeakMap();
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema2 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema2);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema2 = schemaByRequest.get(context.request);
      if (schema2 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema2);
    }
  };
};

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
var import_graphql22 = __toESM(require_graphql2(), 1);
function assertResolversPresent(schema2, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema2, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !(0, import_graphql22.isScalarType)((0, import_graphql22.getNamedType)(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
function expectResolver(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
var import_graphql23 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver(schema2, requireResolversForResolveType) {
  mapSchema(schema2, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces(schema2, resolvers2) {
  const extendedResolvers = {};
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers2[iFace.name]) {
          for (const fieldName in resolvers2[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers2[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers2[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema({ schema: schema2, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver3, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers2 = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema2, inputResolvers) : inputResolvers;
  for (const typeName in resolvers2) {
    const resolverValue = resolvers2[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema2.getType(typeName);
    if (type == null) {
      if (requireResolversToMatchSchema === "ignore") {
        continue;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if ((0, import_graphql23.isSpecifiedScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql23.isEnumType)(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
        }
      }
    } else if ((0, import_graphql23.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
        }
      }
    } else if ((0, import_graphql23.isObjectType)(type) || (0, import_graphql23.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema2 = updateResolversInPlace ? addResolversToExistingSchema(schema2, resolvers2, defaultFieldResolver3) : createNewSchemaWithResolvers(schema2, resolvers2, defaultFieldResolver3);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema2, requireResolversForResolveType);
  }
  return schema2;
}
function addResolversToExistingSchema(schema2, resolvers2, defaultFieldResolver3) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in resolvers2) {
    const type = schema2.getType(typeName);
    const resolverValue = resolvers2[typeName];
    if ((0, import_graphql23.isScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: resolverValue?.astNode?.description ?? type.astNode.description,
            directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql23.isEnumType)(type)) {
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config2.astNode != null) {
          config2.astNode = {
            ...config2.astNode,
            description: resolverValue?.astNode?.description ?? config2.astNode.description,
            directives: (config2.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql23.GraphQLEnumType(config2);
    } else if ((0, import_graphql23.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql23.isObjectType)(type) || (0, import_graphql23.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema2, serializeInputValue);
  healSchema(schema2);
  forEachDefaultValue(schema2, parseInputValue);
  if (defaultFieldResolver3 != null) {
    forEachField(schema2, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver3;
      }
    });
  }
  return schema2;
}
function createNewSchemaWithResolvers(schema2, resolvers2, defaultFieldResolver3) {
  schema2 = mapSchema(schema2, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      const config2 = type.toConfig();
      const resolverValue = resolvers2[type.name];
      if (!(0, import_graphql23.isSpecifiedScalarType)(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: resolverValue?.astNode?.description ?? config2.astNode.description,
              directives: (config2.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config2[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql23.GraphQLScalarType(config2);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: resolverValue?.astNode?.description ?? config2.astNode.description,
              directives: (config2.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql23.GraphQLEnumType(config2);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql23.GraphQLUnionType(config2);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config2.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql23.GraphQLObjectType(config2);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql23.GraphQLInterfaceType(config2);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers2[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver3 != null) {
    schema2 = mapSchema(schema2, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver3
      })
    });
  }
  return schema2;
}
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
var import_graphql35 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers2 = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers2.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers2, true);
  if (options?.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments(args1, args2, config2) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome), config2);
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
function deduplicateArguments(args, config2) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!config2?.reverseArguments) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
var import_graphql24 = __toESM(require_graphql2(), 1);
function directiveAlreadyExists(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
}
function isRepeatableDirective(directive, directives) {
  return !!directives?.[directive.name.value]?.repeatable;
}
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
function mergeArguments2(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
}
function deduplicateDirectives(directives, definitions) {
  return directives.map((directive, i, all) => {
    const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
    if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments2(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
}
function mergeDirectives(d1 = [], d2 = [], config2, directives) {
  const reverseOrder = config2 && config2.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = deduplicateDirectives([...asNext], directives);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
      const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments2(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function validateInputs(node, existingNode) {
  const printedNode = (0, import_graphql24.print)({
    ...node,
    description: void 0
  });
  const printedExistingNode = (0, import_graphql24.print)({
    ...existingNode,
    description: void 0
  });
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    validateInputs(node, existingNode);
    return {
      ...node,
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues(first, second, config2, directives) {
  if (config2?.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
var import_graphql25 = __toESM(require_graphql2(), 1);
function mergeEnum(e1, e2, config2, directives) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: config2?.convertExtensions || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config2, directives),
      values: mergeEnumValues(e1.values, e2.values, config2)
    };
  }
  return config2?.convertExtensions ? {
    ...e1,
    kind: import_graphql25.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
var import_graphql26 = __toESM(require_graphql2(), 1);
function isStringTypes(types) {
  return typeof types === "string";
}
function isSourceTypes(types) {
  return types instanceof import_graphql26.Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === import_graphql26.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== import_graphql26.Kind.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === import_graphql26.Kind.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === import_graphql26.Kind.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));
function defaultStringComparator(a, b2) {
  if (a == null && b2 == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b2 == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b2)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b2)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
function fieldAlreadyExists(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
}
function mergeFields(type, f1, f2, config2, directives) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists(result, field);
      if (existing && !config2?.ignoreFieldConflicts) {
        const newField = config2?.onFieldTypeConflict && config2.onFieldTypeConflict(existing, field, type, config2?.throwOnConflict) || preventConflicts(type, existing, field, config2?.throwOnConflict);
        newField.arguments = mergeArguments(field["arguments"] || [], existing["arguments"] || [], config2);
        newField.directives = mergeDirectives(field.directives, existing.directives, config2, directives);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  if (config2 && config2.exclusions) {
    const exclusions = config2.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
function preventConflicts(type, a, b2, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b2.type);
  if (aType !== bType) {
    const t1 = extractType(a.type);
    const t2 = extractType(b2.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${b2.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
    if (!safeChangeForFieldType(a.type, b2.type, !ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode(b2.type) && !isNonNullTypeNode(a.type)) {
    a.type = b2.type;
  }
  return a;
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
var import_graphql27 = __toESM(require_graphql2(), 1);
function mergeInputType(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config2?.convertExtensions || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return config2?.convertExtensions ? {
    ...node,
    kind: import_graphql27.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
var import_graphql28 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
function alreadyExists(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
  const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
function mergeInterface(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config2?.convertExtensions || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config2) : void 0
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return config2?.convertExtensions ? {
    ...node,
    kind: import_graphql28.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var import_graphql33 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
var import_graphql29 = __toESM(require_graphql2(), 1);
function mergeType(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config2?.convertExtensions || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config2)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return config2?.convertExtensions ? {
    ...node,
    kind: import_graphql29.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
var import_graphql30 = __toESM(require_graphql2(), 1);
function mergeScalar(node, existingNode, config2, directives) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: config2?.convertExtensions || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config2, directives)
    };
  }
  return config2?.convertExtensions ? {
    ...node,
    kind: import_graphql30.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
var import_graphql31 = __toESM(require_graphql2(), 1);
function mergeUnion(first, second, config2, directives) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
      directives: mergeDirectives(first.directives, second.directives, config2, directives),
      kind: config2?.convertExtensions || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql31.Kind.UNION_TYPE_DEFINITION : import_graphql31.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config2)
    };
  }
  return config2?.convertExtensions ? {
    ...first,
    kind: import_graphql31.Kind.UNION_TYPE_DEFINITION
  } : first;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
var import_graphql32 = __toESM(require_graphql2(), 1);
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config2, directives) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql32.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql32.Kind.SCHEMA_DEFINITION ? import_graphql32.Kind.SCHEMA_DEFINITION : import_graphql32.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return config2?.convertExtensions ? {
    ...node,
    kind: import_graphql32.Kind.SCHEMA_DEFINITION
  } : node;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config2, directives = {}) {
  const mergedResultMap = directives;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = nodeDefinition.name?.value;
      if (config2?.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (config2?.exclusions?.includes(name + ".*") || config2?.exclusions?.includes(name)) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql33.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql33.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql33.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.UNION_TYPE_DEFINITION:
          case import_graphql33.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql33.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql33.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql33.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql33.Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql33.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql33.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config2);
    }
  }
  return mergedResultMap;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
var import_graphql34 = __toESM(require_graphql2(), 1);
function mergeTypeDefs(typeSource, config2) {
  resetComments();
  const doc = {
    kind: import_graphql34.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config2
    })
  };
  let result;
  if (config2?.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type of typeSource) {
        visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);
      }
    } else if ((0, import_graphql34.isSchema)(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = (0, import_graphql34.parse)(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && (0, import_graphql34.isDefinitionNode)(typeSource)) {
      if (typeSource.kind === import_graphql34.Kind.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes };
}
function mergeGraphQLTypes(typeSource, config2) {
  resetComments();
  const { allDirectives, allNodes } = visitTypeSources(typeSource, config2);
  const mergedDirectives = mergeGraphQLNodes(allDirectives, config2);
  const mergedNodes = mergeGraphQLNodes(allNodes, config2, mergedDirectives);
  if (config2?.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: import_graphql34.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql34.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql34.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if (config2?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol]?.operationTypes?.length) {
    mergedNodes[schemaDefSymbol] = {
      kind: import_graphql34.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql34.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql34.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql34.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config2?.sort) {
    const sortFn = typeof config2.sort === "function" ? config2.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b2) => sortFn(a.name?.value, b2.name?.value));
  }
  return mergedNodeDefinitions;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/merge/esm/extensions.js
function mergeExtensions(extensions) {
  return mergeDeep(extensions);
}
function applyExtensionObject(obj, extensions) {
  if (!obj) {
    return;
  }
  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);
}
function applyExtensions(schema2, extensions) {
  applyExtensionObject(schema2, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type = schema2.getType(typeName);
    if (type) {
      applyExtensionObject(type, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema2;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
function makeExecutableSchema({ typeDefs: typeDefs2, resolvers: resolvers2 = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs2) {
    throw new Error("Must provide typeDefs");
  }
  let schema2;
  if ((0, import_graphql35.isSchema)(typeDefs2)) {
    schema2 = typeDefs2;
  } else if (otherOptions?.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema2 = (0, import_graphql35.buildSchema)(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, otherOptions);
    schema2 = (0, import_graphql35.buildASTSchema)(mergedTypeDefs, otherOptions);
  }
  schema2 = addResolversToSchema({
    schema: schema2,
    resolvers: mergeResolvers(resolvers2),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema2, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema2, schemaExtensions);
  }
  return schema2;
}

// node_modules/graphql-yoga/esm/schema.js
function createSchema(opts) {
  return makeExecutableSchema(opts);
}

// node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = /* @__PURE__ */ new WeakMap();

// node_modules/@envelop/core/esm/utils.js
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
function getSubscribeArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
}
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
function mapAsyncIterator2(source, mapper) {
  const iterator = source[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: void 0, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
function getExecuteArgs(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
}
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));
function isAsyncIterable2(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn2) {
  if (isAsyncIterable2(payload.result)) {
    return { onNext: fn2 };
  }
  fn2({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return void 0;
}
function finalAsyncIterator(source, onFinal) {
  const iterator = source[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source, onError) {
  const iterator = source[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: void 0 };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: void 0 };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}

// node_modules/@envelop/core/esm/orchestrator.js
function throwEngineFunctionError(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
}
function createEnvelopOrchestrator({ plugins }) {
  let schema2 = null;
  let initDone = false;
  const parse4 = () => throwEngineFunctionError("parse");
  const validate2 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema2 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema2,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source, parseOptions) => {
    let result = null;
    let parseFn = parse4;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source.toString());
    return result;
  } : () => parse4;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema3, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : void 0;
    let validateFn = validate2;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema3,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema3, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate2;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    let context = orchestratorCtx ? { ...initialContext, ...orchestratorCtx } : initialContext;
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            context = { ...context, ...extension };
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            context = { ...context, ...extension };
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => orchestratorCtx ? { ...initialContext, ...orchestratorCtx } : initialContext;
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    let context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          context = { ...context, ...extension };
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== void 0) {
        break;
      }
    }
    if (result === void 0) {
      result = await subscribeFn({
        ...args,
        contextValue: context
        // Casted for GraphQL.js 15 compatibility
        // Can be removed once we drop support for GraphQL.js 15
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable2(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    let context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            context = {
              ...context,
              ...extension
            };
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== void 0) {
        break;
      }
    }
    if (result === void 0) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable2(result)) {
      result = mapAsyncIterator2(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable2(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema2) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema2,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema2;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// node_modules/@envelop/core/esm/create.js
function notEmpty(value) {
  return value != null;
}
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// node_modules/@envelop/core/esm/plugins/use-masked-errors.js
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
function createSerializableGraphQLError(message, originalError, isDev2) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev2) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
}
var createDefaultMaskError = (isDev2) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev2);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError2, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError2(error, message)) });
  }
};
function useMaskedErrors(opts) {
  const maskError2 = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError2, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError2(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError2(error, message));
        }
      };
    }
  };
}

// node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/execute.js
var import_graphql37 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/values.js
var import_graphql36 = __toESM(require_graphql2(), 1);
function getVariableValues(schema2, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema2, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors.push(error);
    });
    if (errors.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors.push(error);
  }
  return { errors };
}
function coerceVariableValues(schema2, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = (0, import_graphql36.typeFromAST)(schema2, varDefNode.type);
    if (!(0, import_graphql36.isInputType)(varType)) {
      const varTypeStr = (0, import_graphql36.print)(varDefNode.type);
      onError(createGraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = (0, import_graphql36.valueFromAST)(varDefNode.defaultValue, varType);
      } else if ((0, import_graphql36.isNonNullType)(varType)) {
        const varTypeStr = inspect(varType);
        onError(createGraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && (0, import_graphql36.isNonNullType)(varType)) {
      const varTypeStr = inspect(varType);
      onError(createGraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = (0, import_graphql36.coerceInputValue)(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error.originalError
      }));
    });
  }
  return coercedValues;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object) {
  const resolvedObject = /* @__PURE__ */ Object.create(null);
  await Promise.all(Object.entries(object).map(async ([key, value]) => {
    resolvedObject[key] = await value;
  }));
  return resolvedObject;
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: void 0, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = void 0;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = void 0;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: void 0, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/execute.js
var import_value_or_promise = __toESM(require_main(), 1);
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
function execute(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
function executeImpl(exeContext) {
  return new import_value_or_promise.ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }).resolve();
}
function buildResponse(data, errors) {
  return errors.length === 0 ? { data } : { errors, data };
}
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document2) {
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    if (definition.kind === import_graphql37.Kind.FRAGMENT_DEFINITION) {
      fragments[definition.name.value] = definition;
    }
  }
  return fragments;
});
function buildExecutionContext(args) {
  const { schema: schema2, document: document2, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver } = args;
  (0, import_graphql37.assertValidSchema)(schema2);
  const fragments = getFragmentsFromDocument(document2);
  let operation;
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case import_graphql37.Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [createGraphQLError("Must provide operation name if query contains multiple operations.")];
          }
          operation = definition;
        } else if (definition.name?.value === operationName) {
          operation = definition;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues(schema2, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema2,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver,
    typeResolver: typeResolver ?? defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver,
    subsequentPayloads: /* @__PURE__ */ new Set(),
    errors: []
  };
}
function buildPerEventExecutionContext(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: /* @__PURE__ */ new Set(),
    errors: []
  };
}
function executeOperation(exeContext) {
  const { operation, schema: schema2, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema2, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const path = void 0;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(fields, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath(path, responseName, parentType.name);
    return new import_value_or_promise.ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === void 0) {
        return results;
      }
      results[responseName] = result;
      return results;
    });
  }, /* @__PURE__ */ Object.create(null)).resolve();
}
function executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields) {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== void 0) {
        results[responseName] = result;
        if (isPromise(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path, asyncPayloadRecord) {
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(path));
        const handledError = handleFieldError(error, returnType, errors);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(path));
    const handledError = handleFieldError(error, returnType, errors);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, errors) {
  if ((0, import_graphql37.isNonNullType)(returnType)) {
    throw error;
  }
  errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if ((0, import_graphql37.isNonNullType)(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if ((0, import_graphql37.isListType)(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if ((0, import_graphql37.isLeafType)(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if ((0, import_graphql37.isAbstractType)(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if ((0, import_graphql37.isObjectType)(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect(returnType));
}
function getStreamValues(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = (0, import_graphql37.getDirectiveValues)(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : void 0
  };
}
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath(path, index, void 0);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath(path, index, void 0);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeListItemValue(item, completedResults, errors, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise(completedItem)) {
      completedResults.push(completedItem.then(void 0, (rawError) => {
        const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
        const handledError = handleFieldError(error, itemType, errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
    const handledError = handleFieldError(error, itemType, errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
}
function completeLeafValue(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof import_graphql37.GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`);
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if ((0, import_graphql37.isObjectType)(runtimeTypeName)) {
    throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!(0, import_graphql37.isObjectType)(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect(result)}.`, {
    nodes: fieldNodes
  });
}
function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields2(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
}
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0; i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0; i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source, args, contextValue, info) {
  if (isObjectLike(source) || typeof source === "function") {
    const property = source[info.fieldName];
    if (typeof property === "function") {
      return source[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
function subscribe(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    async next() {
      if (done) {
        return {
          value: void 0,
          done
        };
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult);
  } else {
    yield someExecutionResult;
  }
}
function mapSourceToResponse(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream[Symbol.asyncIterator](), async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload))), async function* (error) {
    const wrappedError = createGraphQLError(error.message, {
      originalError: error,
      nodes: [exeContext.operation]
    });
    yield {
      errors: [wrappedError]
    };
  }));
}
function createSourceEventStreamImpl(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise(eventStream)) {
      return eventStream.then(void 0, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
}
function executeSubscription(exeContext) {
  const { schema: schema2, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema2.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", { nodes: operation });
  }
  const { fields: rootFields } = collectFields(schema2, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef(schema2, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, { nodes: fieldNodes });
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise(result)) {
      return result.then(assertEventStream).then(void 0, (error) => {
        throw (0, import_graphql37.locatedError)(error, fieldNodes, pathToArray(path));
      });
    }
    return assertEventStream(result);
  } catch (error) {
    throw (0, import_graphql37.locatedError)(error, fieldNodes, pathToArray(path));
  }
}
function assertEventStream(result) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError(`Subscription field must return Async Iterable. Received: ${inspect(result)}.`);
  }
  return result;
}
function executeDeferredFragment(exeContext, parentType, sourceValue, fields, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields, asyncPayloadRecord);
    if (isPromise(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
}
function executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise(completedItem)) {
        completedItem = completedItem.then(void 0, (rawError) => {
          const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
}
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: void 0 };
    }
    item = value;
  } catch (rawError) {
    const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise(completedItem)) {
      completedItem = completedItem.then(void 0, (rawError) => {
        const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = (0, import_graphql37.locatedError)(rawError, fieldNodes, pathToArray(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? void 0;
  while (true) {
    const itemPath = addPath(path, index, void 0);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
function filterSubsequentPayloads(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0; i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
}
function getCompletedIncrementalResults(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
}
function yieldSubsequentPayloads(exeContext) {
  let isDone = false;
  async function next() {
    if (isDone) {
      return { value: void 0, done: true };
    }
    await Promise.race(Array.from(exeContext.subsequentPayloads).map((p) => p.promise));
    if (isDone) {
      return { value: void 0, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: void 0, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
}
var DeferredFragmentRecord = class {
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
};
var StreamRecord = class {
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
};
function isStreamPayload(asyncPayload) {
  return asyncPayload.type === "stream";
}
function getFieldDef(schema2, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === import_graphql37.SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return import_graphql37.SchemaMetaFieldDef;
  } else if (fieldName === import_graphql37.TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return import_graphql37.TypeMetaFieldDef;
  } else if (fieldName === import_graphql37.TypeNameMetaFieldDef.name) {
    return import_graphql37.TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}

// node_modules/graphql-yoga/node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
var import_graphql38 = __toESM(require_graphql2(), 1);
var import_value_or_promise2 = __toESM(require_main(), 1);
function normalizedExecutor(args) {
  const operationAST = (0, import_graphql38.getOperationAST)(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe(args);
  }
  return new import_value_or_promise2.ValueOrPromise(() => execute(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result);
    }
    return result;
  }).resolve();
}

// node_modules/graphql-yoga/esm/server.js
var defaultFetchAPI = __toESM(require_node_ponyfill(), 1);

// node_modules/@whatwg-node/server/esm/createServerAdapter.js
var DefaultFetchAPI = __toESM(require_node_ponyfill2(), 1);

// node_modules/@whatwg-node/server/esm/utils.js
var import_fetch = __toESM(require_node_ponyfill2(), 1);
function isAsyncIterable3(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
function getPort(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
}
function getHostnameWithPort(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
}
function buildFullUrl(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || "http";
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
}
function isRequestBody(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable3(body)) {
    return true;
  }
  return false;
}
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new import_fetch.URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
        body: maybeParsedBody
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: nodeRequest.headers
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: nodeRequest.headers,
    body: rawRequest
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
function configureSocket(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
}
function endResponse(serverResponse) {
  serverResponse.end(null, null, null);
}
async function sendAsyncIterable(serverResponse, asyncIterable) {
  for await (const chunk of asyncIterable) {
    if (!serverResponse.write(chunk)) {
      break;
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  if (fetchResponse.bodyType === "Buffer" || fetchResponse.bodyType === "String" || fetchResponse.bodyType === "Uint8Array") {
    serverResponse.write(fetchResponse.bodyInit);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable3(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && ("body" in val || "cache" in val || "credentials" in val || "headers" in val || "integrity" in val || "keepalive" in val || "method" in val || "mode" in val || "redirect" in val || "referrer" in val || "referrerPolicy" in val || "signal" in val || "window" in val);
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source) => {
    const descriptors = Object.getOwnPropertyNames(source).reduce((descriptors2, key) => {
      descriptors2[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

// node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
var UWSAbortSignal = class extends EventTarget {
  throwIfAborted() {
    if (this.aborted) {
      throw new DOMException("Aborted", "AbortError");
    }
  }
  constructor(res) {
    super();
    this.aborted = false;
    this._onabort = null;
    res.onAborted(() => {
      this.aborted = true;
      this.dispatchEvent(new Event("request aborted"));
    });
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("request aborted", value);
    } else {
      this.removeEventListener("request aborted", value);
    }
  }
};
function getRequestFromUWSRequest({ req, res, fetchAPI }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    body = new fetchAPI.ReadableStream({});
    const readable = body.readable;
    res.onAborted(() => {
      readable.push(null);
    });
    let multipleChunks = false;
    res.onData(function(ab, isLast) {
      const chunk = Buffer.from(ab, 0, ab.byteLength);
      if (!multipleChunks && isLast) {
        readable.push(chunk);
      } else {
        readable.push(Buffer.concat([chunk]));
      }
      if (isLast) {
        readable.push(null);
      }
      multipleChunks = true;
    });
  }
  const headers = new fetchAPI.Headers();
  req.forEach((key, value) => {
    headers.set(key, value);
  });
  const url = `http://localhost${req.getUrl()}`;
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal: new UWSAbortSignal(res)
  });
}
async function sendResponseToUwsOpts({ res, response }) {
  let resAborted = false;
  res.onAborted(function() {
    resAborted = true;
  });
  const isStringOrBuffer = response.bodyType === "String" || response.bodyType === "Uint8Array";
  res.cork(() => {
    res.writeStatus(`${response.status} ${response.statusText}`);
    for (const [key, value] of response.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = response.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              res.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        res.writeHeader(key, value);
      }
    }
    if (isStringOrBuffer) {
      res.end(response.bodyInit);
    }
  });
  if (isStringOrBuffer) {
    return;
  }
  if (!response.body) {
    res.end();
    return;
  }
  for await (const chunk of response.body) {
    if (resAborted) {
      return;
    }
    res.cork(() => {
      res.write(chunk);
    });
  }
  res.cork(() => {
    res.end();
  });
}

// node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  const waitUntils = await Promise.allSettled(waitUntilPromises);
  waitUntils.forEach((waitUntil) => {
    if (waitUntil.status === "rejected") {
      console.error(waitUntil.reason);
    }
  });
}
function isRequestAccessible(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
}
function addWaitUntil(serverContext, waitUntilPromises) {
  serverContext["waitUntil"] = function(promise) {
    if (promise != null) {
      waitUntilPromises.push(promise);
    }
  };
}
var EMPTY_OBJECT = {};
function createServerAdapter(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...DefaultFetchAPI,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  async function handleRequest(request, serverContext) {
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    let requestHandler = givenHandleRequest;
    let response;
    for (const onRequestHook of onRequestHooks) {
      await onRequestHook({
        request,
        serverContext,
        fetchAPI,
        url,
        requestHandler,
        setRequestHandler(newRequestHandler) {
          requestHandler = newRequestHandler;
        },
        endResponse(newResponse) {
          response = newResponse;
        }
      });
      if (response) {
        break;
      }
    }
    if (!response) {
      response = await requestHandler(request, serverContext);
    }
    for (const onResponseHook of onResponseHooks) {
      await onResponseHook({
        request,
        response,
        serverContext
      });
    }
    return response;
  }
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function requestListener(nodeRequest, serverResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: serverResponse
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    return handleNodeRequest(nodeRequest, defaultServerContext, ...ctx).then((response) => {
      if (response) {
        return sendNodeResponse(response, serverResponse, nodeRequest);
      }
      return new Promise((resolve) => {
        serverResponse.statusCode = 404;
        serverResponse.once("end", resolve);
        serverResponse.end();
      });
    }).finally(() => {
      if (waitUntilPromises.length > 0) {
        return handleWaitUntils(waitUntilPromises);
      }
    });
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req
    };
    addWaitUntil(defaultServerContext, waitUntilPromises);
    const serverContext = ctx.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI
    });
    return handleRequest(request, serverContext).then((response) => {
      if (!response) {
        res.writeStatus("404 Not Found");
        res.end();
        return;
      }
      return sendResponseToUwsOpts({
        response,
        res
      });
    });
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const serverContext = ctx.length > 0 ? Object.assign({}, event, ...ctx) : event;
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const serverContext = (ctx.length > 1 ? completeAssign(...ctx) : ctx[0]) || {};
    if (serverContext.waitUntil == null) {
      const waitUntilPromises = [];
      addWaitUntil(serverContext, waitUntilPromises);
      const response$ = handleRequest(request, serverContext);
      if (waitUntilPromises.length > 0) {
        return handleWaitUntils(waitUntilPromises).then(() => response$);
      }
      return response$;
    }
    return handleRequest(request, serverContext);
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || "href" in input) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        return handleRequestWithWaitUntil(new fetchAPI.Request(input, initOrCtx), ...restOfCtx);
      }
      return handleRequestWithWaitUntil(new fetchAPI.Request(input), ...maybeCtx);
    }
    return handleRequestWithWaitUntil(input, ...maybeCtx);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest,
    fetch: fetchFn,
    handleNodeRequest,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    // It should have all the attributes of the handler function and the server instance
    has: (_2, prop) => {
      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
    },
    get: (_2, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_2, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
}

// node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      }
      headers["Vary"] = "Access-Control-Request-Headers";
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          // Safari (and potentially other browsers) need content-length 0,
          // for 204 or they just hang waiting for a body
          // see: https://github.com/expressjs/cors/blob/master/lib/index.js#L176
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
var import_fetch2 = __toESM(require_node_ponyfill2(), 1);
function createDefaultErrorHandler(ResponseCtor = import_fetch2.Response) {
  return function defaultErrorHandler(e) {
    return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.stack || e.message || e.toString(), {
      status: e.statusCode || e.status || 500,
      headers: e.headers || {}
    });
  };
}
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(async function handlerWithErrorHandling(request, serverContext) {
        try {
          const response = await requestHandler(request, serverContext);
          return response;
        } catch (e) {
          const response = await errorHandler(e, request, serverContext);
          return response;
        }
      });
    }
  };
}

// node_modules/graphql-yoga/esm/server.js
var import_graphql41 = __toESM(require_graphql2(), 1);

// node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
var import_fetch3 = __toESM(require_node_ponyfill(), 1);
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || void 0;
  const query = searchParams.get("query") || void 0;
  const variablesStr = searchParams.get("variables") || void 0;
  const extensionsStr = searchParams.get("extensions") || void 0;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : void 0,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : void 0
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new import_fetch3.URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/get.js
var import_fetch4 = __toESM(require_node_ponyfill(), 1);
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new import_fetch4.URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k2;
  while (i < l) {
    k2 = keys[i++];
    if (k2 === "__proto__" || k2 === "constructor" || k2 === "prototype")
      break;
    t = t[k2] = i === l ? val : typeof (x = t[k2]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
var expectedParameters = /* @__PURE__ */ new Set([
  "query",
  "variables",
  "operationName",
  "extensions"
]);
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject2(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
function extendedTypeof(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
}
function isObject2(val) {
  return extendedTypeof(val) === "object";
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
var import_graphql39 = __toESM(require_graphql2(), 1);
function assertMutationViaGet(method, document2, operationName) {
  const operation = document2 ? (0, import_graphql39.getOperationAST)(document2, operationName) ?? void 0 : void 0;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        // the `params` might be missing in cases where the user provided
        // malformed context to getEnveloped (like `yoga.getEnveloped({})`)
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof import_graphql39.GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id: id2 = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id2
          }
        });
        endResponse2(response);
      }
    }
  };
}

// node_modules/graphql-yoga/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn2) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn2) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_2, fn2) {
      this._onabort.push(fn2);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn2 of this.signal._onabort) {
        fn2(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _Stack.#constructing = true;
    const s = new _Stack(max, HeapCls);
    _Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!_Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
};
var LRUCache = class _LRUCache {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k2, index, options, context) => c.#backgroundFetch(k2, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.delete(this.#keyList[index]);
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (ttl === 0 || start === 0) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k2, v2, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v2)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v2, k2);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i2) => {
  };
  #addItemSize = (_i2, _s2, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k2 = this.#keyList[i];
      if (k2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      if (v2 !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn2, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn2(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn2, thisp = this) {
    for (const i of this.#indexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn2, thisp = this) {
    for (const i of this.#rindexes()) {
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn2.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.delete(this.#keyList[i]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v2 = this.#valList[i];
      const value = this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k2, v2, setOptions = {}) {
    if (v2 === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k2, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k2);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k2;
      this.#valList[index] = v2;
      this.#keyMap.set(k2, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v2 !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k2, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k2, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v2;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt2 = this.#disposed;
        let task;
        while (task = dt2?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k2 = this.#keyList[head];
    const v2 = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v2)) {
      v2.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v2, k2, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v2, k2, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k2);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k2);
    if (index !== void 0) {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2) && v2.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k2);
    if (index !== void 0 && (allowStale || !this.#isStale(index))) {
      const v2 = this.#valList[index];
      return this.#isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
    }
  }
  #backgroundFetch(k2, index, options, context) {
    const v2 = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v2)) {
      return v2;
    }
    const ac2 = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac2.abort(signal.reason), {
      signal: ac2.signal
    });
    const fetchOpts = {
      signal: ac2.signal,
      options,
      context
    };
    const cb = (v3, updateCache = false) => {
      const { aborted } = ac2.signal;
      const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac2.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac2.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v3 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.delete(k2);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v3, fetchOpts.options);
        }
      }
      return v3;
    };
    const eb = (er2) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er2;
      }
      return fetchFail(er2);
    };
    const fetchFail = (er2) => {
      const { aborted } = ac2.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.delete(k2);
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er2;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k2, v2, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v3) => res(v3 === void 0 ? void 0 : v3), rej);
      }
      ac2.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v3) => cb(v3, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac2,
      __staleWhileFetching: v2,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k2);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b2 = p;
    return !!b2 && b2 instanceof Promise && b2.hasOwnProperty("__staleWhileFetching") && b2.__abortController instanceof AC;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k2);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k2, index, options, context);
      return p.__returned = p;
    } else {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v2;
      }
      const p = this.#backgroundFetch(k2, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k2);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k2);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.clear();
        } else {
          this.#removeItemSize(index);
          const v2 = this.#valList[index];
          if (this.#isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v2, k2, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v2, k2, "delete"]);
            }
          }
          this.#keyMap.delete(k2);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#next[this.#prev[index]] = this.#next[index];
            this.#prev[this.#next[index]] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v2 = this.#valList[index];
      if (this.#isBackgroundFetch(v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v2, k2, "delete");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v2, k2, "delete"]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt2 = this.#disposed;
      let task;
      while (task = dt2?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
};

// node_modules/graphql-yoga/esm/utils/create-lru-cache.js
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 36e5;
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}

// node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document2 = documentCache.get(strDocument);
      if (document2) {
        setParsedDocument(document2);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema2, documentAST, rules },
      setResult
      // eslint-disable-next-line @typescript-eslint/ban-types
    }) {
      if (schema2 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = /* @__PURE__ */ new WeakMap();
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema2);
        if (!validationCacheByDocument) {
          validationCacheByDocument = /* @__PURE__ */ new WeakMap();
          validationCacheBySchema.set(schema2, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/use-request-parser.js
var DEFAULT_MATCHER = () => true;
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}

// node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  return JSON.stringify(Array.isArray(result) ? result.map(omitInternalsFromResultErrors) : omitInternalsFromResultErrors(result));
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : void 0;
    }
    return newResult;
  }
  return result;
}
function omitInternalsFromError(err) {
  if (isGraphQLError(err)) {
    const serializedError = "toJSON" in err && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || void 0),
      extensions: Object.keys(extensions).length ? extensions : void 0
    });
  }
  return err;
}

// node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder();
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable2(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12e3;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder();
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable2(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next
`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}

`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete

`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(
    executionResult,
    headersInit,
    // prefer 200 only if accepting application/json and all errors are exclusively GraphQL errors
    acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError))
  );
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var multipart = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
function getSSEProcessorConfig() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
}
var regular = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};
function useResultProcessors() {
  const isSubscriptionRequestMap = /* @__PURE__ */ new WeakMap();
  const sse = getSSEProcessorConfig();
  const defaultList = [sse, multipart, regular];
  const subscriptionList = [sse, regular];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable2(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!DOCTYPE html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \u{1F440}</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// node_modules/graphql-yoga/esm/process-request.js
var import_graphql40 = __toESM(require_graphql2(), 1);
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document2 = enveloped.parse(params.query);
  const errors = enveloped.validate(enveloped.schema, document2);
  if (errors.length > 0) {
    return { errors };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document: document2,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = (0, import_graphql40.getOperationAST)(document2, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error)) {
    if (error.originalError) {
      if (error.originalError.name === "GraphQLError") {
        return error;
      }
      const extensions = {
        ...error.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error.originalError.message,
          stack: error.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error.nodes,
        source: error.source,
        positions: error.positions,
        path: error.path,
        extensions
      });
    }
    return error;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error instanceof Error ? {
        message: error.message,
        stack: error.stack
      } : error : void 0
    }
  });
};

// node_modules/graphql-yoga/esm/server.js
var YogaServer = class {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser) {
            requestParser = parser;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...defaultFetchAPI
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger = options?.logging == null ? true : options.logging;
    this.logger = typeof logger === "boolean" ? logger === true ? createLogger() : createLogger("silent") : typeof logger === "string" ? createLogger(logger) : logger;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = /* @__PURE__ */ new WeakSet();
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error, message) => {
        if (maskedErrorSet.has(error)) {
          return error;
        }
        const newError = maskErrorFn(error, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error) {
          this.logger.error(error);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse: import_graphql41.parse,
        validate: import_graphql41.validate,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules: import_graphql41.specifiedRules
      }),
      // Use the schema provided by the user
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      // Middlewares before processing the incoming HTTP request
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      // Middlewares before the GraphQL execution
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      // Middlewares after the GraphQL execution
      useResultProcessors(),
      useErrorHandling((error, request) => {
        const errors = handleError(error, this.maskedErrorsOpts, this.logger);
        const result = {
          errors
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      // To make sure those are called at the end
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(
              // @ts-expect-error Add plugins has context but this hook doesn't care
              useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache)
            );
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(
            // @ts-expect-error Add plugins has context but this hook doesn't care
            useUnhandledRoute({
              graphqlEndpoint,
              showLandingPage: options?.landingPage ?? true
            })
          );
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(
            // We handle validation errors at the end
            useHTTPValidationError()
          );
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error) {
      const errors = handleError(error, this.maskedErrorsOpts, this.logger);
      const result = {
        errors
      };
      return result;
    }
  }
};
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

// src/server.ts
var import_node_http = require("node:http");

// src/lib/prisma.ts
var import_client = __toESM(require_client2());
var prisma;
if (process.env.NODE_ENV === "production") {
  prisma = new import_client.PrismaClient();
} else {
  if (!global.prisma) {
    global.prisma = new import_client.PrismaClient();
  }
  prisma = global.prisma;
}
var prisma_default = prisma;

// src/util/helper.ts
var import_bcryptjs = __toESM(require_bcryptjs());
async function hashPassword(password, SALT_WORK_FACTOR = 10) {
  try {
    const salt = await import_bcryptjs.default.genSalt(SALT_WORK_FACTOR);
    return await import_bcryptjs.default.hash(password, salt);
  } catch (error) {
    console.log("error hashing the password : ", error);
    throw new Error("Something went wrong hashing the password");
  }
}
async function comparePassword(password1, password2) {
  return await import_bcryptjs.default.compare(password1, password2);
}
var clearUndefined = (obj = {}) => {
  return Object.keys(obj).reduce((acc, key) => {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
};

// src/services/account/index.ts
async function findOne(input) {
  const filteredObj = clearUndefined(input?.accountFilter ?? {});
  const aAuthInputObj = clearUndefined(input.oAuthFilter || {});
  const account4 = await prisma_default.account.findUnique({
    where: {
      ...filteredObj,
      oAuthClient: {
        every: {
          ...aAuthInputObj
        }
      }
    },
    include: {
      affiliate: true,
      applicant: true,
      company: true,
      oAuthClient: true
    }
  });
  console.log("find one  :  ", account4, input);
  return {
    errors: [],
    account: account4
  };
}
async function getMe(input) {
  const account4 = await prisma_default.account.findUnique({
    where: { id: input.accountId },
    include: {
      applicant: {
        include: {
          // savedJobs: true,
          workExperience: true
        }
      },
      company: true,
      affiliate: true,
      oAuthClient: true
    }
  });
  return account4;
}
async function updateProfile(input) {
  const accountInput = input.account ?? {};
  const applicantInput = input.applicant ?? {};
  const nonNullAccountInput = clearUndefined(accountInput);
  const nonNullApplicantInput = clearUndefined(applicantInput);
  const workExperience = Boolean(nonNullApplicantInput?.workExperience) && Array.isArray(nonNullApplicantInput.workExperience) ? {
    workExperience: {
      deleteMany: {},
      createMany: {
        // where: {},
        data: nonNullApplicantInput.workExperience
      }
    }
  } : {};
  if (Array.isArray(nonNullApplicantInput?.workExperience)) {
    delete nonNullApplicantInput.workExperience;
  }
  console.log(
    "nonNullApplicantInput : ",
    JSON.stringify(nonNullApplicantInput, null, 2)
  );
  const account4 = await prisma_default.account.update({
    where: { id: input.accountId },
    data: {
      ...nonNullAccountInput,
      applicant: {
        update: {
          data: {
            ...nonNullApplicantInput,
            ...workExperience
          }
        }
      }
    },
    include: {
      applicant: true,
      company: true,
      affiliate: true,
      oAuthClient: true
    }
  });
  if (account4 == null) {
    return {
      errors: [
        {
          message: "Account not found"
        }
      ],
      account: null
    };
  }
  return {
    errors: [],
    account: account4
  };
}
var account = {
  findOne,
  getMe,
  updateProfile
};
var account_default = account;

// src/services/job/index.ts
async function getPostedJobs(input) {
  const filter = Object.keys(input ?? {}).reduce((acc, key) => {
    if (input?.[key] !== void 0) {
      acc[key] = input[key];
    }
    return acc;
  }, {});
  const jobPosts = await prisma_default.jobPost.findMany({
    where: {
      ...filter
    },
    include: {
      affiliate: true,
      company: true
    }
    // take: 5,
    // skip: 1, // Skip the cursor
    // cursor: {
    //   id: myCursor,
    // },
  });
  return jobPosts;
}
async function getCompanyPostedJobs(input) {
  const jobPosts = await prisma_default.jobPost.findMany({
    where: {
      companyId: input.companyId
    },
    include: {
      // company: true,
    }
  });
  return {
    errors: [],
    jobPosts
  };
}
async function getJobPostApplications(input) {
  const jobApplications = await prisma_default.jobApplication.findMany({
    where: {
      jobPostId: input.jobPostId
    },
    include: {
      applicant: true
    }
  });
  return {
    errors: [],
    payload: jobApplications.map((ja2) => ({
      application: ja2,
      applicant: ja2.applicant
    }))
  };
}
async function getSavedJobs(input) {
  const jobPosts = await prisma_default.jobPost.findMany({
    where: {
      savedBy: {
        every: {
          accountId: input.accountId
        }
      }
    },
    include: {
      affiliate: true,
      company: true,
      savedBy: true
    }
  });
  return jobPosts;
}
async function createJobPost(input) {
  const jobPost2 = await prisma_default.jobPost.create({
    data: {
      title: input.title,
      description: input.description,
      jobSite: input.jobSite,
      jobType: input.jobType,
      email: input.email,
      category: input.category,
      vacancy: input.vacancy,
      applicationDeadline: input.applicationDeadline,
      englishLevel: input.englishLevel,
      salaryType: input.salaryType,
      skills: input.skills,
      interviewQuestions: input.interviewQuestions,
      location: input.location,
      experienceLevel: input.experienceLevel,
      salary: input.salary,
      jobExperience: input.jobExperience,
      isVisible: input.isVisible,
      otherLanguages: input.otherLanguages,
      companyId: input.companyId
      // affiliate? @relation(fields: [affiliateId], references: [id])
      // affiliateId String?
    }
  });
  return {
    errors: [],
    jobPost: jobPost2
  };
}
async function editJobPost(input) {
  const nunNullEditedInput = clearUndefined(input.editedData);
  console.log("edit input : ", nunNullEditedInput);
  const jobPost2 = await prisma_default.jobPost.update({
    where: {
      id: input.filter.jobPostId,
      companyId: input.filter.companyId
    },
    data: {
      ...nunNullEditedInput
    }
  });
  console.log("updated jobpost : ", jobPost2);
  if (jobPost2 == null) {
    return {
      errors: [
        {
          message: "jobPost not found"
        }
      ],
      jobPost: null
    };
  }
  return {
    errors: [],
    jobPost: jobPost2
  };
}
async function saveJobPost(input) {
  const jobPost2 = await prisma_default.applicant.update({
    data: {
      savedJobs: {
        ...Boolean(input.save) && {
          connect: {
            id: input.jobPostId
          }
        },
        ...!input.save && {
          disconnect: {
            id: input.jobPostId
          }
        }
      }
    },
    where: {
      accountId: input.accountId
    },
    include: {
      savedJobs: true
    }
  });
  return jobPost2.savedJobs.find((p) => p.id === input.jobPostId) ?? null;
}
async function getJobPost(input) {
  const jobPost2 = await prisma_default.jobPost.findUnique({
    where: {
      id: input.id
    },
    include: {
      // company: true,
      // affiliate: true,
      // savedBy: true,
    }
  });
  return jobPost2;
}
var jobPost = {
  getPostedJobs,
  createJobPost,
  getSavedJobs,
  saveJobPost,
  getJobPost,
  editJobPost,
  getCompanyPostedJobs,
  getJobPostApplications
};
var job_default = jobPost;

// src/services/auth/index.ts
async function signUp(input) {
  const { firstName, lastName, country, password, email, accountType } = input;
  const ifExist = await prisma_default.account.findUnique({
    where: {
      email
    }
  });
  if (ifExist != null) {
    return {
      errors: [
        {
          message: "Account already exist"
        }
      ],
      account: null
    };
  }
  const hashedPassword = await hashPassword(password);
  const newCompany = await prisma_default.account.create({
    data: {
      email,
      firstName,
      fullName: firstName + " " + lastName,
      lastName,
      password: hashedPassword,
      country,
      accountType,
      isVerified: false,
      userName: firstName,
      image: `${process.env.NEXT_PUBLIC_S3_CLOUD_FRONT_URL}/logo.png`,
      ...accountType === "COMPANY" ? {
        company: {
          create: {
            companyName: input?.companyName ?? firstName
          }
        }
      } : accountType === "APPLICANT" ? {
        applicant: {
          create: {}
        }
      } : accountType === "AFFILIATE" ? {
        affiliate: {
          create: {}
        }
      } : {}
    },
    include: {
      company: true,
      applicant: true,
      affiliate: true,
      oAuthClient: true
    }
  });
  return {
    errors: [],
    account: newCompany
  };
}
async function signUpOAuth(input) {
  const { accountType } = input.account;
  const newCompany = await prisma_default.account.create({
    data: {
      ...input.account,
      image: input.account.image ?? `${process.env.NEXT_PUBLIC_S3_CLOUD_FRONT_URL}/logo.png`,
      accountType,
      fullName: input.account.firstName + " " + input.account.lastName,
      emailVerified: /* @__PURE__ */ new Date(),
      password: "-",
      isVerified: true,
      oAuthClient: {
        create: {
          ...input.OAuth
        }
      },
      ...accountType === "COMPANY" ? {
        company: {
          create: {}
        }
      } : accountType === "APPLICANT" ? {
        applicant: {
          create: {}
        }
      } : accountType === "AFFILIATE" ? {
        affiliate: {
          create: {}
        }
      } : {}
    },
    include: {
      company: true,
      applicant: true,
      affiliate: true,
      oAuthClient: true
    }
  });
  console.log("createdUser with ---> ", newCompany);
  return {
    errors: [],
    account: newCompany
  };
}
async function logIn(input) {
  const { email, password } = input;
  const account4 = await prisma_default.account.findUnique({
    where: { email },
    include: {
      applicant: true,
      company: true,
      affiliate: true,
      oAuthClient: true
    }
  });
  if (account4 == null) {
    return {
      errors: [
        {
          message: "Account Not Found!"
        }
      ],
      account: null
    };
  }
  if (account4.oAuthClient.length > 0) {
    return {
      errors: [
        {
          message: "This account created with social link, please login with your social link"
        }
      ],
      account: null
    };
  }
  const isMatch = await comparePassword(password, account4.password);
  if (!isMatch) {
    return {
      errors: [
        {
          message: "Invalid email or password"
        }
      ],
      account: null
    };
  }
  console.log("login with ---> ", account4);
  return {
    errors: [],
    account: {
      ...account4
    }
  };
}
var auth_default = {
  signUp,
  signUpOAuth,
  logIn
};

// src/services/company/index.ts
var import_error8 = __toESM(require_error());
async function getCompanies() {
  const companies = await prisma_default.company.findMany({
    where: {},
    include: {
      // account: true,
    }
  });
  return companies;
}
async function getSavedApplicants(input) {
  const company = await prisma_default.company.findUnique({
    where: {
      id: input.companyId
    },
    include: {
      savedApplicants: true
    }
  });
  if (company === null) {
    throw new import_error8.GraphQLError(`No company found with id ${input.companyId}`);
  }
  return company.savedApplicants;
}
async function saveApplicant(input) {
  const company = await prisma_default.company.update({
    where: {
      id: input.companyId
    },
    data: {
      savedApplicants: {
        ...input.save === true ? {
          connect: {
            id: input.applicantId
          }
        } : {
          disconnect: {
            id: input.applicantId
          }
        }
      }
    },
    include: {
      savedApplicants: true
    }
  });
  if (company === null) {
    throw new import_error8.GraphQLError(
      `Fail to save applicant with id : ${input.applicantId}`
    );
  }
  console.log("saved-- applicant : ", company.savedApplicants.length);
  return company.savedApplicants.length !== 0;
}
async function getCompanyAccount(input) {
  const applicant = await prisma_default.company.findUnique({
    where: {
      id: input.id
    },
    include: {
      account: true
    }
  });
  return applicant?.account ?? null;
}
async function acceptApplicationAndCreateInterview(input) {
  let application = await prisma_default.jobApplication.findUnique({
    where: {
      id: input.applicationId
    }
  });
  if (application === null) {
    throw new import_error8.GraphQLError(
      `No application found with id : ${input.applicationId}`
    );
  }
  application = await prisma_default.jobApplication.update({
    where: {
      id: input.applicationId
    },
    data: {
      status: "INTERVIEW"
    }
  });
  const newInterview = await prisma_default.interview.create({
    data: {
      applicantId: application.applicantId,
      companyId: application.companyId,
      jobPostId: application.jobPostId,
      jobApplicationId: application.id,
      description: input.description,
      deadline: input.date,
      status: "PENDING"
    }
  });
  return newInterview;
}
async function acceptInterviewAndCreateOffer(input) {
  const application = await prisma_default.jobApplication.update({
    where: {
      id: input.applicationId,
      applicantId: input.applicantId
    },
    data: {
      status: "OFFER",
      interview: {
        update: {
          status: "ACCEPTED"
        }
      }
    }
  });
  if (application === null) {
    throw new import_error8.GraphQLError(
      `No application found with id : ${input.applicationId}`
    );
  }
  const newOffer = await prisma_default.offer.create({
    data: {
      applicantId: application.applicantId,
      companyId: application.companyId,
      jobPostId: application.jobPostId,
      jobApplicationId: application.id,
      description: input.description,
      deadline: /* @__PURE__ */ new Date(),
      status: "PENDING"
    }
  });
  return newOffer;
}
var account2 = {
  getCompanies,
  getSavedApplicants,
  saveApplicant,
  getCompanyAccount,
  acceptApplicationAndCreateInterview,
  acceptInterviewAndCreateOffer
};
var company_default = account2;

// src/services/applicant/index.ts
var import_client2 = __toESM(require_client());
var import_error9 = __toESM(require_error());
async function getAllApplicants(input) {
  const applicant = await prisma_default.applicant.findMany({
    where: {},
    include: {
      // account: true,
      _count: true
    },
    take: input.first ?? void 0,
    skip: input.after != null ? 1 : 0,
    ...input.after != null ? {
      cursor: { id: input.after }
    } : {}
  });
  return applicant;
}
async function getApplicant(input) {
  const applicant = await prisma_default.applicant.findUnique({
    where: {
      id: input.id
    },
    include: {
      // account: true,
      // workExperience: true,
      // savedJobs: true,
    }
  });
  return applicant;
}
async function getApplicantAccount(input) {
  const applicant = await prisma_default.applicant.findUnique({
    where: {
      id: input.id
    },
    include: {
      account: true
    }
  });
  return applicant?.account ?? null;
}
async function getSavedJobs2(input) {
  const savedJobs = await prisma_default.jobPost.findMany({
    where: {
      savedBy: {
        some: {
          id: input.id
        }
      }
    }
  });
  return savedJobs;
}
async function getJobApplications(input) {
  const filter = clearUndefined(input.filter ?? {});
  console.log("getJobApplications filter : ", filter);
  const applications = await prisma_default.jobApplication.findMany({
    where: {
      ...filter,
      ...filter?.ids ? { id: { in: filter?.ids } } : {}
    },
    include: {
      interview: true,
      offer: true
    }
  });
  return applications;
}
async function getWorkExperience(input) {
  const workExperience = await prisma_default.workExperience.findMany({
    where: {
      // id: ,
      applicant: {
        id: input.id
      }
    }
  });
  return workExperience;
}
async function createApplication(input) {
  const application = await prisma_default.jobApplication.create({
    data: {
      applicantId: input.applicantId,
      jobPostId: input.jobPostId,
      companyId: input.companyId,
      status: import_client2.ApplicationStatus.PENDING,
      resume: input.resume,
      coverLetter: input.coverLetter,
      attachment: input.attachment,
      email: input.email,
      phone: input.phone
    }
  });
  return {
    errors: [],
    application
  };
}
async function respondInterview(input) {
  const updatedInterview = await prisma_default.interview.update({
    where: {
      id: input.interviewId,
      applicantId: input.applicantId
    },
    data: {
      status: input?.refuse ? "APPLICANT_REFUSED" : "APPLICANT_RESPONDED",
      answerVideo: input.interviewVideoUrl
    }
  });
  return updatedInterview;
}
async function respondOffer(input) {
  let updatedOffer = await prisma_default.jobApplication.update({
    where: {
      id: input.applicationId,
      applicantId: input.applicantId
    },
    data: {
      status: input.refuse ? "OFFER" : "ACCEPTED",
      offer: {
        update: {
          status: input.refuse ? "APPLICANT_REFUSED" : "ACCEPTED"
        }
      }
    },
    include: {
      offer: true
    }
  });
  if (updatedOffer?.offer === null) {
    throw new import_error9.GraphQLError(
      `Fail to save applicant with id : ${"input.applicantId"}`
    );
  }
  return updatedOffer.offer;
}
var account3 = {
  getApplicant,
  getAllApplicants,
  getSavedJobs: getSavedJobs2,
  getWorkExperience,
  getApplicantAccount,
  getJobApplications,
  createApplication,
  respondInterview,
  respondOffer
};
var applicant_default = account3;

// src/services/index.ts
var Services = {
  Account: account_default,
  Job: job_default,
  Auth: auth_default,
  Company: company_default,
  Applicant: applicant_default
};
var services_default = Services;

// src/graphql/context.ts
function createContext(initialCtx) {
  return {
    me: null,
    service: services_default,
    prisma: prisma_default,
    ...initialCtx
  };
}

// src/graphql/schema/typeDefs.generated.ts
var typeDefs = { "kind": "Document", "definitions": [{ "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Query", "loc": { "start": 12, "end": 17 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "me", "loc": { "start": 22, "end": 24 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 25, "end": 30 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MeInput", "loc": { "start": 32, "end": 39 } }, "loc": { "start": 32, "end": 39 } }, "loc": { "start": 32, "end": 40 } }, "directives": [], "loc": { "start": 25, "end": 40 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountPayload", "loc": { "start": 43, "end": 57 } }, "loc": { "start": 43, "end": 57 } }, "directives": [], "loc": { "start": 22, "end": 57 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "findAccount", "loc": { "start": 60, "end": 71 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 72, "end": 77 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FindAccountFilterInput", "loc": { "start": 79, "end": 101 } }, "loc": { "start": 79, "end": 101 } }, "loc": { "start": 79, "end": 102 } }, "directives": [], "loc": { "start": 72, "end": 102 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FindOnePayload", "loc": { "start": 105, "end": 119 } }, "loc": { "start": 105, "end": 119 } }, "directives": [], "loc": { "start": 60, "end": 119 } }], "loc": { "start": 0, "end": 121 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 135, "end": 143 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "profileUpdate", "loc": { "start": 148, "end": 161 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 162, "end": 167 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UpdateProfileInput", "loc": { "start": 169, "end": 187 } }, "loc": { "start": 169, "end": 187 } }, "loc": { "start": 169, "end": 188 } }, "directives": [], "loc": { "start": 162, "end": 188 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountUpdate", "loc": { "start": 191, "end": 204 } }, "loc": { "start": 191, "end": 204 } }, "loc": { "start": 191, "end": 205 } }, "directives": [], "loc": { "start": 148, "end": 205 } }], "loc": { "start": 123, "end": 207 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AccountUpdate", "loc": { "start": 214, "end": 227 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "PayloadError", "loc": { "start": 239, "end": 251 } }, "loc": { "start": 239, "end": 251 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 256, "end": 262 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 265, "end": 270 } }, "loc": { "start": 265, "end": 270 } }, "loc": { "start": 265, "end": 271 } }, "loc": { "start": 264, "end": 272 } }, "loc": { "start": 264, "end": 273 } }, "directives": [], "loc": { "start": 256, "end": 273 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 276, "end": 283 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountPayload", "loc": { "start": 285, "end": 299 } }, "loc": { "start": 285, "end": 299 } }, "directives": [], "loc": { "start": 276, "end": 299 } }], "loc": { "start": 209, "end": 301 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "UpdateProfileInput", "loc": { "start": 309, "end": 327 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountId", "loc": { "start": 332, "end": 341 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 343, "end": 349 } }, "loc": { "start": 343, "end": 349 } }, "loc": { "start": 343, "end": 350 } }, "directives": [], "loc": { "start": 332, "end": 350 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 353, "end": 360 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountUpdateInput", "loc": { "start": 362, "end": 380 } }, "loc": { "start": 362, "end": 380 } }, "directives": [], "loc": { "start": 353, "end": 380 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicant", "loc": { "start": 383, "end": 392 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantUpdateInput", "loc": { "start": 394, "end": 414 } }, "loc": { "start": 394, "end": 414 } }, "directives": [], "loc": { "start": 383, "end": 414 } }], "loc": { "start": 303, "end": 416 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "AccountUpdateInput", "loc": { "start": 424, "end": 442 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 447, "end": 456 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 458, "end": 464 } }, "loc": { "start": 458, "end": 464 } }, "directives": [], "loc": { "start": 447, "end": 464 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 467, "end": 475 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 477, "end": 483 } }, "loc": { "start": 477, "end": 483 } }, "directives": [], "loc": { "start": 467, "end": 483 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 486, "end": 491 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 493, "end": 499 } }, "loc": { "start": 493, "end": 499 } }, "directives": [], "loc": { "start": 486, "end": 499 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 502, "end": 507 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 509, "end": 515 } }, "loc": { "start": 509, "end": 515 } }, "directives": [], "loc": { "start": 502, "end": 515 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 518, "end": 523 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 525, "end": 531 } }, "loc": { "start": 525, "end": 531 } }, "directives": [], "loc": { "start": 518, "end": 531 } }], "loc": { "start": 418, "end": 533 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "WorkExperienceInput", "loc": { "start": 541, "end": 560 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyName", "loc": { "start": 565, "end": 576 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 578, "end": 584 } }, "loc": { "start": 578, "end": 584 } }, "loc": { "start": 578, "end": 585 } }, "directives": [], "loc": { "start": 565, "end": 585 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyWebsite", "loc": { "start": 588, "end": 602 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 604, "end": 610 } }, "loc": { "start": 604, "end": 610 } }, "directives": [], "loc": { "start": 588, "end": 610 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "position", "loc": { "start": 613, "end": 621 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 623, "end": 629 } }, "loc": { "start": 623, "end": 629 } }, "loc": { "start": 623, "end": 630 } }, "directives": [], "loc": { "start": 613, "end": 630 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "startDate", "loc": { "start": 633, "end": 642 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 644, "end": 652 } }, "loc": { "start": 644, "end": 652 } }, "loc": { "start": 644, "end": 653 } }, "directives": [], "loc": { "start": 633, "end": 653 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "endDate", "loc": { "start": 656, "end": 663 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 665, "end": 673 } }, "loc": { "start": 665, "end": 673 } }, "directives": [], "loc": { "start": 656, "end": 673 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "ongoing", "loc": { "start": 676, "end": 683 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 685, "end": 692 } }, "loc": { "start": 685, "end": 692 } }, "loc": { "start": 685, "end": 693 } }, "directives": [], "loc": { "start": 676, "end": 693 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accomplishment", "loc": { "start": 696, "end": 710 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 712, "end": 718 } }, "loc": { "start": 712, "end": 718 } }, "loc": { "start": 712, "end": 719 } }, "directives": [], "loc": { "start": 696, "end": 719 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 722, "end": 728 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 731, "end": 737 } }, "loc": { "start": 731, "end": 737 } }, "loc": { "start": 731, "end": 738 } }, "loc": { "start": 730, "end": 739 } }, "loc": { "start": 730, "end": 740 } }, "directives": [], "loc": { "start": 722, "end": 740 } }], "loc": { "start": 535, "end": 742 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AccountPayload", "loc": { "start": 749, "end": 763 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 768, "end": 770 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 772, "end": 778 } }, "loc": { "start": 772, "end": 778 } }, "loc": { "start": 772, "end": 779 } }, "directives": [], "loc": { "start": 768, "end": 779 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 782, "end": 787 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 789, "end": 795 } }, "loc": { "start": 789, "end": 795 } }, "loc": { "start": 789, "end": 796 } }, "directives": [], "loc": { "start": 782, "end": 796 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "emailVerified", "loc": { "start": 799, "end": 812 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 814, "end": 822 } }, "loc": { "start": 814, "end": 822 } }, "directives": [], "loc": { "start": 799, "end": 822 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 825, "end": 834 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 836, "end": 842 } }, "loc": { "start": 836, "end": 842 } }, "loc": { "start": 836, "end": 843 } }, "directives": [], "loc": { "start": 825, "end": 843 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 846, "end": 854 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 856, "end": 862 } }, "loc": { "start": 856, "end": 862 } }, "loc": { "start": 856, "end": 863 } }, "directives": [], "loc": { "start": 846, "end": 863 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 866, "end": 875 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 877, "end": 885 } }, "loc": { "start": 877, "end": 885 } }, "loc": { "start": 877, "end": 886 } }, "directives": [], "loc": { "start": 866, "end": 886 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 889, "end": 900 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 902, "end": 913 } }, "loc": { "start": 902, "end": 913 } }, "loc": { "start": 902, "end": 914 } }, "directives": [], "loc": { "start": 889, "end": 914 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 917, "end": 922 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 924, "end": 930 } }, "loc": { "start": 924, "end": 930 } }, "directives": [], "loc": { "start": 917, "end": 930 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 933, "end": 938 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 940, "end": 946 } }, "loc": { "start": 940, "end": 946 } }, "directives": [], "loc": { "start": 933, "end": 946 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "oAuthClient", "loc": { "start": 949, "end": 960 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuth", "loc": { "start": 963, "end": 968 } }, "loc": { "start": 963, "end": 968 } }, "loc": { "start": 963, "end": 969 } }, "loc": { "start": 962, "end": 970 } }, "loc": { "start": 962, "end": 971 } }, "directives": [], "loc": { "start": 949, "end": 971 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "company", "loc": { "start": 974, "end": 981 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Company", "loc": { "start": 983, "end": 990 } }, "loc": { "start": 983, "end": 990 } }, "directives": [], "loc": { "start": 974, "end": 990 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicant", "loc": { "start": 993, "end": 1002 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 1004, "end": 1013 } }, "loc": { "start": 1004, "end": 1013 } }, "directives": [], "loc": { "start": 993, "end": 1013 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "affiliate", "loc": { "start": 1016, "end": 1025 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AffiliateLight", "loc": { "start": 1027, "end": 1041 } }, "loc": { "start": 1027, "end": 1041 } }, "directives": [], "loc": { "start": 1016, "end": 1041 } }], "loc": { "start": 744, "end": 1043 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "MeInput", "loc": { "start": 1051, "end": 1058 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountId", "loc": { "start": 1063, "end": 1072 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1074, "end": 1080 } }, "loc": { "start": 1074, "end": 1080 } }, "loc": { "start": 1074, "end": 1081 } }, "directives": [], "loc": { "start": 1063, "end": 1081 } }], "loc": { "start": 1045, "end": 1083 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "FindAccountFilterInput", "loc": { "start": 1091, "end": 1113 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountFilter", "loc": { "start": 1118, "end": 1131 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountFilterInput", "loc": { "start": 1133, "end": 1151 } }, "loc": { "start": 1133, "end": 1151 } }, "directives": [], "loc": { "start": 1118, "end": 1151 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "oAuthFilter", "loc": { "start": 1154, "end": 1165 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuthAccountFilterInput", "loc": { "start": 1167, "end": 1190 } }, "loc": { "start": 1167, "end": 1190 } }, "directives": [], "loc": { "start": 1154, "end": 1190 } }], "loc": { "start": 1085, "end": 1192 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuthAccountFilterInput", "loc": { "start": 1200, "end": 1223 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "provider", "loc": { "start": 1228, "end": 1236 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1238, "end": 1244 } }, "loc": { "start": 1238, "end": 1244 } }, "directives": [], "loc": { "start": 1228, "end": 1244 } }], "loc": { "start": 1194, "end": 1246 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "AccountFilterInput", "loc": { "start": 1254, "end": 1272 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 1277, "end": 1279 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 1281, "end": 1283 } }, "loc": { "start": 1281, "end": 1283 } }, "directives": [], "loc": { "start": 1277, "end": 1283 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 1286, "end": 1291 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1293, "end": 1299 } }, "loc": { "start": 1293, "end": 1299 } }, "directives": [], "loc": { "start": 1286, "end": 1299 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 1302, "end": 1307 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1309, "end": 1315 } }, "loc": { "start": 1309, "end": 1315 } }, "directives": [], "loc": { "start": 1302, "end": 1315 } }], "loc": { "start": 1248, "end": 1317 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 1324, "end": 1335 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "COMPANY", "loc": { "start": 1340, "end": 1347 } }, "directives": [], "loc": { "start": 1340, "end": 1347 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "APPLICANT", "loc": { "start": 1350, "end": 1359 } }, "directives": [], "loc": { "start": 1350, "end": 1359 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "AFFILIATE", "loc": { "start": 1362, "end": 1371 } }, "directives": [], "loc": { "start": 1362, "end": 1371 } }], "loc": { "start": 1319, "end": 1373 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "Gender", "loc": { "start": 1380, "end": 1386 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "MALE", "loc": { "start": 1391, "end": 1395 } }, "directives": [], "loc": { "start": 1391, "end": 1395 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "FEMALE", "loc": { "start": 1398, "end": 1404 } }, "directives": [], "loc": { "start": 1398, "end": 1404 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "OTHER", "loc": { "start": 1407, "end": 1412 } }, "directives": [], "loc": { "start": 1407, "end": 1412 } }], "loc": { "start": 1375, "end": 1414 } }, { "kind": "InterfaceTypeDefinition", "name": { "kind": "Name", "value": "IAccount", "loc": { "start": 1426, "end": 1434 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 1439, "end": 1441 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1443, "end": 1449 } }, "loc": { "start": 1443, "end": 1449 } }, "loc": { "start": 1443, "end": 1450 } }, "directives": [], "loc": { "start": 1439, "end": 1450 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 1453, "end": 1458 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1460, "end": 1466 } }, "loc": { "start": 1460, "end": 1466 } }, "loc": { "start": 1460, "end": 1467 } }, "directives": [], "loc": { "start": 1453, "end": 1467 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "emailVerified", "loc": { "start": 1470, "end": 1483 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 1485, "end": 1493 } }, "loc": { "start": 1485, "end": 1493 } }, "directives": [], "loc": { "start": 1470, "end": 1493 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 1496, "end": 1505 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1507, "end": 1513 } }, "loc": { "start": 1507, "end": 1513 } }, "loc": { "start": 1507, "end": 1514 } }, "directives": [], "loc": { "start": 1496, "end": 1514 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 1517, "end": 1525 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1527, "end": 1533 } }, "loc": { "start": 1527, "end": 1533 } }, "loc": { "start": 1527, "end": 1534 } }, "directives": [], "loc": { "start": 1517, "end": 1534 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 1537, "end": 1548 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 1550, "end": 1561 } }, "loc": { "start": 1550, "end": 1561 } }, "loc": { "start": 1550, "end": 1562 } }, "directives": [], "loc": { "start": 1537, "end": 1562 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 1565, "end": 1574 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 1576, "end": 1584 } }, "loc": { "start": 1576, "end": 1584 } }, "loc": { "start": 1576, "end": 1585 } }, "directives": [], "loc": { "start": 1565, "end": 1585 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 1588, "end": 1593 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1595, "end": 1601 } }, "loc": { "start": 1595, "end": 1601 } }, "directives": [], "loc": { "start": 1588, "end": 1601 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 1604, "end": 1609 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1611, "end": 1617 } }, "loc": { "start": 1611, "end": 1617 } }, "directives": [], "loc": { "start": 1604, "end": 1617 } }], "loc": { "start": 1416, "end": 1619 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Account", "loc": { "start": 1626, "end": 1633 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "IAccount", "loc": { "start": 1645, "end": 1653 } }, "loc": { "start": 1645, "end": 1653 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 1658, "end": 1660 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1662, "end": 1668 } }, "loc": { "start": 1662, "end": 1668 } }, "loc": { "start": 1662, "end": 1669 } }, "directives": [], "loc": { "start": 1658, "end": 1669 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 1672, "end": 1677 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1679, "end": 1685 } }, "loc": { "start": 1679, "end": 1685 } }, "loc": { "start": 1679, "end": 1686 } }, "directives": [], "loc": { "start": 1672, "end": 1686 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "emailVerified", "loc": { "start": 1689, "end": 1702 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 1704, "end": 1712 } }, "loc": { "start": 1704, "end": 1712 } }, "directives": [], "loc": { "start": 1689, "end": 1712 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 1715, "end": 1724 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1726, "end": 1732 } }, "loc": { "start": 1726, "end": 1732 } }, "loc": { "start": 1726, "end": 1733 } }, "directives": [], "loc": { "start": 1715, "end": 1733 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 1736, "end": 1744 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1746, "end": 1752 } }, "loc": { "start": 1746, "end": 1752 } }, "loc": { "start": 1746, "end": 1753 } }, "directives": [], "loc": { "start": 1736, "end": 1753 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "fullName", "loc": { "start": 1756, "end": 1764 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1766, "end": 1772 } }, "loc": { "start": 1766, "end": 1772 } }, "loc": { "start": 1766, "end": 1773 } }, "directives": [], "loc": { "start": 1756, "end": 1773 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 1776, "end": 1787 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 1789, "end": 1800 } }, "loc": { "start": 1789, "end": 1800 } }, "loc": { "start": 1789, "end": 1801 } }, "directives": [], "loc": { "start": 1776, "end": 1801 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 1804, "end": 1813 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 1815, "end": 1823 } }, "loc": { "start": 1815, "end": 1823 } }, "loc": { "start": 1815, "end": 1824 } }, "directives": [], "loc": { "start": 1804, "end": 1824 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 1827, "end": 1832 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1834, "end": 1840 } }, "loc": { "start": 1834, "end": 1840 } }, "directives": [], "loc": { "start": 1827, "end": 1840 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 1843, "end": 1848 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 1850, "end": 1856 } }, "loc": { "start": 1850, "end": 1856 } }, "loc": { "start": 1850, "end": 1857 } }, "directives": [], "loc": { "start": 1843, "end": 1857 } }], "loc": { "start": 1621, "end": 1859 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "AccountSortField", "loc": { "start": 1866, "end": 1882 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Sort users by created at.", "block": false, "loc": { "start": 1887, "end": 1914 } }, "name": { "kind": "Name", "value": "CREATED_AT", "loc": { "start": 1917, "end": 1927 } }, "directives": [], "loc": { "start": 1887, "end": 1927 } }, { "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Sort users by email.", "block": false, "loc": { "start": 1930, "end": 1952 } }, "name": { "kind": "Name", "value": "EMAIL", "loc": { "start": 1955, "end": 1960 } }, "directives": [], "loc": { "start": 1930, "end": 1960 } }, { "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Sort users by first name.", "block": false, "loc": { "start": 1963, "end": 1990 } }, "name": { "kind": "Name", "value": "FIRST_NAME", "loc": { "start": 1993, "end": 2003 } }, "directives": [], "loc": { "start": 1963, "end": 2003 } }, { "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Sort users by last modified at.", "block": false, "loc": { "start": 2006, "end": 2039 } }, "name": { "kind": "Name", "value": "LAST_MODIFIED_AT", "loc": { "start": 2042, "end": 2058 } }, "directives": [], "loc": { "start": 2006, "end": 2058 } }, { "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Sort users by last name.", "block": false, "loc": { "start": 2061, "end": 2087 } }, "name": { "kind": "Name", "value": "LAST_NAME", "loc": { "start": 2090, "end": 2099 } }, "directives": [], "loc": { "start": 2061, "end": 2099 } }], "loc": { "start": 1861, "end": 2101 } }, { "kind": "ScalarTypeDefinition", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 2110, "end": 2118 } }, "directives": [], "loc": { "start": 2103, "end": 2118 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Affiliate", "loc": { "start": 2124, "end": 2133 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "IAccount", "loc": { "start": 2145, "end": 2153 } }, "loc": { "start": 2145, "end": 2153 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 2158, "end": 2160 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2162, "end": 2168 } }, "loc": { "start": 2162, "end": 2168 } }, "loc": { "start": 2162, "end": 2169 } }, "directives": [], "loc": { "start": 2158, "end": 2169 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 2172, "end": 2177 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2179, "end": 2185 } }, "loc": { "start": 2179, "end": 2185 } }, "loc": { "start": 2179, "end": 2186 } }, "directives": [], "loc": { "start": 2172, "end": 2186 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "emailVerified", "loc": { "start": 2189, "end": 2202 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 2204, "end": 2212 } }, "loc": { "start": 2204, "end": 2212 } }, "directives": [], "loc": { "start": 2189, "end": 2212 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 2215, "end": 2224 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2226, "end": 2232 } }, "loc": { "start": 2226, "end": 2232 } }, "loc": { "start": 2226, "end": 2233 } }, "directives": [], "loc": { "start": 2215, "end": 2233 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 2236, "end": 2244 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2246, "end": 2252 } }, "loc": { "start": 2246, "end": 2252 } }, "loc": { "start": 2246, "end": 2253 } }, "directives": [], "loc": { "start": 2236, "end": 2253 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 2256, "end": 2265 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 2267, "end": 2275 } }, "loc": { "start": 2267, "end": 2275 } }, "loc": { "start": 2267, "end": 2276 } }, "directives": [], "loc": { "start": 2256, "end": 2276 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 2279, "end": 2290 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 2292, "end": 2303 } }, "loc": { "start": 2292, "end": 2303 } }, "loc": { "start": 2292, "end": 2304 } }, "directives": [], "loc": { "start": 2279, "end": 2304 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 2307, "end": 2312 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2314, "end": 2320 } }, "loc": { "start": 2314, "end": 2320 } }, "directives": [], "loc": { "start": 2307, "end": 2320 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 2323, "end": 2328 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2330, "end": 2336 } }, "loc": { "start": 2330, "end": 2336 } }, "directives": [], "loc": { "start": 2323, "end": 2336 } }], "loc": { "start": 2119, "end": 2338 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AffiliateLight", "loc": { "start": 2345, "end": 2359 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 2364, "end": 2366 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2368, "end": 2374 } }, "loc": { "start": 2368, "end": 2374 } }, "loc": { "start": 2368, "end": 2375 } }, "directives": [], "loc": { "start": 2364, "end": 2375 } }], "loc": { "start": 2340, "end": 2377 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Query", "loc": { "start": 2390, "end": 2395 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getApplicants", "loc": { "start": 2400, "end": 2413 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2414, "end": 2419 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetApplicantsInput", "loc": { "start": 2421, "end": 2439 } }, "loc": { "start": 2421, "end": 2439 } }, "loc": { "start": 2421, "end": 2440 } }, "directives": [], "loc": { "start": 2414, "end": 2440 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantConnection", "loc": { "start": 2443, "end": 2462 } }, "loc": { "start": 2443, "end": 2462 } }, "directives": [], "loc": { "start": 2400, "end": 2462 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getApplicant", "loc": { "start": 2465, "end": 2477 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2478, "end": 2483 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetApplicantInput", "loc": { "start": 2485, "end": 2502 } }, "loc": { "start": 2485, "end": 2502 } }, "loc": { "start": 2485, "end": 2503 } }, "directives": [], "loc": { "start": 2478, "end": 2503 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 2506, "end": 2515 } }, "loc": { "start": 2506, "end": 2515 } }, "directives": [], "loc": { "start": 2465, "end": 2515 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getJobApplications", "loc": { "start": 2518, "end": 2536 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2537, "end": 2542 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetJobApplicationsInput", "loc": { "start": 2544, "end": 2567 } }, "loc": { "start": 2544, "end": 2567 } }, "loc": { "start": 2544, "end": 2568 } }, "directives": [], "loc": { "start": 2537, "end": 2568 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationConnections", "loc": { "start": 2571, "end": 2593 } }, "loc": { "start": 2571, "end": 2593 } }, "loc": { "start": 2571, "end": 2594 } }, "directives": [], "loc": { "start": 2518, "end": 2594 } }], "loc": { "start": 2378, "end": 2596 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 2610, "end": 2618 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicantProfileUpdate", "loc": { "start": 2623, "end": 2645 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2646, "end": 2651 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantProfileUpdateInput", "loc": { "start": 2653, "end": 2680 } }, "loc": { "start": 2653, "end": 2680 } }, "loc": { "start": 2653, "end": 2681 } }, "directives": [], "loc": { "start": 2646, "end": 2681 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountUpdate", "loc": { "start": 2684, "end": 2697 } }, "loc": { "start": 2684, "end": 2697 } }, "loc": { "start": 2684, "end": 2698 } }, "directives": [], "loc": { "start": 2623, "end": 2698 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createApplication", "loc": { "start": 2701, "end": 2718 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2719, "end": 2724 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateApplicationInput", "loc": { "start": 2726, "end": 2748 } }, "loc": { "start": 2726, "end": 2748 } }, "loc": { "start": 2726, "end": 2749 } }, "directives": [], "loc": { "start": 2719, "end": 2749 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateApplicationPayload", "loc": { "start": 2752, "end": 2776 } }, "loc": { "start": 2752, "end": 2776 } }, "loc": { "start": 2752, "end": 2777 } }, "directives": [], "loc": { "start": 2701, "end": 2777 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "respondInterview", "loc": { "start": 2780, "end": 2796 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2797, "end": 2802 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "RespondInterviewInput", "loc": { "start": 2804, "end": 2825 } }, "loc": { "start": 2804, "end": 2825 } }, "loc": { "start": 2804, "end": 2826 } }, "directives": [], "loc": { "start": 2797, "end": 2826 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Interview", "loc": { "start": 2829, "end": 2838 } }, "loc": { "start": 2829, "end": 2838 } }, "directives": [], "loc": { "start": 2780, "end": 2838 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "respondToOffer", "loc": { "start": 2841, "end": 2855 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 2856, "end": 2861 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "RespondOfferInput", "loc": { "start": 2863, "end": 2880 } }, "loc": { "start": 2863, "end": 2880 } }, "loc": { "start": 2863, "end": 2881 } }, "directives": [], "loc": { "start": 2856, "end": 2881 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Offer", "loc": { "start": 2884, "end": 2889 } }, "loc": { "start": 2884, "end": 2889 } }, "directives": [], "loc": { "start": 2841, "end": 2889 } }], "loc": { "start": 2598, "end": 2891 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "RespondInterviewInput", "loc": { "start": 2899, "end": 2920 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "interviewId", "loc": { "start": 2925, "end": 2936 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2938, "end": 2944 } }, "loc": { "start": 2938, "end": 2944 } }, "loc": { "start": 2938, "end": 2945 } }, "directives": [], "loc": { "start": 2925, "end": 2945 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 2948, "end": 2959 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2961, "end": 2967 } }, "loc": { "start": 2961, "end": 2967 } }, "loc": { "start": 2961, "end": 2968 } }, "directives": [], "loc": { "start": 2948, "end": 2968 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "interviewVideoUrl", "loc": { "start": 2971, "end": 2988 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 2990, "end": 2996 } }, "loc": { "start": 2990, "end": 2996 } }, "directives": [], "loc": { "start": 2971, "end": 2996 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "refuse", "loc": { "start": 2999, "end": 3005 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 3007, "end": 3014 } }, "loc": { "start": 3007, "end": 3014 } }, "defaultValue": { "kind": "BooleanValue", "value": false, "loc": { "start": 3017, "end": 3022 } }, "directives": [], "loc": { "start": 2999, "end": 3022 } }], "loc": { "start": 2893, "end": 3024 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "RespondOfferInput", "loc": { "start": 3032, "end": 3049 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "offerId", "loc": { "start": 3054, "end": 3061 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3063, "end": 3069 } }, "loc": { "start": 3063, "end": 3069 } }, "loc": { "start": 3063, "end": 3070 } }, "directives": [], "loc": { "start": 3054, "end": 3070 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicationId", "loc": { "start": 3073, "end": 3086 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3088, "end": 3094 } }, "loc": { "start": 3088, "end": 3094 } }, "loc": { "start": 3088, "end": 3095 } }, "directives": [], "loc": { "start": 3073, "end": 3095 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 3098, "end": 3109 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3111, "end": 3117 } }, "loc": { "start": 3111, "end": 3117 } }, "loc": { "start": 3111, "end": 3118 } }, "directives": [], "loc": { "start": 3098, "end": 3118 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "refuse", "loc": { "start": 3121, "end": 3127 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 3129, "end": 3136 } }, "loc": { "start": 3129, "end": 3136 } }, "defaultValue": { "kind": "BooleanValue", "value": false, "loc": { "start": 3139, "end": 3144 } }, "directives": [], "loc": { "start": 3121, "end": 3144 } }], "loc": { "start": 3026, "end": 3146 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicationFilter", "loc": { "start": 3154, "end": 3171 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "status", "loc": { "start": 3176, "end": 3182 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationStatus", "loc": { "start": 3184, "end": 3201 } }, "loc": { "start": 3184, "end": 3201 } }, "directives": [], "loc": { "start": 3176, "end": 3201 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 3204, "end": 3215 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3217, "end": 3223 } }, "loc": { "start": 3217, "end": 3223 } }, "directives": [], "loc": { "start": 3204, "end": 3223 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 3226, "end": 3235 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3237, "end": 3243 } }, "loc": { "start": 3237, "end": 3243 } }, "directives": [], "loc": { "start": 3226, "end": 3243 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "ids", "loc": { "start": 3246, "end": 3249 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3252, "end": 3258 } }, "loc": { "start": 3252, "end": 3258 } }, "loc": { "start": 3252, "end": 3259 } }, "loc": { "start": 3251, "end": 3260 } }, "directives": [], "loc": { "start": 3246, "end": 3260 } }], "loc": { "start": 3148, "end": 3262 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetJobApplicationsInput", "loc": { "start": 3270, "end": 3293 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "filter", "loc": { "start": 3298, "end": 3304 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationFilter", "loc": { "start": 3306, "end": 3323 } }, "loc": { "start": 3306, "end": 3323 } }, "directives": [], "loc": { "start": 3298, "end": 3323 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "first", "loc": { "start": 3326, "end": 3331 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 3333, "end": 3336 } }, "loc": { "start": 3333, "end": 3336 } }, "directives": [], "loc": { "start": 3326, "end": 3336 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "last", "loc": { "start": 3339, "end": 3343 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 3345, "end": 3348 } }, "loc": { "start": 3345, "end": 3348 } }, "directives": [], "loc": { "start": 3339, "end": 3348 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "after", "loc": { "start": 3351, "end": 3356 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3358, "end": 3364 } }, "loc": { "start": 3358, "end": 3364 } }, "directives": [], "loc": { "start": 3351, "end": 3364 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "before", "loc": { "start": 3367, "end": 3373 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3375, "end": 3381 } }, "loc": { "start": 3375, "end": 3381 } }, "directives": [], "loc": { "start": 3367, "end": 3381 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "orderBy", "loc": { "start": 3384, "end": 3391 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantOrdering", "loc": { "start": 3394, "end": 3411 } }, "loc": { "start": 3394, "end": 3411 } }, "loc": { "start": 3394, "end": 3412 } }, "loc": { "start": 3393, "end": 3413 } }, "directives": [], "loc": { "start": 3384, "end": 3413 } }], "loc": { "start": 3264, "end": 3415 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "CreateApplicationInput", "loc": { "start": 3423, "end": 3445 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 3450, "end": 3461 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3463, "end": 3469 } }, "loc": { "start": 3463, "end": 3469 } }, "loc": { "start": 3463, "end": 3470 } }, "directives": [], "loc": { "start": 3450, "end": 3470 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 3473, "end": 3482 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3484, "end": 3490 } }, "loc": { "start": 3484, "end": 3490 } }, "loc": { "start": 3484, "end": 3491 } }, "directives": [], "loc": { "start": 3473, "end": 3491 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 3494, "end": 3503 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3505, "end": 3511 } }, "loc": { "start": 3505, "end": 3511 } }, "loc": { "start": 3505, "end": 3512 } }, "directives": [], "loc": { "start": 3494, "end": 3512 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "coverLetter", "loc": { "start": 3515, "end": 3526 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3528, "end": 3534 } }, "loc": { "start": 3528, "end": 3534 } }, "loc": { "start": 3528, "end": 3535 } }, "directives": [], "loc": { "start": 3515, "end": 3535 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "resume", "loc": { "start": 3538, "end": 3544 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3546, "end": 3552 } }, "loc": { "start": 3546, "end": 3552 } }, "loc": { "start": 3546, "end": 3553 } }, "directives": [], "loc": { "start": 3538, "end": 3553 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 3556, "end": 3561 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3563, "end": 3569 } }, "loc": { "start": 3563, "end": 3569 } }, "loc": { "start": 3563, "end": 3570 } }, "directives": [], "loc": { "start": 3556, "end": 3570 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 3573, "end": 3578 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3580, "end": 3586 } }, "loc": { "start": 3580, "end": 3586 } }, "loc": { "start": 3580, "end": 3587 } }, "directives": [], "loc": { "start": 3573, "end": 3587 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "attachment", "loc": { "start": 3590, "end": 3600 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3602, "end": 3608 } }, "loc": { "start": 3602, "end": 3608 } }, "directives": [], "loc": { "start": 3590, "end": 3608 } }], "loc": { "start": 3417, "end": 3610 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantProfileUpdateInput", "loc": { "start": 3618, "end": 3645 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountId", "loc": { "start": 3650, "end": 3659 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3661, "end": 3667 } }, "loc": { "start": 3661, "end": 3667 } }, "loc": { "start": 3661, "end": 3668 } }, "directives": [], "loc": { "start": 3650, "end": 3668 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 3671, "end": 3678 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountUpdateInput", "loc": { "start": 3680, "end": 3698 } }, "loc": { "start": 3680, "end": 3698 } }, "directives": [], "loc": { "start": 3671, "end": 3698 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicant", "loc": { "start": 3701, "end": 3710 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantUpdateInput", "loc": { "start": 3712, "end": 3732 } }, "loc": { "start": 3712, "end": 3732 } }, "directives": [], "loc": { "start": 3701, "end": 3732 } }], "loc": { "start": 3612, "end": 3734 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantUpdateInput", "loc": { "start": 3742, "end": 3762 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "experienceYear", "loc": { "start": 3767, "end": 3781 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 3783, "end": 3786 } }, "loc": { "start": 3783, "end": 3786 } }, "directives": [], "loc": { "start": 3767, "end": 3786 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "resume", "loc": { "start": 3789, "end": 3795 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3797, "end": 3803 } }, "loc": { "start": 3797, "end": 3803 } }, "directives": [], "loc": { "start": 3789, "end": 3803 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "introVideo", "loc": { "start": 3806, "end": 3816 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3818, "end": 3824 } }, "loc": { "start": 3818, "end": 3824 } }, "directives": [], "loc": { "start": 3806, "end": 3824 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "about", "loc": { "start": 3827, "end": 3832 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3834, "end": 3840 } }, "loc": { "start": 3834, "end": 3840 } }, "directives": [], "loc": { "start": 3827, "end": 3840 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobPosition", "loc": { "start": 3843, "end": 3854 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3856, "end": 3862 } }, "loc": { "start": 3856, "end": 3862 } }, "directives": [], "loc": { "start": 3843, "end": 3862 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "salaryExpectation", "loc": { "start": 3865, "end": 3882 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 3884, "end": 3887 } }, "loc": { "start": 3884, "end": 3887 } }, "directives": [], "loc": { "start": 3865, "end": 3887 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "location", "loc": { "start": 3890, "end": 3898 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3900, "end": 3906 } }, "loc": { "start": 3900, "end": 3906 } }, "directives": [], "loc": { "start": 3890, "end": 3906 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "skillLevel", "loc": { "start": 3909, "end": 3919 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 3921, "end": 3936 } }, "loc": { "start": 3921, "end": 3936 } }, "directives": [], "loc": { "start": 3909, "end": 3936 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "englishLevel", "loc": { "start": 3939, "end": 3951 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 3953, "end": 3965 } }, "loc": { "start": 3953, "end": 3965 } }, "directives": [], "loc": { "start": 3939, "end": 3965 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accomplishment", "loc": { "start": 3968, "end": 3982 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 3984, "end": 3990 } }, "loc": { "start": 3984, "end": 3990 } }, "directives": [], "loc": { "start": 3968, "end": 3990 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "workExperience", "loc": { "start": 3993, "end": 4007 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "WorkExperienceInput", "loc": { "start": 4010, "end": 4029 } }, "loc": { "start": 4010, "end": 4029 } }, "loc": { "start": 4010, "end": 4030 } }, "loc": { "start": 4009, "end": 4031 } }, "directives": [], "loc": { "start": 3993, "end": 4031 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "github", "loc": { "start": 4034, "end": 4040 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4042, "end": 4048 } }, "loc": { "start": 4042, "end": 4048 } }, "directives": [], "loc": { "start": 4034, "end": 4048 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "linkedin", "loc": { "start": 4051, "end": 4059 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4061, "end": 4067 } }, "loc": { "start": 4061, "end": 4067 } }, "directives": [], "loc": { "start": 4051, "end": 4067 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "portfolio", "loc": { "start": 4070, "end": 4079 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4081, "end": 4087 } }, "loc": { "start": 4081, "end": 4087 } }, "directives": [], "loc": { "start": 4070, "end": 4087 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 4090, "end": 4096 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4099, "end": 4105 } }, "loc": { "start": 4099, "end": 4105 } }, "loc": { "start": 4099, "end": 4106 } }, "loc": { "start": 4098, "end": 4107 } }, "directives": [], "loc": { "start": 4090, "end": 4107 } }], "loc": { "start": 3736, "end": 4109 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetApplicantsInput", "loc": { "start": 4117, "end": 4135 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "filter", "loc": { "start": 4140, "end": 4146 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantFilter", "loc": { "start": 4148, "end": 4163 } }, "loc": { "start": 4148, "end": 4163 } }, "directives": [], "loc": { "start": 4140, "end": 4163 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "first", "loc": { "start": 4166, "end": 4171 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 4173, "end": 4176 } }, "loc": { "start": 4173, "end": 4176 } }, "directives": [], "loc": { "start": 4166, "end": 4176 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "last", "loc": { "start": 4179, "end": 4183 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 4185, "end": 4188 } }, "loc": { "start": 4185, "end": 4188 } }, "directives": [], "loc": { "start": 4179, "end": 4188 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "after", "loc": { "start": 4191, "end": 4196 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4198, "end": 4204 } }, "loc": { "start": 4198, "end": 4204 } }, "directives": [], "loc": { "start": 4191, "end": 4204 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "before", "loc": { "start": 4207, "end": 4213 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4215, "end": 4221 } }, "loc": { "start": 4215, "end": 4221 } }, "directives": [], "loc": { "start": 4207, "end": 4221 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "orderBy", "loc": { "start": 4224, "end": 4231 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantOrdering", "loc": { "start": 4234, "end": 4251 } }, "loc": { "start": 4234, "end": 4251 } }, "loc": { "start": 4234, "end": 4252 } }, "loc": { "start": 4233, "end": 4253 } }, "directives": [], "loc": { "start": 4224, "end": 4253 } }], "loc": { "start": 4111, "end": 4255 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantOrdering", "loc": { "start": 4263, "end": 4280 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "field", "loc": { "start": 4285, "end": 4290 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountSortField", "loc": { "start": 4292, "end": 4308 } }, "loc": { "start": 4292, "end": 4308 } }, "loc": { "start": 4292, "end": 4309 } }, "directives": [], "loc": { "start": 4285, "end": 4309 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "direction", "loc": { "start": 4312, "end": 4321 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OrderDirection", "loc": { "start": 4323, "end": 4337 } }, "loc": { "start": 4323, "end": 4337 } }, "loc": { "start": 4323, "end": 4338 } }, "directives": [], "loc": { "start": 4312, "end": 4338 } }], "loc": { "start": 4257, "end": 4340 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantFilter", "loc": { "start": 4348, "end": 4363 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "ids", "loc": { "start": 4368, "end": 4371 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4374, "end": 4380 } }, "loc": { "start": 4374, "end": 4380 } }, "loc": { "start": 4374, "end": 4381 } }, "loc": { "start": 4373, "end": 4382 } }, "directives": [], "loc": { "start": 4368, "end": 4382 } }], "loc": { "start": 4342, "end": 4384 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetApplicantInput", "loc": { "start": 4392, "end": 4409 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 4414, "end": 4416 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4418, "end": 4424 } }, "loc": { "start": 4418, "end": 4424 } }, "loc": { "start": 4418, "end": 4425 } }, "directives": [], "loc": { "start": 4414, "end": 4425 } }], "loc": { "start": 4386, "end": 4427 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "CreateApplicationPayload", "loc": { "start": 4434, "end": 4458 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "PayloadError", "loc": { "start": 4470, "end": 4482 } }, "loc": { "start": 4470, "end": 4482 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "application", "loc": { "start": 4487, "end": 4498 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Application", "loc": { "start": 4500, "end": 4511 } }, "loc": { "start": 4500, "end": 4511 } }, "directives": [], "loc": { "start": 4487, "end": 4511 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 4514, "end": 4520 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 4523, "end": 4528 } }, "loc": { "start": 4523, "end": 4528 } }, "loc": { "start": 4523, "end": 4529 } }, "loc": { "start": 4522, "end": 4530 } }, "loc": { "start": 4522, "end": 4531 } }, "directives": [], "loc": { "start": 4514, "end": 4531 } }], "loc": { "start": 4429, "end": 4533 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantConnection", "loc": { "start": 4540, "end": 4559 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "edges", "loc": { "start": 4564, "end": 4569 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantEdge", "loc": { "start": 4572, "end": 4585 } }, "loc": { "start": 4572, "end": 4585 } }, "loc": { "start": 4572, "end": 4586 } }, "loc": { "start": 4571, "end": 4587 } }, "loc": { "start": 4571, "end": 4588 } }, "directives": [], "loc": { "start": 4564, "end": 4588 } }, { "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "Pagination data for this connection.", "block": false, "loc": { "start": 4591, "end": 4629 } }, "name": { "kind": "Name", "value": "pageInfo", "loc": { "start": 4632, "end": 4640 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageInfo", "loc": { "start": 4642, "end": 4650 } }, "loc": { "start": 4642, "end": 4650 } }, "loc": { "start": 4642, "end": 4651 } }, "directives": [], "loc": { "start": 4591, "end": 4651 } }, { "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "A total count of items in the collection.", "block": false, "loc": { "start": 4654, "end": 4697 } }, "name": { "kind": "Name", "value": "totalCount", "loc": { "start": 4700, "end": 4710 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 4712, "end": 4715 } }, "loc": { "start": 4712, "end": 4715 } }, "directives": [], "loc": { "start": 4654, "end": 4715 } }], "loc": { "start": 4535, "end": 4717 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantEdge", "loc": { "start": 4724, "end": 4737 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "A cursor for use in pagination.", "block": false, "loc": { "start": 4742, "end": 4775 } }, "name": { "kind": "Name", "value": "cursor", "loc": { "start": 4778, "end": 4784 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4786, "end": 4792 } }, "loc": { "start": 4786, "end": 4792 } }, "loc": { "start": 4786, "end": 4793 } }, "directives": [], "loc": { "start": 4742, "end": 4793 } }, { "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "The item at the end of the edge.", "block": false, "loc": { "start": 4796, "end": 4830 } }, "name": { "kind": "Name", "value": "node", "loc": { "start": 4833, "end": 4837 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 4839, "end": 4848 } }, "loc": { "start": 4839, "end": 4848 } }, "loc": { "start": 4839, "end": 4849 } }, "directives": [], "loc": { "start": 4796, "end": 4849 } }], "loc": { "start": 4719, "end": 4851 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantAccountEdge", "loc": { "start": 4858, "end": 4878 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "cursor", "loc": { "start": 4883, "end": 4889 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 4891, "end": 4897 } }, "loc": { "start": 4891, "end": 4897 } }, "loc": { "start": 4891, "end": 4898 } }, "directives": [], "loc": { "start": 4883, "end": 4898 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "node", "loc": { "start": 4901, "end": 4905 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Account", "loc": { "start": 4907, "end": 4914 } }, "loc": { "start": 4907, "end": 4914 } }, "loc": { "start": 4907, "end": 4915 } }, "directives": [], "loc": { "start": 4901, "end": 4915 } }], "loc": { "start": 4853, "end": 4917 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "PageInfo", "loc": { "start": 4924, "end": 4932 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "hasNextPage", "loc": { "start": 4937, "end": 4948 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 4950, "end": 4957 } }, "loc": { "start": 4950, "end": 4957 } }, "loc": { "start": 4950, "end": 4958 } }, "directives": [], "loc": { "start": 4937, "end": 4958 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "hasPreviousPage", "loc": { "start": 4961, "end": 4976 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 4978, "end": 4985 } }, "loc": { "start": 4978, "end": 4985 } }, "loc": { "start": 4978, "end": 4986 } }, "directives": [], "loc": { "start": 4961, "end": 4986 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "startCursor", "loc": { "start": 4989, "end": 5e3 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5002, "end": 5008 } }, "loc": { "start": 5002, "end": 5008 } }, "directives": [], "loc": { "start": 4989, "end": 5008 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "endCursor", "loc": { "start": 5011, "end": 5020 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5022, "end": 5028 } }, "loc": { "start": 5022, "end": 5028 } }, "directives": [], "loc": { "start": 5011, "end": 5028 } }], "loc": { "start": 4919, "end": 5030 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantAccountConnections", "loc": { "start": 5037, "end": 5064 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "edges", "loc": { "start": 5069, "end": 5074 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantAccountEdge", "loc": { "start": 5077, "end": 5097 } }, "loc": { "start": 5077, "end": 5097 } }, "loc": { "start": 5077, "end": 5098 } }, "loc": { "start": 5076, "end": 5099 } }, "loc": { "start": 5076, "end": 5100 } }, "directives": [], "loc": { "start": 5069, "end": 5100 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "pageInfo", "loc": { "start": 5103, "end": 5111 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageInfo", "loc": { "start": 5113, "end": 5121 } }, "loc": { "start": 5113, "end": 5121 } }, "loc": { "start": 5113, "end": 5122 } }, "directives": [], "loc": { "start": 5103, "end": 5122 } }], "loc": { "start": 5032, "end": 5124 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantSavedJobPostEdge", "loc": { "start": 5131, "end": 5156 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "cursor", "loc": { "start": 5161, "end": 5167 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5169, "end": 5175 } }, "loc": { "start": 5169, "end": 5175 } }, "loc": { "start": 5169, "end": 5176 } }, "directives": [], "loc": { "start": 5161, "end": 5176 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "node", "loc": { "start": 5179, "end": 5183 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 5185, "end": 5192 } }, "loc": { "start": 5185, "end": 5192 } }, "loc": { "start": 5185, "end": 5193 } }, "directives": [], "loc": { "start": 5179, "end": 5193 } }], "loc": { "start": 5126, "end": 5195 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantAppliedJobPostEdge", "loc": { "start": 5202, "end": 5229 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "cursor", "loc": { "start": 5234, "end": 5240 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5242, "end": 5248 } }, "loc": { "start": 5242, "end": 5248 } }, "loc": { "start": 5242, "end": 5249 } }, "directives": [], "loc": { "start": 5234, "end": 5249 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "node", "loc": { "start": 5252, "end": 5256 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 5258, "end": 5265 } }, "loc": { "start": 5258, "end": 5265 } }, "loc": { "start": 5258, "end": 5266 } }, "directives": [], "loc": { "start": 5252, "end": 5266 } }], "loc": { "start": 5197, "end": 5268 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicationEdge", "loc": { "start": 5275, "end": 5290 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "cursor", "loc": { "start": 5295, "end": 5301 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5303, "end": 5309 } }, "loc": { "start": 5303, "end": 5309 } }, "loc": { "start": 5303, "end": 5310 } }, "directives": [], "loc": { "start": 5295, "end": 5310 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "node", "loc": { "start": 5313, "end": 5317 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Application", "loc": { "start": 5319, "end": 5330 } }, "loc": { "start": 5319, "end": 5330 } }, "loc": { "start": 5319, "end": 5331 } }, "directives": [], "loc": { "start": 5313, "end": 5331 } }], "loc": { "start": 5270, "end": 5333 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicationConnections", "loc": { "start": 5340, "end": 5362 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "edges", "loc": { "start": 5367, "end": 5372 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationEdge", "loc": { "start": 5375, "end": 5390 } }, "loc": { "start": 5375, "end": 5390 } }, "loc": { "start": 5375, "end": 5391 } }, "loc": { "start": 5374, "end": 5392 } }, "loc": { "start": 5374, "end": 5393 } }, "directives": [], "loc": { "start": 5367, "end": 5393 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "pageInfo", "loc": { "start": 5396, "end": 5404 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageInfo", "loc": { "start": 5406, "end": 5414 } }, "loc": { "start": 5406, "end": 5414 } }, "loc": { "start": 5406, "end": 5415 } }, "directives": [], "loc": { "start": 5396, "end": 5415 } }], "loc": { "start": 5335, "end": 5417 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "ApplicantSavedJobPostConnections", "loc": { "start": 5424, "end": 5456 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "edges", "loc": { "start": 5461, "end": 5466 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantSavedJobPostEdge", "loc": { "start": 5469, "end": 5494 } }, "loc": { "start": 5469, "end": 5494 } }, "loc": { "start": 5469, "end": 5495 } }, "loc": { "start": 5468, "end": 5496 } }, "loc": { "start": 5468, "end": 5497 } }, "directives": [], "loc": { "start": 5461, "end": 5497 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "pageInfo", "loc": { "start": 5500, "end": 5508 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageInfo", "loc": { "start": 5510, "end": 5518 } }, "loc": { "start": 5510, "end": 5518 } }, "loc": { "start": 5510, "end": 5519 } }, "directives": [], "loc": { "start": 5500, "end": 5519 } }], "loc": { "start": 5419, "end": 5521 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 5528, "end": 5537 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 5549, "end": 5553 } }, "loc": { "start": 5549, "end": 5553 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 5558, "end": 5560 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 5562, "end": 5564 } }, "loc": { "start": 5562, "end": 5564 } }, "loc": { "start": 5562, "end": 5565 } }, "directives": [], "loc": { "start": 5558, "end": 5565 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "experienceYear", "loc": { "start": 5568, "end": 5582 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 5584, "end": 5587 } }, "loc": { "start": 5584, "end": 5587 } }, "directives": [], "loc": { "start": 5568, "end": 5587 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "resume", "loc": { "start": 5590, "end": 5596 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5598, "end": 5604 } }, "loc": { "start": 5598, "end": 5604 } }, "directives": [], "loc": { "start": 5590, "end": 5604 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "introVideo", "loc": { "start": 5607, "end": 5617 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5619, "end": 5625 } }, "loc": { "start": 5619, "end": 5625 } }, "directives": [], "loc": { "start": 5607, "end": 5625 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "gender", "loc": { "start": 5628, "end": 5634 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5636, "end": 5642 } }, "loc": { "start": 5636, "end": 5642 } }, "directives": [], "loc": { "start": 5628, "end": 5642 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "about", "loc": { "start": 5645, "end": 5650 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5652, "end": 5658 } }, "loc": { "start": 5652, "end": 5658 } }, "directives": [], "loc": { "start": 5645, "end": 5658 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPosition", "loc": { "start": 5661, "end": 5672 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5674, "end": 5680 } }, "loc": { "start": 5674, "end": 5680 } }, "directives": [], "loc": { "start": 5661, "end": 5680 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "salaryExpectation", "loc": { "start": 5683, "end": 5700 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 5702, "end": 5705 } }, "loc": { "start": 5702, "end": 5705 } }, "directives": [], "loc": { "start": 5683, "end": 5705 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "WorkExperienceYears", "loc": { "start": 5708, "end": 5727 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 5729, "end": 5732 } }, "loc": { "start": 5729, "end": 5732 } }, "directives": [], "loc": { "start": 5708, "end": 5732 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "location", "loc": { "start": 5735, "end": 5743 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5745, "end": 5751 } }, "loc": { "start": 5745, "end": 5751 } }, "directives": [], "loc": { "start": 5735, "end": 5751 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "skillLevel", "loc": { "start": 5754, "end": 5764 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 5766, "end": 5781 } }, "loc": { "start": 5766, "end": 5781 } }, "directives": [], "loc": { "start": 5754, "end": 5781 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "englishLevel", "loc": { "start": 5784, "end": 5796 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 5798, "end": 5810 } }, "loc": { "start": 5798, "end": 5810 } }, "directives": [], "loc": { "start": 5784, "end": 5810 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "otherLanguages", "loc": { "start": 5813, "end": 5827 } }, "arguments": [], "type": { "kind": "ListType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5830, "end": 5836 } }, "loc": { "start": 5830, "end": 5836 } }, "loc": { "start": 5829, "end": 5837 } }, "directives": [], "loc": { "start": 5813, "end": 5837 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accomplishment", "loc": { "start": 5840, "end": 5854 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5856, "end": 5862 } }, "loc": { "start": 5856, "end": 5862 } }, "directives": [], "loc": { "start": 5840, "end": 5862 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "workExperience", "loc": { "start": 5865, "end": 5879 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "WorkExperience", "loc": { "start": 5882, "end": 5896 } }, "loc": { "start": 5882, "end": 5896 } }, "loc": { "start": 5882, "end": 5897 } }, "loc": { "start": 5881, "end": 5898 } }, "loc": { "start": 5881, "end": 5899 } }, "directives": [], "loc": { "start": 5865, "end": 5899 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 5902, "end": 5908 } }, "arguments": [], "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5911, "end": 5917 } }, "loc": { "start": 5911, "end": 5917 } }, "loc": { "start": 5911, "end": 5918 } }, "loc": { "start": 5910, "end": 5919 } }, "directives": [], "loc": { "start": 5902, "end": 5919 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "languages", "loc": { "start": 5922, "end": 5931 } }, "arguments": [], "type": { "kind": "ListType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5934, "end": 5940 } }, "loc": { "start": 5934, "end": 5940 } }, "loc": { "start": 5933, "end": 5941 } }, "directives": [], "loc": { "start": 5922, "end": 5941 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "education", "loc": { "start": 5944, "end": 5953 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5955, "end": 5961 } }, "loc": { "start": 5955, "end": 5961 } }, "directives": [], "loc": { "start": 5944, "end": 5961 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "github", "loc": { "start": 5964, "end": 5970 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5972, "end": 5978 } }, "loc": { "start": 5972, "end": 5978 } }, "directives": [], "loc": { "start": 5964, "end": 5978 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "linkedin", "loc": { "start": 5981, "end": 5989 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 5991, "end": 5997 } }, "loc": { "start": 5991, "end": 5997 } }, "directives": [], "loc": { "start": 5981, "end": 5997 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "portfolio", "loc": { "start": 6e3, "end": 6009 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6011, "end": 6017 } }, "loc": { "start": 6011, "end": 6017 } }, "directives": [], "loc": { "start": 6e3, "end": 6017 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 6020, "end": 6027 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Account", "loc": { "start": 6029, "end": 6036 } }, "loc": { "start": 6029, "end": 6036 } }, "loc": { "start": 6029, "end": 6037 } }, "directives": [], "loc": { "start": 6020, "end": 6037 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "savedJobs", "loc": { "start": 6040, "end": 6049 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "first", "loc": { "start": 6050, "end": 6055 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 6057, "end": 6060 } }, "loc": { "start": 6057, "end": 6060 } }, "directives": [], "loc": { "start": 6050, "end": 6060 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "after", "loc": { "start": 6062, "end": 6067 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6069, "end": 6075 } }, "loc": { "start": 6069, "end": 6075 } }, "directives": [], "loc": { "start": 6062, "end": 6075 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "last", "loc": { "start": 6077, "end": 6081 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 6083, "end": 6086 } }, "loc": { "start": 6083, "end": 6086 } }, "directives": [], "loc": { "start": 6077, "end": 6086 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "before", "loc": { "start": 6088, "end": 6094 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6096, "end": 6102 } }, "loc": { "start": 6096, "end": 6102 } }, "directives": [], "loc": { "start": 6088, "end": 6102 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicantSavedJobPostConnections", "loc": { "start": 6105, "end": 6137 } }, "loc": { "start": 6105, "end": 6137 } }, "directives": [], "loc": { "start": 6040, "end": 6137 } }], "loc": { "start": 5523, "end": 6139 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "WorkExperience", "loc": { "start": 6146, "end": 6160 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyName", "loc": { "start": 6165, "end": 6176 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6178, "end": 6184 } }, "loc": { "start": 6178, "end": 6184 } }, "loc": { "start": 6178, "end": 6185 } }, "directives": [], "loc": { "start": 6165, "end": 6185 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyWebsite", "loc": { "start": 6188, "end": 6202 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6204, "end": 6210 } }, "loc": { "start": 6204, "end": 6210 } }, "directives": [], "loc": { "start": 6188, "end": 6210 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "position", "loc": { "start": 6213, "end": 6221 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6223, "end": 6229 } }, "loc": { "start": 6223, "end": 6229 } }, "loc": { "start": 6223, "end": 6230 } }, "directives": [], "loc": { "start": 6213, "end": 6230 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "ongoing", "loc": { "start": 6233, "end": 6240 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 6242, "end": 6249 } }, "loc": { "start": 6242, "end": 6249 } }, "loc": { "start": 6242, "end": 6250 } }, "directives": [], "loc": { "start": 6233, "end": 6250 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "startDate", "loc": { "start": 6253, "end": 6262 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 6264, "end": 6272 } }, "loc": { "start": 6264, "end": 6272 } }, "loc": { "start": 6264, "end": 6273 } }, "directives": [], "loc": { "start": 6253, "end": 6273 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "endDate", "loc": { "start": 6276, "end": 6283 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 6285, "end": 6293 } }, "loc": { "start": 6285, "end": 6293 } }, "directives": [], "loc": { "start": 6276, "end": 6293 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accomplishment", "loc": { "start": 6296, "end": 6310 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6312, "end": 6318 } }, "loc": { "start": 6312, "end": 6318 } }, "loc": { "start": 6312, "end": 6319 } }, "directives": [], "loc": { "start": 6296, "end": 6319 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 6322, "end": 6328 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6331, "end": 6337 } }, "loc": { "start": 6331, "end": 6337 } }, "loc": { "start": 6331, "end": 6338 } }, "loc": { "start": 6330, "end": 6339 } }, "loc": { "start": 6330, "end": 6340 } }, "directives": [], "loc": { "start": 6322, "end": 6340 } }], "loc": { "start": 6141, "end": 6342 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 6355, "end": 6363 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "signUp", "loc": { "start": 6368, "end": 6374 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 6375, "end": 6380 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SignUpInput", "loc": { "start": 6382, "end": 6393 } }, "loc": { "start": 6382, "end": 6393 } }, "loc": { "start": 6382, "end": 6394 } }, "directives": [], "loc": { "start": 6375, "end": 6394 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AuthPayload", "loc": { "start": 6397, "end": 6408 } }, "loc": { "start": 6397, "end": 6408 } }, "loc": { "start": 6397, "end": 6409 } }, "directives": [], "loc": { "start": 6368, "end": 6409 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "logIn", "loc": { "start": 6412, "end": 6417 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 6418, "end": 6423 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LoginInput", "loc": { "start": 6425, "end": 6435 } }, "loc": { "start": 6425, "end": 6435 } }, "loc": { "start": 6425, "end": 6436 } }, "directives": [], "loc": { "start": 6418, "end": 6436 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AuthPayload", "loc": { "start": 6439, "end": 6450 } }, "loc": { "start": 6439, "end": 6450 } }, "loc": { "start": 6439, "end": 6451 } }, "directives": [], "loc": { "start": 6412, "end": 6451 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "signUpOAuth", "loc": { "start": 6454, "end": 6465 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 6466, "end": 6471 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuthSignUpInput", "loc": { "start": 6473, "end": 6489 } }, "loc": { "start": 6473, "end": 6489 } }, "loc": { "start": 6473, "end": 6490 } }, "directives": [], "loc": { "start": 6466, "end": 6490 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AuthPayload", "loc": { "start": 6493, "end": 6504 } }, "loc": { "start": 6493, "end": 6504 } }, "loc": { "start": 6493, "end": 6505 } }, "directives": [], "loc": { "start": 6454, "end": 6505 } }], "loc": { "start": 6343, "end": 6507 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AuthPayload", "loc": { "start": 6514, "end": 6525 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "PayloadError", "loc": { "start": 6537, "end": 6549 } }, "loc": { "start": 6537, "end": 6549 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 6554, "end": 6560 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 6563, "end": 6568 } }, "loc": { "start": 6563, "end": 6568 } }, "loc": { "start": 6563, "end": 6569 } }, "loc": { "start": 6562, "end": 6570 } }, "loc": { "start": 6562, "end": 6571 } }, "directives": [], "loc": { "start": 6554, "end": 6571 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 6574, "end": 6581 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AuthAccountPayload", "loc": { "start": 6583, "end": 6601 } }, "loc": { "start": 6583, "end": 6601 } }, "directives": [], "loc": { "start": 6574, "end": 6601 } }], "loc": { "start": 6509, "end": 6603 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "FindOnePayload", "loc": { "start": 6610, "end": 6624 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "PayloadError", "loc": { "start": 6636, "end": 6648 } }, "loc": { "start": 6636, "end": 6648 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 6653, "end": 6659 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 6662, "end": 6667 } }, "loc": { "start": 6662, "end": 6667 } }, "loc": { "start": 6662, "end": 6668 } }, "loc": { "start": 6661, "end": 6669 } }, "loc": { "start": 6661, "end": 6670 } }, "directives": [], "loc": { "start": 6653, "end": 6670 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 6673, "end": 6680 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountPayload", "loc": { "start": 6682, "end": 6696 } }, "loc": { "start": 6682, "end": 6696 } }, "directives": [], "loc": { "start": 6673, "end": 6696 } }], "loc": { "start": 6605, "end": 6698 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AuthApplicant", "loc": { "start": 6705, "end": 6718 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 6723, "end": 6725 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6727, "end": 6733 } }, "loc": { "start": 6727, "end": 6733 } }, "loc": { "start": 6727, "end": 6734 } }, "directives": [], "loc": { "start": 6723, "end": 6734 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "experienceYear", "loc": { "start": 6737, "end": 6751 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 6753, "end": 6756 } }, "loc": { "start": 6753, "end": 6756 } }, "directives": [], "loc": { "start": 6737, "end": 6756 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "resume", "loc": { "start": 6759, "end": 6765 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6767, "end": 6773 } }, "loc": { "start": 6767, "end": 6773 } }, "directives": [], "loc": { "start": 6759, "end": 6773 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "gender", "loc": { "start": 6776, "end": 6782 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6784, "end": 6790 } }, "loc": { "start": 6784, "end": 6790 } }, "directives": [], "loc": { "start": 6776, "end": 6790 } }], "loc": { "start": 6700, "end": 6792 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "AuthAccountPayload", "loc": { "start": 6799, "end": 6817 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 6822, "end": 6824 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6826, "end": 6832 } }, "loc": { "start": 6826, "end": 6832 } }, "loc": { "start": 6826, "end": 6833 } }, "directives": [], "loc": { "start": 6822, "end": 6833 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 6836, "end": 6841 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6843, "end": 6849 } }, "loc": { "start": 6843, "end": 6849 } }, "loc": { "start": 6843, "end": 6850 } }, "directives": [], "loc": { "start": 6836, "end": 6850 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "emailVerified", "loc": { "start": 6853, "end": 6866 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 6868, "end": 6876 } }, "loc": { "start": 6868, "end": 6876 } }, "directives": [], "loc": { "start": 6853, "end": 6876 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 6879, "end": 6888 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6890, "end": 6896 } }, "loc": { "start": 6890, "end": 6896 } }, "loc": { "start": 6890, "end": 6897 } }, "directives": [], "loc": { "start": 6879, "end": 6897 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 6900, "end": 6908 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6910, "end": 6916 } }, "loc": { "start": 6910, "end": 6916 } }, "loc": { "start": 6910, "end": 6917 } }, "directives": [], "loc": { "start": 6900, "end": 6917 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 6920, "end": 6929 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 6931, "end": 6939 } }, "loc": { "start": 6931, "end": 6939 } }, "loc": { "start": 6931, "end": 6940 } }, "directives": [], "loc": { "start": 6920, "end": 6940 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 6943, "end": 6954 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 6956, "end": 6967 } }, "loc": { "start": 6956, "end": 6967 } }, "loc": { "start": 6956, "end": 6968 } }, "directives": [], "loc": { "start": 6943, "end": 6968 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 6971, "end": 6976 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6978, "end": 6984 } }, "loc": { "start": 6978, "end": 6984 } }, "directives": [], "loc": { "start": 6971, "end": 6984 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 6987, "end": 6992 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 6994, "end": 7e3 } }, "loc": { "start": 6994, "end": 7e3 } }, "directives": [], "loc": { "start": 6987, "end": 7e3 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "oAuthClient", "loc": { "start": 7003, "end": 7014 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuth", "loc": { "start": 7017, "end": 7022 } }, "loc": { "start": 7017, "end": 7022 } }, "loc": { "start": 7017, "end": 7023 } }, "loc": { "start": 7016, "end": 7024 } }, "loc": { "start": 7016, "end": 7025 } }, "directives": [], "loc": { "start": 7003, "end": 7025 } }], "loc": { "start": 6794, "end": 7027 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuth", "loc": { "start": 7034, "end": 7039 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 7044, "end": 7046 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7048, "end": 7054 } }, "loc": { "start": 7048, "end": 7054 } }, "loc": { "start": 7048, "end": 7055 } }, "directives": [], "loc": { "start": 7044, "end": 7055 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "provider", "loc": { "start": 7058, "end": 7066 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7068, "end": 7074 } }, "loc": { "start": 7068, "end": 7074 } }, "loc": { "start": 7068, "end": 7075 } }, "directives": [], "loc": { "start": 7058, "end": 7075 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "providerAccountId", "loc": { "start": 7078, "end": 7095 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7097, "end": 7103 } }, "loc": { "start": 7097, "end": 7103 } }, "loc": { "start": 7097, "end": 7104 } }, "directives": [], "loc": { "start": 7078, "end": 7104 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "accessToken", "loc": { "start": 7107, "end": 7118 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7120, "end": 7126 } }, "loc": { "start": 7120, "end": 7126 } }, "loc": { "start": 7120, "end": 7127 } }, "directives": [], "loc": { "start": 7107, "end": 7127 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "refreshToken", "loc": { "start": 7130, "end": 7142 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7144, "end": 7150 } }, "loc": { "start": 7144, "end": 7150 } }, "directives": [], "loc": { "start": 7130, "end": 7150 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "expires", "loc": { "start": 7153, "end": 7160 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 7162, "end": 7170 } }, "loc": { "start": 7162, "end": 7170 } }, "loc": { "start": 7162, "end": 7171 } }, "directives": [], "loc": { "start": 7153, "end": 7171 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "tokenType", "loc": { "start": 7174, "end": 7183 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7185, "end": 7191 } }, "loc": { "start": 7185, "end": 7191 } }, "loc": { "start": 7185, "end": 7192 } }, "directives": [], "loc": { "start": 7174, "end": 7192 } }], "loc": { "start": 7029, "end": 7194 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "LoginInput", "loc": { "start": 7202, "end": 7212 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 7217, "end": 7222 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7224, "end": 7230 } }, "loc": { "start": 7224, "end": 7230 } }, "loc": { "start": 7224, "end": 7231 } }, "directives": [], "loc": { "start": 7217, "end": 7231 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "password", "loc": { "start": 7234, "end": 7242 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7244, "end": 7250 } }, "loc": { "start": 7244, "end": 7250 } }, "loc": { "start": 7244, "end": 7251 } }, "directives": [], "loc": { "start": 7234, "end": 7251 } }], "loc": { "start": 7196, "end": 7253 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "SignUpInput", "loc": { "start": 7261, "end": 7272 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 7277, "end": 7282 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7284, "end": 7290 } }, "loc": { "start": 7284, "end": 7290 } }, "loc": { "start": 7284, "end": 7291 } }, "directives": [], "loc": { "start": 7277, "end": 7291 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 7294, "end": 7303 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7305, "end": 7311 } }, "loc": { "start": 7305, "end": 7311 } }, "loc": { "start": 7305, "end": 7312 } }, "directives": [], "loc": { "start": 7294, "end": 7312 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyName", "loc": { "start": 7315, "end": 7326 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7328, "end": 7334 } }, "loc": { "start": 7328, "end": 7334 } }, "directives": [], "loc": { "start": 7315, "end": 7334 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 7337, "end": 7345 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7347, "end": 7353 } }, "loc": { "start": 7347, "end": 7353 } }, "loc": { "start": 7347, "end": 7354 } }, "directives": [], "loc": { "start": 7337, "end": 7354 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "password", "loc": { "start": 7357, "end": 7365 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7367, "end": 7373 } }, "loc": { "start": 7367, "end": 7373 } }, "loc": { "start": 7367, "end": 7374 } }, "directives": [], "loc": { "start": 7357, "end": 7374 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 7377, "end": 7388 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 7390, "end": 7401 } }, "loc": { "start": 7390, "end": 7401 } }, "loc": { "start": 7390, "end": 7402 } }, "directives": [], "loc": { "start": 7377, "end": 7402 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "country", "loc": { "start": 7405, "end": 7412 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7414, "end": 7420 } }, "loc": { "start": 7414, "end": 7420 } }, "loc": { "start": 7414, "end": 7421 } }, "directives": [], "loc": { "start": 7405, "end": 7421 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 7424, "end": 7429 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7431, "end": 7437 } }, "loc": { "start": 7431, "end": 7437 } }, "directives": [], "loc": { "start": 7424, "end": 7437 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "name", "loc": { "start": 7440, "end": 7444 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7446, "end": 7452 } }, "loc": { "start": 7446, "end": 7452 } }, "directives": [], "loc": { "start": 7440, "end": 7452 } }], "loc": { "start": 7255, "end": 7454 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuthInput", "loc": { "start": 7462, "end": 7472 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "provider", "loc": { "start": 7477, "end": 7485 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7487, "end": 7493 } }, "loc": { "start": 7487, "end": 7493 } }, "loc": { "start": 7487, "end": 7494 } }, "directives": [], "loc": { "start": 7477, "end": 7494 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "providerAccountId", "loc": { "start": 7497, "end": 7514 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7516, "end": 7522 } }, "loc": { "start": 7516, "end": 7522 } }, "loc": { "start": 7516, "end": 7523 } }, "directives": [], "loc": { "start": 7497, "end": 7523 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accessToken", "loc": { "start": 7526, "end": 7537 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7539, "end": 7545 } }, "loc": { "start": 7539, "end": 7545 } }, "loc": { "start": 7539, "end": 7546 } }, "directives": [], "loc": { "start": 7526, "end": 7546 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "refreshToken", "loc": { "start": 7549, "end": 7561 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7563, "end": 7569 } }, "loc": { "start": 7563, "end": 7569 } }, "directives": [], "loc": { "start": 7549, "end": 7569 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "expires", "loc": { "start": 7572, "end": 7579 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 7581, "end": 7589 } }, "loc": { "start": 7581, "end": 7589 } }, "loc": { "start": 7581, "end": 7590 } }, "directives": [], "loc": { "start": 7572, "end": 7590 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "tokenType", "loc": { "start": 7593, "end": 7602 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7604, "end": 7610 } }, "loc": { "start": 7604, "end": 7610 } }, "loc": { "start": 7604, "end": 7611 } }, "directives": [], "loc": { "start": 7593, "end": 7611 } }], "loc": { "start": 7456, "end": 7613 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuthAccountInput", "loc": { "start": 7621, "end": 7638 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 7643, "end": 7648 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7650, "end": 7656 } }, "loc": { "start": 7650, "end": 7656 } }, "loc": { "start": 7650, "end": 7657 } }, "directives": [], "loc": { "start": 7643, "end": 7657 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "firstName", "loc": { "start": 7660, "end": 7669 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7671, "end": 7677 } }, "loc": { "start": 7671, "end": 7677 } }, "loc": { "start": 7671, "end": 7678 } }, "directives": [], "loc": { "start": 7660, "end": 7678 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "lastName", "loc": { "start": 7681, "end": 7689 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7691, "end": 7697 } }, "loc": { "start": 7691, "end": 7697 } }, "loc": { "start": 7691, "end": 7698 } }, "directives": [], "loc": { "start": 7681, "end": 7698 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountType", "loc": { "start": 7701, "end": 7712 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AccountType", "loc": { "start": 7714, "end": 7725 } }, "loc": { "start": 7714, "end": 7725 } }, "loc": { "start": 7714, "end": 7726 } }, "directives": [], "loc": { "start": 7701, "end": 7726 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "image", "loc": { "start": 7729, "end": 7734 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7736, "end": 7742 } }, "loc": { "start": 7736, "end": 7742 } }, "directives": [], "loc": { "start": 7729, "end": 7742 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "userName", "loc": { "start": 7745, "end": 7753 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7755, "end": 7761 } }, "loc": { "start": 7755, "end": 7761 } }, "directives": [], "loc": { "start": 7745, "end": 7761 } }], "loc": { "start": 7615, "end": 7763 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuthSignUpInput", "loc": { "start": 7771, "end": 7787 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "OAuth", "loc": { "start": 7792, "end": 7797 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuthInput", "loc": { "start": 7799, "end": 7809 } }, "loc": { "start": 7799, "end": 7809 } }, "loc": { "start": 7799, "end": 7810 } }, "directives": [], "loc": { "start": 7792, "end": 7810 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 7813, "end": 7820 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuthAccountInput", "loc": { "start": 7822, "end": 7839 } }, "loc": { "start": 7822, "end": 7839 } }, "loc": { "start": 7822, "end": 7840 } }, "directives": [], "loc": { "start": 7813, "end": 7840 } }], "loc": { "start": 7765, "end": 7842 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OAuthLoginInput", "loc": { "start": 7850, "end": 7865 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "OAuth", "loc": { "start": 7870, "end": 7875 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OAuthInput", "loc": { "start": 7877, "end": 7887 } }, "loc": { "start": 7877, "end": 7887 } }, "loc": { "start": 7877, "end": 7888 } }, "directives": [], "loc": { "start": 7870, "end": 7888 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 7891, "end": 7898 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SignUpInput", "loc": { "start": 7900, "end": 7911 } }, "loc": { "start": 7900, "end": 7911 } }, "loc": { "start": 7900, "end": 7912 } }, "directives": [], "loc": { "start": 7891, "end": 7912 } }], "loc": { "start": 7844, "end": 7914 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Query", "loc": { "start": 7920, "end": 7925 } }, "interfaces": [], "directives": [], "fields": [], "loc": { "start": 7915, "end": 7925 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 7932, "end": 7940 } }, "interfaces": [], "directives": [], "fields": [], "loc": { "start": 7927, "end": 7940 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Error", "loc": { "start": 7947, "end": 7952 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "message", "loc": { "start": 7957, "end": 7964 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 7966, "end": 7972 } }, "loc": { "start": 7966, "end": 7972 } }, "loc": { "start": 7966, "end": 7973 } }, "directives": [], "loc": { "start": 7957, "end": 7973 } }], "loc": { "start": 7942, "end": 7975 } }, { "kind": "InterfaceTypeDefinition", "name": { "kind": "Name", "value": "PayloadError", "loc": { "start": 7987, "end": 7999 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 8004, "end": 8010 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 8013, "end": 8018 } }, "loc": { "start": 8013, "end": 8018 } }, "loc": { "start": 8013, "end": 8019 } }, "loc": { "start": 8012, "end": 8020 } }, "loc": { "start": 8012, "end": 8021 } }, "directives": [], "loc": { "start": 8004, "end": 8021 } }], "loc": { "start": 7977, "end": 8023 } }, { "kind": "InterfaceTypeDefinition", "description": { "kind": "StringValue", "value": "An object with an ID", "block": false, "loc": { "start": 8025, "end": 8047 } }, "name": { "kind": "Name", "value": "Node", "loc": { "start": 8058, "end": 8062 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "The ID of the object.", "block": false, "loc": { "start": 8067, "end": 8090 } }, "name": { "kind": "Name", "value": "id", "loc": { "start": 8093, "end": 8095 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 8097, "end": 8099 } }, "loc": { "start": 8097, "end": 8099 } }, "loc": { "start": 8097, "end": 8100 } }, "directives": [], "loc": { "start": 8067, "end": 8100 } }], "loc": { "start": 8025, "end": 8102 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "OrderDirection", "loc": { "start": 8109, "end": 8123 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Specifies an ascending sort order.", "block": false, "loc": { "start": 8128, "end": 8164 } }, "name": { "kind": "Name", "value": "ASC", "loc": { "start": 8167, "end": 8170 } }, "directives": [], "loc": { "start": 8128, "end": 8170 } }, { "kind": "EnumValueDefinition", "description": { "kind": "StringValue", "value": "Specifies a descending sort order.", "block": false, "loc": { "start": 8173, "end": 8209 } }, "name": { "kind": "Name", "value": "DESC", "loc": { "start": 8212, "end": 8216 } }, "directives": [], "loc": { "start": 8173, "end": 8216 } }], "loc": { "start": 8104, "end": 8218 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Query", "loc": { "start": 8231, "end": 8236 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getCompanies", "loc": { "start": 8241, "end": 8253 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Company", "loc": { "start": 8256, "end": 8263 } }, "loc": { "start": 8256, "end": 8263 } }, "loc": { "start": 8256, "end": 8264 } }, "loc": { "start": 8255, "end": 8265 } }, "loc": { "start": 8255, "end": 8266 } }, "directives": [], "loc": { "start": 8241, "end": 8266 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getSavedApplicant", "loc": { "start": 8269, "end": 8286 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8287, "end": 8292 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetSavedApplicantInput", "loc": { "start": 8294, "end": 8316 } }, "loc": { "start": 8294, "end": 8316 } }, "loc": { "start": 8294, "end": 8317 } }, "directives": [], "loc": { "start": 8287, "end": 8317 } }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 8321, "end": 8330 } }, "loc": { "start": 8321, "end": 8330 } }, "loc": { "start": 8321, "end": 8331 } }, "loc": { "start": 8320, "end": 8332 } }, "loc": { "start": 8320, "end": 8333 } }, "directives": [], "loc": { "start": 8269, "end": 8333 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getCompanyJobPosts", "loc": { "start": 8336, "end": 8354 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8355, "end": 8360 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetCompanyJobPostsInput", "loc": { "start": 8362, "end": 8385 } }, "loc": { "start": 8362, "end": 8385 } }, "loc": { "start": 8362, "end": 8386 } }, "directives": [], "loc": { "start": 8355, "end": 8386 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CompanyJobPostsResponse", "loc": { "start": 8389, "end": 8412 } }, "loc": { "start": 8389, "end": 8412 } }, "loc": { "start": 8389, "end": 8413 } }, "directives": [], "loc": { "start": 8336, "end": 8413 } }], "loc": { "start": 8219, "end": 8415 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 8429, "end": 8437 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "saveApplicant", "loc": { "start": 8442, "end": 8455 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8456, "end": 8461 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SaveApplicantInput", "loc": { "start": 8463, "end": 8481 } }, "loc": { "start": 8463, "end": 8481 } }, "loc": { "start": 8463, "end": 8482 } }, "directives": [], "loc": { "start": 8456, "end": 8482 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 8485, "end": 8492 } }, "loc": { "start": 8485, "end": 8492 } }, "directives": [], "loc": { "start": 8442, "end": 8492 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createJobPost", "loc": { "start": 8495, "end": 8508 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8509, "end": 8514 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateJobPostInput", "loc": { "start": 8516, "end": 8534 } }, "loc": { "start": 8516, "end": 8534 } }, "loc": { "start": 8516, "end": 8535 } }, "directives": [], "loc": { "start": 8509, "end": 8535 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPostResponse", "loc": { "start": 8538, "end": 8553 } }, "loc": { "start": 8538, "end": 8553 } }, "loc": { "start": 8538, "end": 8554 } }, "directives": [], "loc": { "start": 8495, "end": 8554 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "editJobPost", "loc": { "start": 8557, "end": 8568 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8569, "end": 8574 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EditJobPostInput", "loc": { "start": 8576, "end": 8592 } }, "loc": { "start": 8576, "end": 8592 } }, "loc": { "start": 8576, "end": 8593 } }, "directives": [], "loc": { "start": 8569, "end": 8593 } }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPostResponse", "loc": { "start": 8596, "end": 8611 } }, "loc": { "start": 8596, "end": 8611 } }, "loc": { "start": 8596, "end": 8612 } }, "directives": [], "loc": { "start": 8557, "end": 8612 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "sendInterviewRequest", "loc": { "start": 8615, "end": 8635 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8636, "end": 8641 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SendInterviewRequestInput", "loc": { "start": 8643, "end": 8668 } }, "loc": { "start": 8643, "end": 8668 } }, "loc": { "start": 8643, "end": 8669 } }, "directives": [], "loc": { "start": 8636, "end": 8669 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Interview", "loc": { "start": 8672, "end": 8681 } }, "loc": { "start": 8672, "end": 8681 } }, "directives": [], "loc": { "start": 8615, "end": 8681 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "offerApplicant", "loc": { "start": 8684, "end": 8698 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 8699, "end": 8704 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OfferApplicantInput", "loc": { "start": 8706, "end": 8725 } }, "loc": { "start": 8706, "end": 8725 } }, "loc": { "start": 8706, "end": 8726 } }, "directives": [], "loc": { "start": 8699, "end": 8726 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Offer", "loc": { "start": 8729, "end": 8734 } }, "loc": { "start": 8729, "end": 8734 } }, "directives": [], "loc": { "start": 8684, "end": 8734 } }], "loc": { "start": 8417, "end": 8736 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "OfferApplicantInput", "loc": { "start": 8744, "end": 8763 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicationId", "loc": { "start": 8768, "end": 8781 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 8783, "end": 8789 } }, "loc": { "start": 8783, "end": 8789 } }, "loc": { "start": 8783, "end": 8790 } }, "directives": [], "loc": { "start": 8768, "end": 8790 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 8793, "end": 8804 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 8806, "end": 8812 } }, "loc": { "start": 8806, "end": 8812 } }, "loc": { "start": 8806, "end": 8813 } }, "directives": [], "loc": { "start": 8793, "end": 8813 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 8816, "end": 8827 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 8829, "end": 8835 } }, "loc": { "start": 8829, "end": 8835 } }, "loc": { "start": 8829, "end": 8836 } }, "directives": [], "loc": { "start": 8816, "end": 8836 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "date", "loc": { "start": 8839, "end": 8843 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 8845, "end": 8853 } }, "loc": { "start": 8845, "end": 8853 } }, "directives": [], "loc": { "start": 8839, "end": 8853 } }], "loc": { "start": 8738, "end": 8855 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "SendInterviewRequestInput", "loc": { "start": 8863, "end": 8888 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicationId", "loc": { "start": 8893, "end": 8906 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 8908, "end": 8914 } }, "loc": { "start": 8908, "end": 8914 } }, "loc": { "start": 8908, "end": 8915 } }, "directives": [], "loc": { "start": 8893, "end": 8915 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 8918, "end": 8929 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 8931, "end": 8937 } }, "loc": { "start": 8931, "end": 8937 } }, "loc": { "start": 8931, "end": 8938 } }, "directives": [], "loc": { "start": 8918, "end": 8938 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "date", "loc": { "start": 8941, "end": 8945 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 8947, "end": 8955 } }, "loc": { "start": 8947, "end": 8955 } }, "directives": [], "loc": { "start": 8941, "end": 8955 } }], "loc": { "start": 8857, "end": 8957 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetCompanyJobPostsInput", "loc": { "start": 8965, "end": 8988 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 8993, "end": 9002 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9004, "end": 9010 } }, "loc": { "start": 9004, "end": 9010 } }, "loc": { "start": 9004, "end": 9011 } }, "directives": [], "loc": { "start": 8993, "end": 9011 } }], "loc": { "start": 8959, "end": 9013 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "CreateJobPostInput", "loc": { "start": 9021, "end": 9039 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "title", "loc": { "start": 9044, "end": 9049 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9051, "end": 9057 } }, "loc": { "start": 9051, "end": 9057 } }, "loc": { "start": 9051, "end": 9058 } }, "directives": [], "loc": { "start": 9044, "end": 9058 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 9061, "end": 9072 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9074, "end": 9080 } }, "loc": { "start": 9074, "end": 9080 } }, "loc": { "start": 9074, "end": 9081 } }, "directives": [], "loc": { "start": 9061, "end": 9081 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobType", "loc": { "start": 9084, "end": 9091 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobType", "loc": { "start": 9093, "end": 9100 } }, "loc": { "start": 9093, "end": 9100 } }, "loc": { "start": 9093, "end": 9101 } }, "directives": [], "loc": { "start": 9084, "end": 9101 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "salary", "loc": { "start": 9104, "end": 9110 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9113, "end": 9116 } }, "loc": { "start": 9113, "end": 9116 } }, "loc": { "start": 9113, "end": 9117 } }, "loc": { "start": 9112, "end": 9118 } }, "loc": { "start": 9112, "end": 9119 } }, "directives": [], "loc": { "start": 9104, "end": 9119 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "category", "loc": { "start": 9122, "end": 9130 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9133, "end": 9139 } }, "loc": { "start": 9133, "end": 9139 } }, "loc": { "start": 9133, "end": 9140 } }, "loc": { "start": 9132, "end": 9141 } }, "loc": { "start": 9132, "end": 9142 } }, "directives": [], "loc": { "start": 9122, "end": 9142 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "vacancy", "loc": { "start": 9145, "end": 9152 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9154, "end": 9157 } }, "loc": { "start": 9154, "end": 9157 } }, "loc": { "start": 9154, "end": 9158 } }, "directives": [], "loc": { "start": 9145, "end": 9158 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 9161, "end": 9166 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9168, "end": 9174 } }, "loc": { "start": 9168, "end": 9174 } }, "loc": { "start": 9168, "end": 9175 } }, "directives": [], "loc": { "start": 9161, "end": 9175 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobSite", "loc": { "start": 9178, "end": 9185 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobSite", "loc": { "start": 9187, "end": 9194 } }, "loc": { "start": 9187, "end": 9194 } }, "loc": { "start": 9187, "end": 9195 } }, "directives": [], "loc": { "start": 9178, "end": 9195 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicationDeadline", "loc": { "start": 9198, "end": 9217 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 9219, "end": 9227 } }, "loc": { "start": 9219, "end": 9227 } }, "loc": { "start": 9219, "end": 9228 } }, "directives": [], "loc": { "start": 9198, "end": 9228 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "salaryType", "loc": { "start": 9231, "end": 9241 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SalaryType", "loc": { "start": 9243, "end": 9253 } }, "loc": { "start": 9243, "end": 9253 } }, "loc": { "start": 9243, "end": 9254 } }, "directives": [], "loc": { "start": 9231, "end": 9254 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "isVisible", "loc": { "start": 9257, "end": 9266 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 9268, "end": 9275 } }, "loc": { "start": 9268, "end": 9275 } }, "loc": { "start": 9268, "end": 9276 } }, "directives": [], "loc": { "start": 9257, "end": 9276 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "location", "loc": { "start": 9279, "end": 9287 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9289, "end": 9295 } }, "loc": { "start": 9289, "end": 9295 } }, "loc": { "start": 9289, "end": 9296 } }, "directives": [], "loc": { "start": 9279, "end": 9296 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobExperience", "loc": { "start": 9299, "end": 9312 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9314, "end": 9317 } }, "loc": { "start": 9314, "end": 9317 } }, "loc": { "start": 9314, "end": 9318 } }, "directives": [], "loc": { "start": 9299, "end": 9318 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "englishLevel", "loc": { "start": 9321, "end": 9333 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 9335, "end": 9347 } }, "loc": { "start": 9335, "end": 9347 } }, "loc": { "start": 9335, "end": 9348 } }, "directives": [], "loc": { "start": 9321, "end": 9348 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "otherLanguages", "loc": { "start": 9351, "end": 9365 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9368, "end": 9374 } }, "loc": { "start": 9368, "end": 9374 } }, "loc": { "start": 9368, "end": 9375 } }, "loc": { "start": 9367, "end": 9376 } }, "loc": { "start": 9367, "end": 9377 } }, "directives": [], "loc": { "start": 9351, "end": 9377 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 9380, "end": 9386 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9389, "end": 9395 } }, "loc": { "start": 9389, "end": 9395 } }, "loc": { "start": 9389, "end": 9396 } }, "loc": { "start": 9388, "end": 9397 } }, "loc": { "start": 9388, "end": 9398 } }, "directives": [], "loc": { "start": 9380, "end": 9398 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "qualifications", "loc": { "start": 9401, "end": 9415 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9418, "end": 9424 } }, "loc": { "start": 9418, "end": 9424 } }, "loc": { "start": 9418, "end": 9425 } }, "loc": { "start": 9417, "end": 9426 } }, "loc": { "start": 9417, "end": 9427 } }, "directives": [], "loc": { "start": 9401, "end": 9427 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "interviewQuestions", "loc": { "start": 9430, "end": 9448 } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9451, "end": 9457 } }, "loc": { "start": 9451, "end": 9457 } }, "loc": { "start": 9451, "end": 9458 } }, "loc": { "start": 9450, "end": 9459 } }, "loc": { "start": 9450, "end": 9460 } }, "directives": [], "loc": { "start": 9430, "end": 9460 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "experienceLevel", "loc": { "start": 9463, "end": 9478 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 9480, "end": 9495 } }, "loc": { "start": 9480, "end": 9495 } }, "loc": { "start": 9480, "end": 9496 } }, "directives": [], "loc": { "start": 9463, "end": 9496 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "postedBy", "loc": { "start": 9499, "end": 9507 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9509, "end": 9515 } }, "loc": { "start": 9509, "end": 9515 } }, "loc": { "start": 9509, "end": 9516 } }, "directives": [], "loc": { "start": 9499, "end": 9516 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 9519, "end": 9528 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9530, "end": 9536 } }, "loc": { "start": 9530, "end": 9536 } }, "loc": { "start": 9530, "end": 9537 } }, "directives": [], "loc": { "start": 9519, "end": 9537 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "affiliateId", "loc": { "start": 9540, "end": 9551 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9553, "end": 9559 } }, "loc": { "start": 9553, "end": 9559 } }, "directives": [], "loc": { "start": 9540, "end": 9559 } }], "loc": { "start": 9015, "end": 9561 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "EditJobPostFilter", "loc": { "start": 9569, "end": 9586 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 9591, "end": 9600 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9602, "end": 9608 } }, "loc": { "start": 9602, "end": 9608 } }, "loc": { "start": 9602, "end": 9609 } }, "directives": [], "loc": { "start": 9591, "end": 9609 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 9612, "end": 9621 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9623, "end": 9629 } }, "loc": { "start": 9623, "end": 9629 } }, "loc": { "start": 9623, "end": 9630 } }, "directives": [], "loc": { "start": 9612, "end": 9630 } }], "loc": { "start": 9563, "end": 9632 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "EditJobPostInputData", "loc": { "start": 9640, "end": 9660 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "title", "loc": { "start": 9665, "end": 9670 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9672, "end": 9678 } }, "loc": { "start": 9672, "end": 9678 } }, "directives": [], "loc": { "start": 9665, "end": 9678 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 9681, "end": 9692 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9694, "end": 9700 } }, "loc": { "start": 9694, "end": 9700 } }, "directives": [], "loc": { "start": 9681, "end": 9700 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobType", "loc": { "start": 9703, "end": 9710 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobType", "loc": { "start": 9712, "end": 9719 } }, "loc": { "start": 9712, "end": 9719 } }, "directives": [], "loc": { "start": 9703, "end": 9719 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "salary", "loc": { "start": 9722, "end": 9728 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9731, "end": 9734 } }, "loc": { "start": 9731, "end": 9734 } }, "loc": { "start": 9731, "end": 9735 } }, "loc": { "start": 9730, "end": 9736 } }, "directives": [], "loc": { "start": 9722, "end": 9736 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "category", "loc": { "start": 9739, "end": 9747 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9750, "end": 9756 } }, "loc": { "start": 9750, "end": 9756 } }, "loc": { "start": 9750, "end": 9757 } }, "loc": { "start": 9749, "end": 9758 } }, "directives": [], "loc": { "start": 9739, "end": 9758 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "vacancy", "loc": { "start": 9761, "end": 9768 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9770, "end": 9773 } }, "loc": { "start": 9770, "end": 9773 } }, "directives": [], "loc": { "start": 9761, "end": 9773 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 9776, "end": 9781 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9783, "end": 9789 } }, "loc": { "start": 9783, "end": 9789 } }, "directives": [], "loc": { "start": 9776, "end": 9789 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobSite", "loc": { "start": 9792, "end": 9799 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobSite", "loc": { "start": 9801, "end": 9808 } }, "loc": { "start": 9801, "end": 9808 } }, "directives": [], "loc": { "start": 9792, "end": 9808 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicationDeadline", "loc": { "start": 9811, "end": 9830 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 9832, "end": 9840 } }, "loc": { "start": 9832, "end": 9840 } }, "directives": [], "loc": { "start": 9811, "end": 9840 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "salaryType", "loc": { "start": 9843, "end": 9853 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SalaryType", "loc": { "start": 9855, "end": 9865 } }, "loc": { "start": 9855, "end": 9865 } }, "directives": [], "loc": { "start": 9843, "end": 9865 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "isVisible", "loc": { "start": 9868, "end": 9877 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 9879, "end": 9886 } }, "loc": { "start": 9879, "end": 9886 } }, "directives": [], "loc": { "start": 9868, "end": 9886 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "location", "loc": { "start": 9889, "end": 9897 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9899, "end": 9905 } }, "loc": { "start": 9899, "end": 9905 } }, "directives": [], "loc": { "start": 9889, "end": 9905 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobExperience", "loc": { "start": 9908, "end": 9921 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 9923, "end": 9926 } }, "loc": { "start": 9923, "end": 9926 } }, "directives": [], "loc": { "start": 9908, "end": 9926 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "englishLevel", "loc": { "start": 9929, "end": 9941 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 9943, "end": 9955 } }, "loc": { "start": 9943, "end": 9955 } }, "directives": [], "loc": { "start": 9929, "end": 9955 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "otherLanguages", "loc": { "start": 9958, "end": 9972 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9975, "end": 9981 } }, "loc": { "start": 9975, "end": 9981 } }, "loc": { "start": 9975, "end": 9982 } }, "loc": { "start": 9974, "end": 9983 } }, "directives": [], "loc": { "start": 9958, "end": 9983 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 9986, "end": 9992 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 9995, "end": 10001 } }, "loc": { "start": 9995, "end": 10001 } }, "loc": { "start": 9995, "end": 10002 } }, "loc": { "start": 9994, "end": 10003 } }, "directives": [], "loc": { "start": 9986, "end": 10003 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "qualifications", "loc": { "start": 10006, "end": 10020 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10023, "end": 10029 } }, "loc": { "start": 10023, "end": 10029 } }, "loc": { "start": 10023, "end": 10030 } }, "loc": { "start": 10022, "end": 10031 } }, "directives": [], "loc": { "start": 10006, "end": 10031 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "interviewQuestions", "loc": { "start": 10034, "end": 10052 } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10055, "end": 10061 } }, "loc": { "start": 10055, "end": 10061 } }, "loc": { "start": 10055, "end": 10062 } }, "loc": { "start": 10054, "end": 10063 } }, "directives": [], "loc": { "start": 10034, "end": 10063 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "experienceLevel", "loc": { "start": 10066, "end": 10081 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 10083, "end": 10098 } }, "loc": { "start": 10083, "end": 10098 } }, "directives": [], "loc": { "start": 10066, "end": 10098 } }], "loc": { "start": 9634, "end": 10100 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "EditJobPostInput", "loc": { "start": 10108, "end": 10124 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "filter", "loc": { "start": 10129, "end": 10135 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EditJobPostFilter", "loc": { "start": 10137, "end": 10154 } }, "loc": { "start": 10137, "end": 10154 } }, "loc": { "start": 10137, "end": 10155 } }, "directives": [], "loc": { "start": 10129, "end": 10155 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "editedData", "loc": { "start": 10158, "end": 10168 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EditJobPostInputData", "loc": { "start": 10170, "end": 10190 } }, "loc": { "start": 10170, "end": 10190 } }, "loc": { "start": 10170, "end": 10191 } }, "directives": [], "loc": { "start": 10158, "end": 10191 } }], "loc": { "start": 10102, "end": 10193 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetSavedApplicantInput", "loc": { "start": 10201, "end": 10223 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 10228, "end": 10237 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10239, "end": 10245 } }, "loc": { "start": 10239, "end": 10245 } }, "loc": { "start": 10239, "end": 10246 } }, "directives": [], "loc": { "start": 10228, "end": 10246 } }], "loc": { "start": 10195, "end": 10248 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "SaveApplicantInput", "loc": { "start": 10256, "end": 10274 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 10279, "end": 10290 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10292, "end": 10298 } }, "loc": { "start": 10292, "end": 10298 } }, "loc": { "start": 10292, "end": 10299 } }, "directives": [], "loc": { "start": 10279, "end": 10299 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 10302, "end": 10311 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10313, "end": 10319 } }, "loc": { "start": 10313, "end": 10319 } }, "loc": { "start": 10313, "end": 10320 } }, "directives": [], "loc": { "start": 10302, "end": 10320 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "save", "loc": { "start": 10323, "end": 10327 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 10329, "end": 10336 } }, "loc": { "start": 10329, "end": 10336 } }, "loc": { "start": 10329, "end": 10337 } }, "defaultValue": { "kind": "BooleanValue", "value": true, "loc": { "start": 10340, "end": 10344 } }, "directives": [], "loc": { "start": 10323, "end": 10344 } }], "loc": { "start": 10250, "end": 10346 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "JobPostResponse", "loc": { "start": 10353, "end": 10368 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 10373, "end": 10379 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 10382, "end": 10387 } }, "loc": { "start": 10382, "end": 10387 } }, "loc": { "start": 10382, "end": 10388 } }, "loc": { "start": 10381, "end": 10389 } }, "loc": { "start": 10381, "end": 10390 } }, "directives": [], "loc": { "start": 10373, "end": 10390 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPost", "loc": { "start": 10393, "end": 10400 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10402, "end": 10409 } }, "loc": { "start": 10402, "end": 10409 } }, "directives": [], "loc": { "start": 10393, "end": 10409 } }], "loc": { "start": 10348, "end": 10411 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "CompanyJobPostsResponse", "loc": { "start": 10418, "end": 10441 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "errors", "loc": { "start": 10446, "end": 10452 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Error", "loc": { "start": 10455, "end": 10460 } }, "loc": { "start": 10455, "end": 10460 } }, "loc": { "start": 10455, "end": 10461 } }, "loc": { "start": 10454, "end": 10462 } }, "loc": { "start": 10454, "end": 10463 } }, "directives": [], "loc": { "start": 10446, "end": 10463 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPosts", "loc": { "start": 10466, "end": 10474 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10477, "end": 10484 } }, "loc": { "start": 10477, "end": 10484 } }, "loc": { "start": 10477, "end": 10485 } }, "loc": { "start": 10476, "end": 10486 } }, "loc": { "start": 10476, "end": 10487 } }, "directives": [], "loc": { "start": 10466, "end": 10487 } }], "loc": { "start": 10413, "end": 10489 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Company", "loc": { "start": 10496, "end": 10503 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 10515, "end": 10519 } }, "loc": { "start": 10515, "end": 10519 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 10524, "end": 10526 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 10528, "end": 10530 } }, "loc": { "start": 10528, "end": 10530 } }, "loc": { "start": 10528, "end": 10531 } }, "directives": [], "loc": { "start": 10524, "end": 10531 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyName", "loc": { "start": 10534, "end": 10545 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10547, "end": 10553 } }, "loc": { "start": 10547, "end": 10553 } }, "directives": [], "loc": { "start": 10534, "end": 10553 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "logo", "loc": { "start": 10556, "end": 10560 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10562, "end": 10568 } }, "loc": { "start": 10562, "end": 10568 } }, "directives": [], "loc": { "start": 10556, "end": 10568 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "account", "loc": { "start": 10571, "end": 10578 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Account", "loc": { "start": 10580, "end": 10587 } }, "loc": { "start": 10580, "end": 10587 } }, "loc": { "start": 10580, "end": 10588 } }, "directives": [], "loc": { "start": 10571, "end": 10588 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "savedApplicants", "loc": { "start": 10591, "end": 10606 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 10609, "end": 10618 } }, "loc": { "start": 10609, "end": 10618 } }, "loc": { "start": 10609, "end": 10619 } }, "loc": { "start": 10608, "end": 10620 } }, "loc": { "start": 10608, "end": 10621 } }, "directives": [], "loc": { "start": 10591, "end": 10621 } }], "loc": { "start": 10491, "end": 10623 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Query", "loc": { "start": 10636, "end": 10641 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getJobPosts", "loc": { "start": 10646, "end": 10657 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 10658, "end": 10663 } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JopPostFilterInput", "loc": { "start": 10665, "end": 10683 } }, "loc": { "start": 10665, "end": 10683 } }, "directives": [], "loc": { "start": 10658, "end": 10683 } }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10687, "end": 10694 } }, "loc": { "start": 10687, "end": 10694 } }, "loc": { "start": 10687, "end": 10695 } }, "loc": { "start": 10686, "end": 10696 } }, "loc": { "start": 10686, "end": 10697 } }, "directives": [], "loc": { "start": 10646, "end": 10697 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getJobPost", "loc": { "start": 10700, "end": 10710 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 10711, "end": 10716 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GetJobPostInput", "loc": { "start": 10718, "end": 10733 } }, "loc": { "start": 10718, "end": 10733 } }, "loc": { "start": 10718, "end": 10734 } }, "directives": [], "loc": { "start": 10711, "end": 10734 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10737, "end": 10744 } }, "loc": { "start": 10737, "end": 10744 } }, "directives": [], "loc": { "start": 10700, "end": 10744 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "getSavedJobPosts", "loc": { "start": 10747, "end": 10763 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 10764, "end": 10769 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SavedJobPostsInput", "loc": { "start": 10771, "end": 10789 } }, "loc": { "start": 10771, "end": 10789 } }, "loc": { "start": 10771, "end": 10790 } }, "directives": [], "loc": { "start": 10764, "end": 10790 } }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10794, "end": 10801 } }, "loc": { "start": 10794, "end": 10801 } }, "loc": { "start": 10794, "end": 10802 } }, "loc": { "start": 10793, "end": 10803 } }, "loc": { "start": 10793, "end": 10804 } }, "directives": [], "loc": { "start": 10747, "end": 10804 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "sayHi", "loc": { "start": 10807, "end": 10812 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10814, "end": 10820 } }, "loc": { "start": 10814, "end": 10820 } }, "directives": [], "loc": { "start": 10807, "end": 10820 } }], "loc": { "start": 10624, "end": 10822 } }, { "kind": "ObjectTypeExtension", "name": { "kind": "Name", "value": "Mutation", "loc": { "start": 10836, "end": 10844 } }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "saveJobPost", "loc": { "start": 10849, "end": 10860 } }, "arguments": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "input", "loc": { "start": 10861, "end": 10866 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SaveJobPostInput", "loc": { "start": 10868, "end": 10884 } }, "loc": { "start": 10868, "end": 10884 } }, "loc": { "start": 10868, "end": 10885 } }, "directives": [], "loc": { "start": 10861, "end": 10885 } }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10888, "end": 10895 } }, "loc": { "start": 10888, "end": 10895 } }, "directives": [], "loc": { "start": 10849, "end": 10895 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "sayHi", "loc": { "start": 10898, "end": 10903 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10905, "end": 10911 } }, "loc": { "start": 10905, "end": 10911 } }, "loc": { "start": 10905, "end": 10912 } }, "directives": [], "loc": { "start": 10898, "end": 10912 } }], "loc": { "start": 10824, "end": 10914 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 10921, "end": 10928 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 10940, "end": 10944 } }, "loc": { "start": 10940, "end": 10944 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 10949, "end": 10951 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 10953, "end": 10955 } }, "loc": { "start": 10953, "end": 10955 } }, "loc": { "start": 10953, "end": 10956 } }, "directives": [], "loc": { "start": 10949, "end": 10956 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "title", "loc": { "start": 10959, "end": 10964 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10966, "end": 10972 } }, "loc": { "start": 10966, "end": 10972 } }, "loc": { "start": 10966, "end": 10973 } }, "directives": [], "loc": { "start": 10959, "end": 10973 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 10976, "end": 10985 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 10987, "end": 10993 } }, "loc": { "start": 10987, "end": 10993 } }, "loc": { "start": 10987, "end": 10994 } }, "directives": [], "loc": { "start": 10976, "end": 10994 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 10997, "end": 11008 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11010, "end": 11016 } }, "loc": { "start": 11010, "end": 11016 } }, "loc": { "start": 11010, "end": 11017 } }, "directives": [], "loc": { "start": 10997, "end": 11017 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobType", "loc": { "start": 11020, "end": 11027 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobType", "loc": { "start": 11029, "end": 11036 } }, "loc": { "start": 11029, "end": 11036 } }, "loc": { "start": 11029, "end": 11037 } }, "directives": [], "loc": { "start": 11020, "end": 11037 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "salaryType", "loc": { "start": 11040, "end": 11050 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SalaryType", "loc": { "start": 11052, "end": 11062 } }, "loc": { "start": 11052, "end": 11062 } }, "loc": { "start": 11052, "end": 11063 } }, "directives": [], "loc": { "start": 11040, "end": 11063 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "salary", "loc": { "start": 11066, "end": 11072 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 11075, "end": 11078 } }, "loc": { "start": 11075, "end": 11078 } }, "loc": { "start": 11075, "end": 11079 } }, "loc": { "start": 11074, "end": 11080 } }, "loc": { "start": 11074, "end": 11081 } }, "directives": [], "loc": { "start": 11066, "end": 11081 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "category", "loc": { "start": 11084, "end": 11092 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11095, "end": 11101 } }, "loc": { "start": 11095, "end": 11101 } }, "loc": { "start": 11095, "end": 11102 } }, "loc": { "start": 11094, "end": 11103 } }, "loc": { "start": 11094, "end": 11104 } }, "directives": [], "loc": { "start": 11084, "end": 11104 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "vacancy", "loc": { "start": 11107, "end": 11114 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 11116, "end": 11119 } }, "loc": { "start": 11116, "end": 11119 } }, "loc": { "start": 11116, "end": 11120 } }, "directives": [], "loc": { "start": 11107, "end": 11120 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "location", "loc": { "start": 11123, "end": 11131 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11133, "end": 11139 } }, "loc": { "start": 11133, "end": 11139 } }, "loc": { "start": 11133, "end": 11140 } }, "directives": [], "loc": { "start": 11123, "end": 11140 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 11143, "end": 11148 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11150, "end": 11156 } }, "loc": { "start": 11150, "end": 11156 } }, "loc": { "start": 11150, "end": 11157 } }, "directives": [], "loc": { "start": 11143, "end": 11157 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobSite", "loc": { "start": 11160, "end": 11167 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobSite", "loc": { "start": 11169, "end": 11176 } }, "loc": { "start": 11169, "end": 11176 } }, "loc": { "start": 11169, "end": 11177 } }, "directives": [], "loc": { "start": 11160, "end": 11177 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicationDeadline", "loc": { "start": 11180, "end": 11199 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11201, "end": 11209 } }, "loc": { "start": 11201, "end": 11209 } }, "loc": { "start": 11201, "end": 11210 } }, "directives": [], "loc": { "start": 11180, "end": 11210 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "isVisible", "loc": { "start": 11213, "end": 11222 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 11224, "end": 11231 } }, "loc": { "start": 11224, "end": 11231 } }, "loc": { "start": 11224, "end": 11232 } }, "directives": [], "loc": { "start": 11213, "end": 11232 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "experienceLevel", "loc": { "start": 11235, "end": 11250 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 11252, "end": 11267 } }, "loc": { "start": 11252, "end": 11267 } }, "loc": { "start": 11252, "end": 11268 } }, "directives": [], "loc": { "start": 11235, "end": 11268 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobExperience", "loc": { "start": 11271, "end": 11284 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int", "loc": { "start": 11286, "end": 11289 } }, "loc": { "start": 11286, "end": 11289 } }, "loc": { "start": 11286, "end": 11290 } }, "directives": [], "loc": { "start": 11271, "end": 11290 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "englishLevel", "loc": { "start": 11293, "end": 11305 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 11307, "end": 11319 } }, "loc": { "start": 11307, "end": 11319 } }, "loc": { "start": 11307, "end": 11320 } }, "directives": [], "loc": { "start": 11293, "end": 11320 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "otherLanguages", "loc": { "start": 11323, "end": 11337 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11340, "end": 11346 } }, "loc": { "start": 11340, "end": 11346 } }, "loc": { "start": 11340, "end": 11347 } }, "loc": { "start": 11339, "end": 11348 } }, "loc": { "start": 11339, "end": 11349 } }, "directives": [], "loc": { "start": 11323, "end": 11349 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "skills", "loc": { "start": 11352, "end": 11358 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11361, "end": 11367 } }, "loc": { "start": 11361, "end": 11367 } }, "loc": { "start": 11361, "end": 11368 } }, "loc": { "start": 11360, "end": 11369 } }, "loc": { "start": 11360, "end": 11370 } }, "directives": [], "loc": { "start": 11352, "end": 11370 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "qualifications", "loc": { "start": 11373, "end": 11387 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11390, "end": 11396 } }, "loc": { "start": 11390, "end": 11396 } }, "loc": { "start": 11390, "end": 11397 } }, "loc": { "start": 11389, "end": 11398 } }, "loc": { "start": 11389, "end": 11399 } }, "directives": [], "loc": { "start": 11373, "end": 11399 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "interviewQuestions", "loc": { "start": 11402, "end": 11420 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11423, "end": 11429 } }, "loc": { "start": 11423, "end": 11429 } }, "loc": { "start": 11423, "end": 11430 } }, "loc": { "start": 11422, "end": 11431 } }, "loc": { "start": 11422, "end": 11432 } }, "directives": [], "loc": { "start": 11402, "end": 11432 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 11435, "end": 11444 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11446, "end": 11454 } }, "loc": { "start": 11446, "end": 11454 } }, "loc": { "start": 11446, "end": 11455 } }, "directives": [], "loc": { "start": 11435, "end": 11455 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "updatedAt", "loc": { "start": 11458, "end": 11467 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11469, "end": 11477 } }, "loc": { "start": 11469, "end": 11477 } }, "loc": { "start": 11469, "end": 11478 } }, "directives": [], "loc": { "start": 11458, "end": 11478 } }], "loc": { "start": 10916, "end": 11480 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Application", "loc": { "start": 11487, "end": 11498 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 11510, "end": 11514 } }, "loc": { "start": 11510, "end": 11514 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 11519, "end": 11521 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 11523, "end": 11525 } }, "loc": { "start": 11523, "end": 11525 } }, "loc": { "start": 11523, "end": 11526 } }, "directives": [], "loc": { "start": 11519, "end": 11526 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "status", "loc": { "start": 11529, "end": 11535 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationStatus", "loc": { "start": 11537, "end": 11554 } }, "loc": { "start": 11537, "end": 11554 } }, "loc": { "start": 11537, "end": 11555 } }, "directives": [], "loc": { "start": 11529, "end": 11555 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "coverLetter", "loc": { "start": 11558, "end": 11569 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11571, "end": 11577 } }, "loc": { "start": 11571, "end": 11577 } }, "loc": { "start": 11571, "end": 11578 } }, "directives": [], "loc": { "start": 11558, "end": 11578 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "resume", "loc": { "start": 11581, "end": 11587 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11589, "end": 11595 } }, "loc": { "start": 11589, "end": 11595 } }, "loc": { "start": 11589, "end": 11596 } }, "directives": [], "loc": { "start": 11581, "end": 11596 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "email", "loc": { "start": 11599, "end": 11604 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11606, "end": 11612 } }, "loc": { "start": 11606, "end": 11612 } }, "loc": { "start": 11606, "end": 11613 } }, "directives": [], "loc": { "start": 11599, "end": 11613 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "phone", "loc": { "start": 11616, "end": 11621 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11623, "end": 11629 } }, "loc": { "start": 11623, "end": 11629 } }, "loc": { "start": 11623, "end": 11630 } }, "directives": [], "loc": { "start": 11616, "end": 11630 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "attachment", "loc": { "start": 11633, "end": 11643 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11645, "end": 11651 } }, "loc": { "start": 11645, "end": 11651 } }, "directives": [], "loc": { "start": 11633, "end": 11651 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 11654, "end": 11665 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11667, "end": 11673 } }, "loc": { "start": 11667, "end": 11673 } }, "loc": { "start": 11667, "end": 11674 } }, "directives": [], "loc": { "start": 11654, "end": 11674 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 11677, "end": 11686 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11688, "end": 11694 } }, "loc": { "start": 11688, "end": 11694 } }, "loc": { "start": 11688, "end": 11695 } }, "directives": [], "loc": { "start": 11677, "end": 11695 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 11698, "end": 11707 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11709, "end": 11717 } }, "loc": { "start": 11709, "end": 11717 } }, "loc": { "start": 11709, "end": 11718 } }, "directives": [], "loc": { "start": 11698, "end": 11718 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "updatedAt", "loc": { "start": 11721, "end": 11730 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11732, "end": 11740 } }, "loc": { "start": 11732, "end": 11740 } }, "loc": { "start": 11732, "end": 11741 } }, "directives": [], "loc": { "start": 11721, "end": 11741 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPost", "loc": { "start": 11744, "end": 11751 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JobPost", "loc": { "start": 11753, "end": 11760 } }, "loc": { "start": 11753, "end": 11760 } }, "directives": [], "loc": { "start": 11744, "end": 11760 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "interview", "loc": { "start": 11763, "end": 11772 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Interview", "loc": { "start": 11774, "end": 11783 } }, "loc": { "start": 11774, "end": 11783 } }, "directives": [], "loc": { "start": 11763, "end": 11783 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "offer", "loc": { "start": 11786, "end": 11791 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Offer", "loc": { "start": 11793, "end": 11798 } }, "loc": { "start": 11793, "end": 11798 } }, "directives": [], "loc": { "start": 11786, "end": 11798 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicant", "loc": { "start": 11801, "end": 11810 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Applicant", "loc": { "start": 11812, "end": 11821 } }, "loc": { "start": 11812, "end": 11821 } }, "directives": [], "loc": { "start": 11801, "end": 11821 } }], "loc": { "start": 11482, "end": 11823 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Interview", "loc": { "start": 11830, "end": 11839 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 11851, "end": 11855 } }, "loc": { "start": 11851, "end": 11855 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 11860, "end": 11862 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 11864, "end": 11866 } }, "loc": { "start": 11864, "end": 11866 } }, "loc": { "start": 11864, "end": 11867 } }, "directives": [], "loc": { "start": 11860, "end": 11867 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "status", "loc": { "start": 11870, "end": 11876 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "InterviewStatus", "loc": { "start": 11878, "end": 11893 } }, "loc": { "start": 11878, "end": 11893 } }, "directives": [], "loc": { "start": 11870, "end": 11893 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "attachment", "loc": { "start": 11896, "end": 11906 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11908, "end": 11914 } }, "loc": { "start": 11908, "end": 11914 } }, "directives": [], "loc": { "start": 11896, "end": 11914 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "deadline", "loc": { "start": 11917, "end": 11925 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 11927, "end": 11935 } }, "loc": { "start": 11927, "end": 11935 } }, "directives": [], "loc": { "start": 11917, "end": 11935 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 11938, "end": 11949 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11951, "end": 11957 } }, "loc": { "start": 11951, "end": 11957 } }, "loc": { "start": 11951, "end": 11958 } }, "directives": [], "loc": { "start": 11938, "end": 11958 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "answerVideo", "loc": { "start": 11961, "end": 11972 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11974, "end": 11980 } }, "loc": { "start": 11974, "end": 11980 } }, "directives": [], "loc": { "start": 11961, "end": 11980 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "answerText", "loc": { "start": 11983, "end": 11993 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 11995, "end": 12001 } }, "loc": { "start": 11995, "end": 12001 } }, "directives": [], "loc": { "start": 11983, "end": 12001 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 12004, "end": 12015 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12017, "end": 12023 } }, "loc": { "start": 12017, "end": 12023 } }, "loc": { "start": 12017, "end": 12024 } }, "directives": [], "loc": { "start": 12004, "end": 12024 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 12027, "end": 12036 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12038, "end": 12044 } }, "loc": { "start": 12038, "end": 12044 } }, "loc": { "start": 12038, "end": 12045 } }, "directives": [], "loc": { "start": 12027, "end": 12045 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 12048, "end": 12057 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12059, "end": 12065 } }, "loc": { "start": 12059, "end": 12065 } }, "loc": { "start": 12059, "end": 12066 } }, "directives": [], "loc": { "start": 12048, "end": 12066 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobApplicationId", "loc": { "start": 12069, "end": 12085 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12087, "end": 12093 } }, "loc": { "start": 12087, "end": 12093 } }, "directives": [], "loc": { "start": 12069, "end": 12093 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 12096, "end": 12105 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 12107, "end": 12115 } }, "loc": { "start": 12107, "end": 12115 } }, "loc": { "start": 12107, "end": 12116 } }, "directives": [], "loc": { "start": 12096, "end": 12116 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "updatedAt", "loc": { "start": 12119, "end": 12128 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 12130, "end": 12138 } }, "loc": { "start": 12130, "end": 12138 } }, "loc": { "start": 12130, "end": 12139 } }, "directives": [], "loc": { "start": 12119, "end": 12139 } }], "loc": { "start": 11825, "end": 12141 } }, { "kind": "ObjectTypeDefinition", "name": { "kind": "Name", "value": "Offer", "loc": { "start": 12148, "end": 12153 } }, "interfaces": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "Node", "loc": { "start": 12165, "end": 12169 } }, "loc": { "start": 12165, "end": 12169 } }], "directives": [], "fields": [{ "kind": "FieldDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 12174, "end": 12176 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID", "loc": { "start": 12178, "end": 12180 } }, "loc": { "start": 12178, "end": 12180 } }, "loc": { "start": 12178, "end": 12181 } }, "directives": [], "loc": { "start": 12174, "end": 12181 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "status", "loc": { "start": 12184, "end": 12190 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OfferStatus", "loc": { "start": 12192, "end": 12203 } }, "loc": { "start": 12192, "end": 12203 } }, "directives": [], "loc": { "start": 12184, "end": 12203 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "deadline", "loc": { "start": 12206, "end": 12214 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 12216, "end": 12224 } }, "loc": { "start": 12216, "end": 12224 } }, "directives": [], "loc": { "start": 12206, "end": 12224 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "description", "loc": { "start": 12227, "end": 12238 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12240, "end": 12246 } }, "loc": { "start": 12240, "end": 12246 } }, "loc": { "start": 12240, "end": 12247 } }, "directives": [], "loc": { "start": 12227, "end": 12247 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "answerVideo", "loc": { "start": 12250, "end": 12261 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12263, "end": 12269 } }, "loc": { "start": 12263, "end": 12269 } }, "directives": [], "loc": { "start": 12250, "end": 12269 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "answerText", "loc": { "start": 12272, "end": 12282 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12284, "end": 12290 } }, "loc": { "start": 12284, "end": 12290 } }, "directives": [], "loc": { "start": 12272, "end": 12290 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "applicantId", "loc": { "start": 12293, "end": 12304 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12306, "end": 12312 } }, "loc": { "start": 12306, "end": 12312 } }, "loc": { "start": 12306, "end": 12313 } }, "directives": [], "loc": { "start": 12293, "end": 12313 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 12316, "end": 12325 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12327, "end": 12333 } }, "loc": { "start": 12327, "end": 12333 } }, "loc": { "start": 12327, "end": 12334 } }, "directives": [], "loc": { "start": 12316, "end": 12334 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 12337, "end": 12346 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12348, "end": 12354 } }, "loc": { "start": 12348, "end": 12354 } }, "loc": { "start": 12348, "end": 12355 } }, "directives": [], "loc": { "start": 12337, "end": 12355 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "jobApplicationId", "loc": { "start": 12358, "end": 12374 } }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12376, "end": 12382 } }, "loc": { "start": 12376, "end": 12382 } }, "directives": [], "loc": { "start": 12358, "end": 12382 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "createdAt", "loc": { "start": 12385, "end": 12394 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 12396, "end": 12404 } }, "loc": { "start": 12396, "end": 12404 } }, "loc": { "start": 12396, "end": 12405 } }, "directives": [], "loc": { "start": 12385, "end": 12405 } }, { "kind": "FieldDefinition", "name": { "kind": "Name", "value": "updatedAt", "loc": { "start": 12408, "end": 12417 } }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime", "loc": { "start": 12419, "end": 12427 } }, "loc": { "start": 12419, "end": 12427 } }, "loc": { "start": 12419, "end": 12428 } }, "directives": [], "loc": { "start": 12408, "end": 12428 } }], "loc": { "start": 12143, "end": 12430 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "JopPostFilterInput", "loc": { "start": 12438, "end": 12456 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "companyId", "loc": { "start": 12461, "end": 12470 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12472, "end": 12478 } }, "loc": { "start": 12472, "end": 12478 } }, "loc": { "start": 12472, "end": 12479 } }, "directives": [], "loc": { "start": 12461, "end": 12479 } }], "loc": { "start": 12432, "end": 12481 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "GetJobPostInput", "loc": { "start": 12489, "end": 12504 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "id", "loc": { "start": 12509, "end": 12511 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12513, "end": 12519 } }, "loc": { "start": 12513, "end": 12519 } }, "loc": { "start": 12513, "end": 12520 } }, "directives": [], "loc": { "start": 12509, "end": 12520 } }], "loc": { "start": 12483, "end": 12522 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "SavedJobPostsInput", "loc": { "start": 12530, "end": 12548 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountId", "loc": { "start": 12553, "end": 12562 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12564, "end": 12570 } }, "loc": { "start": 12564, "end": 12570 } }, "loc": { "start": 12564, "end": 12571 } }, "directives": [], "loc": { "start": 12553, "end": 12571 } }], "loc": { "start": 12524, "end": 12573 } }, { "kind": "InputObjectTypeDefinition", "name": { "kind": "Name", "value": "SaveJobPostInput", "loc": { "start": 12581, "end": 12597 } }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "jobPostId", "loc": { "start": 12602, "end": 12611 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12613, "end": 12619 } }, "loc": { "start": 12613, "end": 12619 } }, "loc": { "start": 12613, "end": 12620 } }, "directives": [], "loc": { "start": 12602, "end": 12620 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "accountId", "loc": { "start": 12623, "end": 12632 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String", "loc": { "start": 12634, "end": 12640 } }, "loc": { "start": 12634, "end": 12640 } }, "loc": { "start": 12634, "end": 12641 } }, "directives": [], "loc": { "start": 12623, "end": 12641 } }, { "kind": "InputValueDefinition", "name": { "kind": "Name", "value": "save", "loc": { "start": 12644, "end": 12648 } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean", "loc": { "start": 12650, "end": 12657 } }, "loc": { "start": 12650, "end": 12657 } }, "loc": { "start": 12650, "end": 12658 } }, "directives": [], "loc": { "start": 12644, "end": 12658 } }], "loc": { "start": 12575, "end": 12660 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "SalaryType", "loc": { "start": 12667, "end": 12677 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "HOURLY", "loc": { "start": 12682, "end": 12688 } }, "directives": [], "loc": { "start": 12682, "end": 12688 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "MONTHLY", "loc": { "start": 12691, "end": 12698 } }, "directives": [], "loc": { "start": 12691, "end": 12698 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "YEARLY", "loc": { "start": 12701, "end": 12707 } }, "directives": [], "loc": { "start": 12701, "end": 12707 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "ONE_TIME", "loc": { "start": 12710, "end": 12718 } }, "directives": [], "loc": { "start": 12710, "end": 12718 } }], "loc": { "start": 12662, "end": 12720 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "EnglishLevel", "loc": { "start": 12727, "end": 12739 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "BASIC", "loc": { "start": 12744, "end": 12749 } }, "directives": [], "loc": { "start": 12744, "end": 12749 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "CONVERSATIONAL", "loc": { "start": 12752, "end": 12766 } }, "directives": [], "loc": { "start": 12752, "end": 12766 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "FLUENT", "loc": { "start": 12769, "end": 12775 } }, "directives": [], "loc": { "start": 12769, "end": 12775 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "NATIVE", "loc": { "start": 12778, "end": 12784 } }, "directives": [], "loc": { "start": 12778, "end": 12784 } }], "loc": { "start": 12722, "end": 12786 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "JobSite", "loc": { "start": 12793, "end": 12800 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "ONSITE", "loc": { "start": 12805, "end": 12811 } }, "directives": [], "loc": { "start": 12805, "end": 12811 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "REMOTE", "loc": { "start": 12814, "end": 12820 } }, "directives": [], "loc": { "start": 12814, "end": 12820 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "HYBRID", "loc": { "start": 12823, "end": 12829 } }, "directives": [], "loc": { "start": 12823, "end": 12829 } }], "loc": { "start": 12788, "end": 12831 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "JobType", "loc": { "start": 12838, "end": 12845 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "CONTRACTUAL", "loc": { "start": 12850, "end": 12861 } }, "directives": [], "loc": { "start": 12850, "end": 12861 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "INTERNSHIP", "loc": { "start": 12864, "end": 12874 } }, "directives": [], "loc": { "start": 12864, "end": 12874 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "FULL_TIME", "loc": { "start": 12877, "end": 12886 } }, "directives": [], "loc": { "start": 12877, "end": 12886 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "PART_TIME", "loc": { "start": 12889, "end": 12898 } }, "directives": [], "loc": { "start": 12889, "end": 12898 } }], "loc": { "start": 12833, "end": 12900 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "ExperienceLevel", "loc": { "start": 12907, "end": 12922 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "Beginner", "loc": { "start": 12927, "end": 12935 } }, "directives": [], "loc": { "start": 12927, "end": 12935 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "Intermediate", "loc": { "start": 12938, "end": 12950 } }, "directives": [], "loc": { "start": 12938, "end": 12950 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "Expert", "loc": { "start": 12953, "end": 12959 } }, "directives": [], "loc": { "start": 12953, "end": 12959 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "Junior", "loc": { "start": 12962, "end": 12968 } }, "directives": [], "loc": { "start": 12962, "end": 12968 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "Senior", "loc": { "start": 12971, "end": 12977 } }, "directives": [], "loc": { "start": 12971, "end": 12977 } }], "loc": { "start": 12902, "end": 12979 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "ApplicationStatus", "loc": { "start": 12986, "end": 13003 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "PENDING", "loc": { "start": 13008, "end": 13015 } }, "directives": [], "loc": { "start": 13008, "end": 13015 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "INTERVIEW", "loc": { "start": 13018, "end": 13027 } }, "directives": [], "loc": { "start": 13018, "end": 13027 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "OFFER", "loc": { "start": 13030, "end": 13035 } }, "directives": [], "loc": { "start": 13030, "end": 13035 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "ACCEPTED", "loc": { "start": 13038, "end": 13046 } }, "directives": [], "loc": { "start": 13038, "end": 13046 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "REJECTED", "loc": { "start": 13049, "end": 13057 } }, "directives": [], "loc": { "start": 13049, "end": 13057 } }], "loc": { "start": 12981, "end": 13059 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "InterviewStatus", "loc": { "start": 13066, "end": 13081 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "PENDING", "loc": { "start": 13086, "end": 13093 } }, "directives": [], "loc": { "start": 13086, "end": 13093 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "APPLICANT_REFUSED", "loc": { "start": 13096, "end": 13113 } }, "directives": [], "loc": { "start": 13096, "end": 13113 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "APPLICANT_RESPONDED", "loc": { "start": 13116, "end": 13135 } }, "directives": [], "loc": { "start": 13116, "end": 13135 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "ACCEPTED", "loc": { "start": 13138, "end": 13146 } }, "directives": [], "loc": { "start": 13138, "end": 13146 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "REJECTED", "loc": { "start": 13149, "end": 13157 } }, "directives": [], "loc": { "start": 13149, "end": 13157 } }], "loc": { "start": 13061, "end": 13159 } }, { "kind": "EnumTypeDefinition", "name": { "kind": "Name", "value": "OfferStatus", "loc": { "start": 13166, "end": 13177 } }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "PENDING", "loc": { "start": 13182, "end": 13189 } }, "directives": [], "loc": { "start": 13182, "end": 13189 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "APPLICANT_REFUSED", "loc": { "start": 13192, "end": 13209 } }, "directives": [], "loc": { "start": 13192, "end": 13209 } }, { "kind": "EnumValueDefinition", "name": { "kind": "Name", "value": "ACCEPTED", "loc": { "start": 13212, "end": 13220 } }, "directives": [], "loc": { "start": 13212, "end": 13220 } }], "loc": { "start": 13161, "end": 13222 } }], "loc": { "start": 0, "end": 13223 } };

// src/graphql/schema/account/resolvers/Account.ts
var Account = {
  /* Implement Account resolver logic here */
};

// src/graphql/schema/account/resolvers/AccountPayload.ts
var AccountPayload = {
  /* Implement AccountPayload resolver logic here */
};

// src/graphql/schema/account/resolvers/AccountUpdate.ts
var AccountUpdate = {
  /* Implement AccountUpdate resolver logic here */
};

// src/graphql/schema/affiliate/resolvers/Affiliate.ts
var Affiliate = {
  /* Implement Affiliate resolver logic here */
};

// src/graphql/schema/affiliate/resolvers/AffiliateLight.ts
var AffiliateLight = {
  /* Implement AffiliateLight resolver logic here */
};

// src/graphql/schema/applicant/resolvers/Applicant.ts
var import_error10 = __toESM(require_error());
var Applicant = {
  savedJobs: async (parent, args, context) => {
    const saved = await context.service.Applicant.getSavedJobs({
      id: parent.id
    });
    return {
      pageInfo: {
        hasNextPage: false,
        hasPreviousPage: false
      },
      edges: saved.map((job) => ({ node: job, cursor: job.id }))
    };
  },
  workExperience: async (parent, args, context) => {
    const experience = await context.service.Applicant.getWorkExperience({
      id: parent.id ?? ""
    });
    return experience;
  },
  account: async (parent, args, context) => {
    const applicant = await context.service.Applicant.getApplicantAccount({
      id: parent.id
    });
    if (applicant === null) {
      throw new import_error10.GraphQLError(
        `account cant be null for a given applicant : ${parent.id}`
      );
    }
    return applicant;
  }
};

// src/graphql/schema/applicant/resolvers/ApplicantAccountConnections.ts
var ApplicantAccountConnections = {
  /* Implement ApplicantAccountConnections resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantAccountEdge.ts
var ApplicantAccountEdge = {
  /* Implement ApplicantAccountEdge resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantAppliedJobPostEdge.ts
var ApplicantAppliedJobPostEdge = {
  /* Implement ApplicantAppliedJobPostEdge resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantConnection.ts
var ApplicantConnection = {
  /* Implement ApplicantConnection resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantEdge.ts
var ApplicantEdge = {
  /* Implement ApplicantEdge resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantSavedJobPostConnections.ts
var ApplicantSavedJobPostConnections = {
  /* Implement ApplicantSavedJobPostConnections resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicantSavedJobPostEdge.ts
var ApplicantSavedJobPostEdge = {
  /* Implement ApplicantSavedJobPostEdge resolver logic here */
};

// src/graphql/schema/job/resolvers/Application.ts
var Application = {
  jobPost: async (parent, args, context, info) => {
    if (info.operation.name?.value === "GetCompanyJobPosts") {
      return null;
    }
    return await context.service.Job.getJobPost({
      id: parent.jobPostId
    });
  },
  applicant: async (parent, args, context) => {
    return await context.service.Applicant.getApplicant({
      id: parent.applicantId
    });
  }
};

// src/graphql/schema/applicant/resolvers/ApplicationConnections.ts
var ApplicationConnections = {
  /* Implement ApplicationConnections resolver logic here */
};

// src/graphql/schema/applicant/resolvers/ApplicationEdge.ts
var ApplicationEdge = {
  /* Implement ApplicationEdge resolver logic here */
};

// src/graphql/schema/auth/resolvers/AuthAccountPayload.ts
var AuthAccountPayload = {
  /* Implement AuthAccountPayload resolver logic here */
};

// src/graphql/schema/auth/resolvers/AuthApplicant.ts
var AuthApplicant = {
  /* Implement AuthApplicant resolver logic here */
};

// src/graphql/schema/auth/resolvers/AuthPayload.ts
var AuthPayload = {
  /* Implement AuthPayload resolver logic here */
};

// src/graphql/schema/company/resolvers/Company.ts
var import_error11 = __toESM(require_error());
var Company = {
  /* Implement Company resolver logic here */
  account: async (parent, args, context) => {
    const company = await context.service.Company.getCompanyAccount({
      id: parent.id
    });
    if (company === null) {
      throw new import_error11.GraphQLError(
        `account cant be null for a given applicant : ${parent.id}`
      );
    }
    return company;
  },
  savedApplicants: (parent, args, context) => {
    return context.service.Company.getSavedApplicants({
      companyId: parent.id
    });
  }
};

// src/graphql/schema/company/resolvers/CompanyJobPostsResponse.ts
var CompanyJobPostsResponse = {
  /* Implement CompanyJobPostsResponse resolver logic here */
};

// src/graphql/schema/applicant/resolvers/CreateApplicationPayload.ts
var CreateApplicationPayload = {
  /* Implement CreateApplicationPayload resolver logic here */
};

// src/graphql/schema/base/resolvers/Error.ts
var Error2 = {
  /* Implement Error resolver logic here */
};

// src/graphql/schema/auth/resolvers/FindOnePayload.ts
var FindOnePayload = {
  /* Implement FindOnePayload resolver logic here */
};

// src/graphql/schema/job/resolvers/Interview.ts
var Interview = {
  /* Implement Interview resolver logic here */
};

// src/graphql/schema/job/resolvers/JobPost.ts
var JobPost = {
  /* Implement JobPost resolver logic here */
};

// src/graphql/schema/company/resolvers/JobPostResponse.ts
var JobPostResponse = {
  /* Implement JobPostResponse resolver logic here */
};

// src/graphql/schema/applicant/resolvers/Mutation/applicantProfileUpdate.ts
var applicantProfileUpdate = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Account.updateProfile(_arg.input);
};

// src/graphql/schema/applicant/resolvers/Mutation/createApplication.ts
var createApplication2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Applicant.createApplication(_arg.input);
};

// src/graphql/schema/company/resolvers/Mutation/createJobPost.ts
var createJobPost2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Job.createJobPost(_arg.input);
};

// src/graphql/schema/company/resolvers/Mutation/editJobPost.ts
var editJobPost2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Job.editJobPost(_arg.input);
};

// src/graphql/schema/auth/resolvers/Mutation/logIn.ts
var logIn2 = async (_parent, { input }, { service }) => {
  return await service.Auth.logIn(input);
};

// src/graphql/schema/company/resolvers/Mutation/offerApplicant.ts
var offerApplicant = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Company.acceptInterviewAndCreateOffer(_arg.input);
};

// src/graphql/schema/account/resolvers/Mutation/profileUpdate.ts
var profileUpdate = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Account.updateProfile(_arg.input);
};

// src/graphql/schema/applicant/resolvers/Mutation/respondInterview.ts
var respondInterview2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Applicant.respondInterview(_arg.input);
};

// src/graphql/schema/applicant/resolvers/Mutation/respondToOffer.ts
var respondToOffer = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Applicant.respondOffer(_arg.input);
};

// src/graphql/schema/company/resolvers/Mutation/saveApplicant.ts
var saveApplicant2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Company.saveApplicant(_arg.input);
};

// src/graphql/schema/job/resolvers/Mutation/saveJobPost.ts
var saveJobPost2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Job.saveJobPost(_arg.input);
};

// src/graphql/schema/job/resolvers/Mutation/sayHi.ts
var sayHi = async (_parent, _arg, _ctx) => {
};

// src/graphql/schema/company/resolvers/Mutation/sendInterviewRequest.ts
var sendInterviewRequest = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Company.acceptApplicationAndCreateInterview(_arg.input);
};

// src/graphql/schema/auth/resolvers/Mutation/signUp.ts
var signUp2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Auth.signUp(_arg.input);
};

// src/graphql/schema/auth/resolvers/Mutation/signUpOAuth.ts
var signUpOAuth2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Auth.signUpOAuth(_arg.input);
};

// src/graphql/schema/auth/resolvers/OAuth.ts
var OAuth = {
  /* Implement OAuth resolver logic here */
};

// src/graphql/schema/job/resolvers/Offer.ts
var Offer = {
  /* Implement Offer resolver logic here */
};

// src/graphql/schema/applicant/resolvers/PageInfo.ts
var PageInfo = {
  /* Implement PageInfo resolver logic here */
};

// src/graphql/schema/account/resolvers/Query/findAccount.ts
var findAccount = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Account.findOne(_arg.input);
};

// src/graphql/schema/applicant/resolvers/Query/getApplicant.ts
var getApplicant2 = async (_parent, _arg, _ctx) => {
  const applicant = await _ctx.service.Applicant.getApplicant(_arg.input);
  console.log("get applicant resolver : ", applicant);
  if (applicant === null) {
    return null;
  }
  return {
    ...applicant
    // savedJobs: null as any, // left for nested resolver,
    // workExperience: [], // left for nested resolver,
  };
};

// src/graphql/schema/applicant/resolvers/Query/getApplicants.ts
var getApplicants = async (_parent, _arg, _ctx) => {
  const applicants = await _ctx.service.Applicant.getAllApplicants(_arg.input);
  return {
    pageInfo: {
      hasNextPage: !!applicants[0]._count,
      hasPreviousPage: false
    },
    edges: applicants.map((ap2) => ({
      cursor: ap2.id,
      node: { ...ap2 }
    }))
  };
};

// src/graphql/schema/company/resolvers/Query/getCompanies.ts
var getCompanies2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Company.getCompanies();
};

// src/graphql/schema/company/resolvers/Query/getCompanyJobPosts.ts
var getCompanyJobPosts = async (_parent, _arg, { service }) => {
  return await service.Job.getCompanyPostedJobs(_arg.input);
};

// src/graphql/schema/applicant/resolvers/Query/getJobApplications.ts
var getJobApplications2 = async (_parent, _arg, _ctx) => {
  const jobApplications = await _ctx.service.Applicant.getJobApplications(
    _arg.input
  );
  return {
    pageInfo: {
      hasNextPage: false,
      hasPreviousPage: false
    },
    edges: jobApplications.map((application) => ({
      node: application,
      cursor: application.id
    }))
  };
};

// src/graphql/schema/job/resolvers/Query/getJobPost.ts
var getJobPost2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Job.getJobPost(_arg.input);
};

// src/graphql/schema/job/resolvers/Query/getJobPosts.ts
var getJobPosts = async (_parent, _args, { service }) => {
  return await service.Job.getPostedJobs(_args.input);
};

// src/graphql/schema/company/resolvers/Query/getSavedApplicant.ts
var getSavedApplicant = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Company.getSavedApplicants(_arg.input);
};

// src/graphql/schema/job/resolvers/Query/getSavedJobPosts.ts
var getSavedJobPosts = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Job.getSavedJobs(_arg.input);
};

// src/graphql/schema/account/resolvers/Query/me.ts
var me2 = async (_parent, _arg, _ctx) => {
  return await _ctx.service.Account.getMe(_arg.input);
};

// src/graphql/schema/job/resolvers/Query/sayHi.ts
var sayHi2 = async (_parent, _arg, _ctx) => {
  return "this is a test";
};

// src/graphql/schema/applicant/resolvers/WorkExperience.ts
var WorkExperience = {
  /* Implement WorkExperience resolver logic here */
};

// node_modules/graphql-scalars/esm/error.js
var import_graphql42 = __toESM(require_graphql2(), 1);
function createGraphQLError2(message, options) {
  if (import_graphql42.versionInfo.major >= 17) {
    return new import_graphql42.GraphQLError(message, options);
  }
  return new import_graphql42.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
}

// node_modules/graphql-scalars/esm/scalars/iso-date/formatter.js
var parseDateTime = (dateTime) => {
  return new Date(dateTime);
};

// node_modules/graphql-scalars/esm/scalars/iso-date/validator.js
var leapYear = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var validateTime = (time) => {
  time = time === null || time === void 0 ? void 0 : time.toUpperCase();
  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  return TIME_REGEX.test(time);
};
var validateDate = (datestring) => {
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;
  if (!RFC_3339_REGEX.test(datestring)) {
    return false;
  }
  const year = Number(datestring.substr(0, 4));
  const month = Number(datestring.substr(5, 2));
  const day = Number(datestring.substr(8, 2));
  switch (month) {
    case 2:
      if (leapYear(year) && day > 29) {
        return false;
      } else if (!leapYear(year) && day > 28) {
        return false;
      }
      return true;
    case 4:
    case 6:
    case 9:
    case 11:
      if (day > 30) {
        return false;
      }
      break;
  }
  return true;
};
var validateDateTime = (dateTimeString) => {
  dateTimeString = dateTimeString === null || dateTimeString === void 0 ? void 0 : dateTimeString.toUpperCase();
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  if (!RFC_3339_REGEX.test(dateTimeString)) {
    return false;
  }
  const time = Date.parse(dateTimeString);
  if (time !== time) {
    return false;
  }
  const index = dateTimeString.indexOf("T");
  const dateString = dateTimeString.substr(0, index);
  const timeString = dateTimeString.substr(index + 1);
  return validateDate(dateString) && validateTime(timeString);
};
var validateJSDate = (date) => {
  const time = date.getTime();
  return time === time;
};

// node_modules/graphql-scalars/esm/scalars/iso-date/DateTime.js
var import_graphql43 = __toESM(require_graphql2(), 1);
var GraphQLDateTimeConfig = {
  name: "DateTime",
  description: "A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw createGraphQLError2("DateTime cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${value}.`);
    } else if (typeof value === "number") {
      try {
        return new Date(value);
      } catch (e) {
        throw createGraphQLError2("DateTime cannot represent an invalid Unix timestamp " + value);
      }
    } else {
      throw createGraphQLError2("DateTime cannot be serialized from a non string, non numeric or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw createGraphQLError2("DateTime cannot represent an invalid Date instance");
    }
    if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${value}.`);
    }
    throw createGraphQLError2(`DateTime cannot represent non string or Date type ${JSON.stringify(value)}`);
  },
  parseLiteral(ast) {
    if (ast.kind !== import_graphql43.Kind.STRING) {
      throw createGraphQLError2(`DateTime cannot represent non string or Date type ${"value" in ast && ast.value}`, {
        nodes: ast
      });
    }
    const { value } = ast;
    if (validateDateTime(value)) {
      return parseDateTime(value);
    }
    throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${String(value)}.`, { nodes: ast });
  },
  extensions: {
    codegenScalarType: "Date | string",
    jsonSchema: {
      type: "string",
      format: "date-time"
    }
  }
};
var GraphQLDateTime = /* @__PURE__ */ new import_graphql43.GraphQLScalarType(GraphQLDateTimeConfig);

// src/graphql/schema/resolvers.generated.ts
var resolvers = {
  Query: { findAccount, getApplicant: getApplicant2, getApplicants, getCompanies: getCompanies2, getCompanyJobPosts, getJobApplications: getJobApplications2, getJobPost: getJobPost2, getJobPosts, getSavedApplicant, getSavedJobPosts, me: me2, sayHi: sayHi2 },
  Mutation: { applicantProfileUpdate, createApplication: createApplication2, createJobPost: createJobPost2, editJobPost: editJobPost2, logIn: logIn2, offerApplicant, profileUpdate, respondInterview: respondInterview2, respondToOffer, saveApplicant: saveApplicant2, saveJobPost: saveJobPost2, sayHi, sendInterviewRequest, signUp: signUp2, signUpOAuth: signUpOAuth2 },
  Account,
  AccountPayload,
  AccountUpdate,
  Affiliate,
  AffiliateLight,
  Applicant,
  ApplicantAccountConnections,
  ApplicantAccountEdge,
  ApplicantAppliedJobPostEdge,
  ApplicantConnection,
  ApplicantEdge,
  ApplicantSavedJobPostConnections,
  ApplicantSavedJobPostEdge,
  Application,
  ApplicationConnections,
  ApplicationEdge,
  AuthAccountPayload,
  AuthApplicant,
  AuthPayload,
  Company,
  CompanyJobPostsResponse,
  CreateApplicationPayload,
  Error: Error2,
  FindOnePayload,
  Interview,
  JobPost,
  JobPostResponse,
  OAuth,
  Offer,
  PageInfo,
  WorkExperience,
  DateTime: GraphQLDateTime
};

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind2;
(function(MapperKind3) {
  MapperKind3["TYPE"] = "MapperKind.TYPE";
  MapperKind3["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind3["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind3["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind3["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind3["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind3["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind3["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind3["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind3["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind3["QUERY"] = "MapperKind.QUERY";
  MapperKind3["MUTATION"] = "MapperKind.MUTATION";
  MapperKind3["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind3["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind3["FIELD"] = "MapperKind.FIELD";
  MapperKind3["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind3["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind3["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind3["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind3["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind3["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind3["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind3["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind3["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind3["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind2 || (MapperKind2 = {}));

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/mapSchema.js
var import_graphql48 = __toESM(require_graphql2(), 1);

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
var import_graphql44 = __toESM(require_graphql2(), 1);
function getObjectTypeFromTypeMap2(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if ((0, import_graphql44.isObjectType)(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/rewire.js
var import_graphql46 = __toESM(require_graphql2(), 1);

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/stub.js
var import_graphql45 = __toESM(require_graphql2(), 1);
function isNamedStub2(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub2(type) {
  switch (type.name) {
    case import_graphql45.GraphQLInt.name:
      return import_graphql45.GraphQLInt;
    case import_graphql45.GraphQLFloat.name:
      return import_graphql45.GraphQLFloat;
    case import_graphql45.GraphQLString.name:
      return import_graphql45.GraphQLString;
    case import_graphql45.GraphQLBoolean.name:
      return import_graphql45.GraphQLBoolean;
    case import_graphql45.GraphQLID.name:
      return import_graphql45.GraphQLID;
    default:
      return type;
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes2(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      throw new Error(`Duplicate schema type name ${newName}`);
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if ((0, import_graphql46.isSpecifiedDirective)(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql46.GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if ((0, import_graphql46.isObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields),
        interfaces: () => rewireNamedTypes(config2.interfaces)
      };
      return new import_graphql46.GraphQLObjectType(newConfig);
    } else if ((0, import_graphql46.isInterfaceType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireFields(config2.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new import_graphql46.GraphQLInterfaceType(newConfig);
    } else if ((0, import_graphql46.isUnionType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        types: () => rewireNamedTypes(config2.types)
      };
      return new import_graphql46.GraphQLUnionType(newConfig);
    } else if ((0, import_graphql46.isInputObjectType)(type)) {
      const config2 = type.toConfig();
      const newConfig = {
        ...config2,
        fields: () => rewireInputFields(config2.fields)
      };
      return new import_graphql46.GraphQLInputObjectType(newConfig);
    } else if ((0, import_graphql46.isEnumType)(type)) {
      const enumConfig = type.toConfig();
      return new import_graphql46.GraphQLEnumType(enumConfig);
    } else if ((0, import_graphql46.isScalarType)(type)) {
      if ((0, import_graphql46.isSpecifiedScalarType)(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new import_graphql46.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if ((0, import_graphql46.isListType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql46.GraphQLList(rewiredType) : null;
    } else if ((0, import_graphql46.isNonNullType)(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new import_graphql46.GraphQLNonNull(rewiredType) : null;
    } else if ((0, import_graphql46.isNamedType)(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub2(type) ? getBuiltInForStub2(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/transformInputValue.js
var import_graphql47 = __toESM(require_graphql2(), 1);
function transformInputValue2(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = (0, import_graphql47.getNullableType)(type);
  if ((0, import_graphql47.isLeafType)(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if ((0, import_graphql47.isListType)(nullableType)) {
    return value.map((listMember) => transformInputValue2(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if ((0, import_graphql47.isInputObjectType)(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue2(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue2(type, value) {
  return transformInputValue2(type, value, (t, v2) => {
    try {
      return t.serialize(v2);
    } catch (_a2) {
      return v2;
    }
  });
}
function parseInputValue2(type, value) {
  return transformInputValue2(type, value, (t, v2) => {
    try {
      return t.parseValue(v2);
    } catch (_a2) {
      return v2;
    }
  });
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema2(schema2, schemaMapper = {}) {
  const newTypeMap = mapArguments2(mapFields2(mapTypes2(mapDefaultValues2(mapEnumValues2(mapTypes2(mapDefaultValues2(schema2.getTypeMap(), schema2, serializeInputValue2), schema2, schemaMapper, (type) => (0, import_graphql48.isLeafType)(type)), schema2, schemaMapper), schema2, parseInputValue2), schema2, schemaMapper, (type) => !(0, import_graphql48.isLeafType)(type)), schema2, schemaMapper), schema2, schemaMapper);
  const originalDirectives = schema2.getDirectives();
  const newDirectives = mapDirectives2(originalDirectives, schema2, schemaMapper);
  const { typeMap, directives } = rewireTypes2(newTypeMap, newDirectives);
  return new import_graphql48.GraphQLSchema({
    ...schema2.toConfig(),
    query: getObjectTypeFromTypeMap2(typeMap, getObjectTypeFromTypeMap2(newTypeMap, schema2.getQueryType())),
    mutation: getObjectTypeFromTypeMap2(typeMap, getObjectTypeFromTypeMap2(newTypeMap, schema2.getMutationType())),
    subscription: getObjectTypeFromTypeMap2(typeMap, getObjectTypeFromTypeMap2(newTypeMap, schema2.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
function mapTypes2(originalTypeMap, schema2, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper2(schema2, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema2);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues2(originalTypeMap, schema2, schemaMapper) {
  const enumValueMapper = getEnumValueMapper2(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes2(originalTypeMap, schema2, {
    [MapperKind2.ENUM_TYPE]: (type) => {
      const config2 = type.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema2, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes2(new import_graphql48.GraphQLEnumType({
        ...config2,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => (0, import_graphql48.isEnumType)(type));
}
function mapDefaultValues2(originalTypeMap, schema2, fn2) {
  const newTypeMap = mapArguments2(originalTypeMap, schema2, {
    [MapperKind2.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType2(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields2(newTypeMap, schema2, {
    [MapperKind2.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType2(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
function getNewType2(newTypeMap, type) {
  if ((0, import_graphql48.isListType)(type)) {
    const newType = getNewType2(newTypeMap, type.ofType);
    return newType != null ? new import_graphql48.GraphQLList(newType) : null;
  } else if ((0, import_graphql48.isNonNullType)(type)) {
    const newType = getNewType2(newTypeMap, type.ofType);
    return newType != null ? new import_graphql48.GraphQLNonNull(newType) : null;
  } else if ((0, import_graphql48.isNamedType)(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields2(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql48.isObjectType)(originalType) && !(0, import_graphql48.isInterfaceType)(originalType) && !(0, import_graphql48.isInputObjectType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper2(schema2, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema2);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if ((0, import_graphql48.isObjectType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes2(new import_graphql48.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else if ((0, import_graphql48.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes2(new import_graphql48.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes2(new import_graphql48.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapArguments2(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql48.isObjectType)(originalType) && !(0, import_graphql48.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper2(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema2);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if ((0, import_graphql48.isObjectType)(originalType)) {
        newTypeMap[typeName] = new import_graphql48.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else if ((0, import_graphql48.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = new import_graphql48.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql48.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
function mapDirectives2(originalDirectives, schema2, schemaMapper) {
  const directiveMapper = getDirectiveMapper2(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema2);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers2(schema2, typeName) {
  var _a2, _b, _c2;
  const type = schema2.getType(typeName);
  const specifiers = [MapperKind2.TYPE];
  if ((0, import_graphql48.isObjectType)(type)) {
    specifiers.push(MapperKind2.COMPOSITE_TYPE, MapperKind2.OBJECT_TYPE);
    if (typeName === ((_a2 = schema2.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind2.ROOT_OBJECT, MapperKind2.QUERY);
    } else if (typeName === ((_b = schema2.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind2.ROOT_OBJECT, MapperKind2.MUTATION);
    } else if (typeName === ((_c2 = schema2.getSubscriptionType()) === null || _c2 === void 0 ? void 0 : _c2.name)) {
      specifiers.push(MapperKind2.ROOT_OBJECT, MapperKind2.SUBSCRIPTION);
    }
  } else if ((0, import_graphql48.isInputObjectType)(type)) {
    specifiers.push(MapperKind2.INPUT_OBJECT_TYPE);
  } else if ((0, import_graphql48.isInterfaceType)(type)) {
    specifiers.push(MapperKind2.COMPOSITE_TYPE, MapperKind2.ABSTRACT_TYPE, MapperKind2.INTERFACE_TYPE);
  } else if ((0, import_graphql48.isUnionType)(type)) {
    specifiers.push(MapperKind2.COMPOSITE_TYPE, MapperKind2.ABSTRACT_TYPE, MapperKind2.UNION_TYPE);
  } else if ((0, import_graphql48.isEnumType)(type)) {
    specifiers.push(MapperKind2.ENUM_TYPE);
  } else if ((0, import_graphql48.isScalarType)(type)) {
    specifiers.push(MapperKind2.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper2(schema2, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers2(schema2, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers2(schema2, typeName) {
  var _a2, _b, _c2;
  const type = schema2.getType(typeName);
  const specifiers = [MapperKind2.FIELD];
  if ((0, import_graphql48.isObjectType)(type)) {
    specifiers.push(MapperKind2.COMPOSITE_FIELD, MapperKind2.OBJECT_FIELD);
    if (typeName === ((_a2 = schema2.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind2.ROOT_FIELD, MapperKind2.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema2.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind2.ROOT_FIELD, MapperKind2.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c2 = schema2.getSubscriptionType()) === null || _c2 === void 0 ? void 0 : _c2.name)) {
      specifiers.push(MapperKind2.ROOT_FIELD, MapperKind2.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if ((0, import_graphql48.isInterfaceType)(type)) {
    specifiers.push(MapperKind2.COMPOSITE_FIELD, MapperKind2.INTERFACE_FIELD);
  } else if ((0, import_graphql48.isInputObjectType)(type)) {
    specifiers.push(MapperKind2.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper2(schema2, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers2(schema2, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper2(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind2.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper2(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind2.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper2(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind2.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes2(type) {
  if ((0, import_graphql48.isObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql48.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql48.Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql48.GraphQLObjectType(config2);
  } else if ((0, import_graphql48.isInterfaceType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql48.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql48.Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql48.GraphQLInterfaceType(config2);
  } else if ((0, import_graphql48.isInputObjectType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql48.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql48.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql48.GraphQLInputObjectType(config2);
  } else if ((0, import_graphql48.isEnumType)(type)) {
    const config2 = type.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        values
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new import_graphql48.GraphQLEnumType(config2);
  } else {
    return type;
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/heal.js
var import_graphql49 = __toESM(require_graphql2(), 1);
function healSchema2(schema2) {
  healTypes2(schema2.getTypeMap(), schema2.getDirectives());
  return schema2;
}
function healTypes2(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualName in actualNamedTypeMap) {
      throw new Error(`Duplicate schema type name ${actualName}`);
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if ((0, import_graphql49.isObjectType)(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if ((0, import_graphql49.isInterfaceType)(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if ((0, import_graphql49.isUnionType)(type)) {
      healUnderlyingTypes(type);
      return;
    } else if ((0, import_graphql49.isInputObjectType)(type)) {
      healInputFields(type);
      return;
    } else if ((0, import_graphql49.isLeafType)(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if ((0, import_graphql49.isListType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql49.GraphQLList(healedType) : null;
    } else if ((0, import_graphql49.isNonNullType)(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new import_graphql49.GraphQLNonNull(healedType) : null;
    } else if ((0, import_graphql49.isNamedType)(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/forEachField.js
var import_graphql50 = __toESM(require_graphql2(), 1);
function forEachField2(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql50.getNamedType)(type).name.startsWith("__") && (0, import_graphql50.isObjectType)(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn2(field, typeName, fieldName);
      }
    }
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
var import_graphql51 = __toESM(require_graphql2(), 1);
function forEachDefaultValue2(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!(0, import_graphql51.getNamedType)(type).name.startsWith("__")) {
      if ((0, import_graphql51.isObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn2(arg.type, arg.defaultValue);
          }
        }
      } else if ((0, import_graphql51.isInputObjectType)(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn2(field.type, field.defaultValue);
        }
      }
    }
  }
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
var import_graphql52 = __toESM(require_graphql2(), 1);

// node_modules/graphql-middleware/node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver2(schema2, requireResolversForResolveType) {
  mapSchema2(schema2, {
    [MapperKind2.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces2(schema2, resolvers2) {
  const extendedResolvers = {};
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers2[iFace.name]) {
          for (const fieldName in resolvers2[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers2[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers2[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}

// node_modules/graphql-middleware/node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema2(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
  const options = (0, import_graphql52.isSchema)(schemaOrOptions) ? {
    schema: schemaOrOptions,
    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
    resolverValidationOptions: legacyInputValidationOptions
  } : schemaOrOptions;
  let { schema: schema2, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver3, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options;
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers2 = inheritResolversFromInterfaces ? extendResolversFromInterfaces2(schema2, inputResolvers) : inputResolvers;
  for (const typeName in resolvers2) {
    const resolverValue = resolvers2[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema2.getType(typeName);
    if (type == null) {
      if (requireResolversToMatchSchema === "ignore") {
        continue;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if ((0, import_graphql52.isSpecifiedScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql52.isEnumType)(type)) {
      const values = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
        }
      }
    } else if ((0, import_graphql52.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
        }
      }
    } else if ((0, import_graphql52.isObjectType)(type) || (0, import_graphql52.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema2 = updateResolversInPlace ? addResolversToExistingSchema2(schema2, resolvers2, defaultFieldResolver3) : createNewSchemaWithResolvers2(schema2, resolvers2, defaultFieldResolver3);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver2(schema2, requireResolversForResolveType);
  }
  return schema2;
}
function addResolversToExistingSchema2(schema2, resolvers2, defaultFieldResolver3) {
  var _a2, _b, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l2, _m2;
  const typeMap = schema2.getTypeMap();
  for (const typeName in resolvers2) {
    const type = schema2.getType(typeName);
    const resolverValue = resolvers2[typeName];
    if ((0, import_graphql52.isScalarType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: (_b = (_a2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type.astNode.description,
            directives: ((_c2 = type.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e2 = (_d2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d2 === void 0 ? void 0 : _d2.directives) !== null && _e2 !== void 0 ? _e2 : [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql52.isEnumType)(type)) {
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config2.astNode != null) {
          config2.astNode = {
            ...config2.astNode,
            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
            directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l2 = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l2 !== void 0 ? _l2 : [])
          };
        } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.concat((_m2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m2 !== void 0 ? _m2 : []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql52.GraphQLEnumType(config2);
    } else if ((0, import_graphql52.isUnionType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql52.isObjectType)(type) || (0, import_graphql52.isInterfaceType)(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties2(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue2(schema2, serializeInputValue2);
  healSchema2(schema2);
  forEachDefaultValue2(schema2, parseInputValue2);
  if (defaultFieldResolver3 != null) {
    forEachField2(schema2, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver3;
      }
    });
  }
  return schema2;
}
function createNewSchemaWithResolvers2(schema2, resolvers2, defaultFieldResolver3) {
  schema2 = mapSchema2(schema2, {
    [MapperKind2.SCALAR_TYPE]: (type) => {
      var _a2, _b, _c2, _d2, _e2, _f;
      const config2 = type.toConfig();
      const resolverValue = resolvers2[type.name];
      if (!(0, import_graphql52.isSpecifiedScalarType)(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c2 = config2.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e2 = (_d2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d2 === void 0 ? void 0 : _d2.directives) !== null && _e2 !== void 0 ? _e2 : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config2[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql52.GraphQLScalarType(config2);
      }
    },
    [MapperKind2.ENUM_TYPE]: (type) => {
      var _a2, _b, _c2, _d2, _e2, _f;
      const resolverValue = resolvers2[type.name];
      const config2 = type.toConfig();
      const enumValueConfigMap = config2.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c2 = config2.astNode.directives) !== null && _c2 !== void 0 ? _c2 : []).concat((_e2 = (_d2 = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d2 === void 0 ? void 0 : _d2.directives) !== null && _e2 !== void 0 ? _e2 : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql52.GraphQLEnumType(config2);
      }
    },
    [MapperKind2.UNION_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql52.GraphQLUnionType(config2);
      }
    },
    [MapperKind2.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config2.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql52.GraphQLObjectType(config2);
      }
    },
    [MapperKind2.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers2[type.name];
      if (resolverValue != null) {
        const config2 = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql52.GraphQLInterfaceType(config2);
      }
    },
    [MapperKind2.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers2[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties2(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver3 != null) {
    schema2 = mapSchema2(schema2, {
      [MapperKind2.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver3
      })
    });
  }
  return schema2;
}
function setFieldProperties2(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}

// node_modules/graphql-middleware/dist/applicator.mjs
var import_graphql54 = __toESM(require_graphql2(), 1);

// node_modules/graphql-middleware/dist/utils.mjs
var import_graphql53 = __toESM(require_graphql2(), 1);

// node_modules/graphql-middleware/dist/generator.mjs
var MiddlewareGenerator = class {
  constructor(generator) {
    this.generator = generator;
  }
  generate(schema2) {
    return this.generator(schema2);
  }
};

// node_modules/graphql-middleware/dist/utils.mjs
function isMiddlewareResolver(obj) {
  return typeof obj === "function" || typeof obj === "object" && obj.then !== void 0;
}
function isMiddlewareWithFragment(obj) {
  return (typeof obj.fragment === "string" || typeof obj.fragments === "object") && isMiddlewareResolver(obj.resolve);
}
function isMiddlewareFunction(obj) {
  return isMiddlewareWithFragment(obj) || isMiddlewareResolver(obj);
}
function isMiddlewareGenerator(x) {
  return x instanceof MiddlewareGenerator;
}
function isGraphQLObjectType(obj) {
  return obj instanceof import_graphql53.GraphQLObjectType || obj instanceof import_graphql53.GraphQLInterfaceType;
}

// node_modules/graphql-middleware/dist/applicator.mjs
function wrapResolverInMiddleware(resolver, middleware2) {
  return (parent, args, ctx, info) => middleware2((_parent = parent, _args = args, _ctx = ctx, _info = info) => resolver(_parent, _args, _ctx, _info), parent, args, ctx, info);
}
function parseField(field) {
  const { isDeprecated, ...restData } = field;
  const argsMap = field.args.reduce((acc, cur) => {
    acc[cur.name] = cur;
    return acc;
  }, {});
  return {
    ...restData,
    args: argsMap
  };
}
function applyMiddlewareToField(field, options, middleware2) {
  const parsedField = parseField(field);
  if (isMiddlewareWithFragment(middleware2) && parsedField.resolve && parsedField.resolve !== import_graphql54.defaultFieldResolver) {
    return {
      ...parsedField,
      fragment: middleware2.fragment,
      fragments: middleware2.fragments,
      resolve: wrapResolverInMiddleware(parsedField.resolve, middleware2.resolve)
    };
  } else if (isMiddlewareWithFragment(middleware2) && parsedField.subscribe) {
    return {
      ...parsedField,
      fragment: middleware2.fragment,
      fragments: middleware2.fragments,
      subscribe: wrapResolverInMiddleware(parsedField.subscribe, middleware2.resolve)
    };
  } else if (isMiddlewareResolver(middleware2) && parsedField.resolve && parsedField.resolve !== import_graphql54.defaultFieldResolver) {
    return {
      ...parsedField,
      resolve: wrapResolverInMiddleware(parsedField.resolve, middleware2)
    };
  } else if (isMiddlewareResolver(middleware2) && parsedField.subscribe) {
    return {
      ...parsedField,
      subscribe: wrapResolverInMiddleware(parsedField.subscribe, middleware2)
    };
  } else if (isMiddlewareWithFragment(middleware2) && !options.onlyDeclaredResolvers) {
    return {
      ...parsedField,
      fragment: middleware2.fragment,
      fragments: middleware2.fragments,
      resolve: wrapResolverInMiddleware(import_graphql54.defaultFieldResolver, middleware2.resolve)
    };
  } else if (isMiddlewareResolver(middleware2) && !options.onlyDeclaredResolvers) {
    return {
      ...parsedField,
      resolve: wrapResolverInMiddleware(import_graphql54.defaultFieldResolver, middleware2)
    };
  } else {
    return { ...parsedField, resolve: import_graphql54.defaultFieldResolver };
  }
}
function applyMiddlewareToType(type, options, middleware2) {
  const fieldMap = type.getFields();
  if (isMiddlewareFunction(middleware2)) {
    const resolvers2 = Object.keys(fieldMap).reduce((resolvers22, fieldName) => {
      resolvers22[fieldName] = applyMiddlewareToField(fieldMap[fieldName], options, middleware2);
      return resolvers22;
    }, {});
    return resolvers2;
  } else {
    const resolvers2 = Object.keys(middleware2).reduce((resolvers22, fieldName) => {
      resolvers22[fieldName] = applyMiddlewareToField(fieldMap[fieldName], options, middleware2[fieldName]);
      return resolvers22;
    }, {});
    return resolvers2;
  }
}
function applyMiddlewareToSchema(schema2, options, middleware2) {
  const typeMap = schema2.getTypeMap();
  const resolvers2 = Object.keys(typeMap).filter((type) => isGraphQLObjectType(typeMap[type]) && !(0, import_graphql54.isIntrospectionType)(typeMap[type])).reduce((resolvers22, type) => {
    resolvers22[type] = applyMiddlewareToType(typeMap[type], options, middleware2);
    return resolvers22;
  }, {});
  return resolvers2;
}
function generateResolverFromSchemaAndMiddleware(schema2, options, middleware2) {
  if (isMiddlewareFunction(middleware2)) {
    return applyMiddlewareToSchema(schema2, options, middleware2);
  } else {
    const typeMap = schema2.getTypeMap();
    const resolvers2 = Object.keys(middleware2).reduce((resolvers22, type) => {
      resolvers22[type] = applyMiddlewareToType(typeMap[type], options, middleware2[type]);
      return resolvers22;
    }, {});
    return resolvers2;
  }
}

// node_modules/graphql-middleware/dist/validation.mjs
function validateMiddleware(schema2, middleware2) {
  if (isMiddlewareFunction(middleware2)) {
    return middleware2;
  }
  const types = schema2.getTypeMap();
  Object.keys(middleware2).forEach((type) => {
    if (!Object.keys(types).includes(type)) {
      throw new MiddlewareError(`Type ${type} exists in middleware but is missing in Schema.`);
    }
    if (!isMiddlewareFunction(middleware2[type])) {
      const fields = types[type].getFields();
      Object.keys(middleware2[type]).forEach((field) => {
        if (!Object.keys(fields).includes(field)) {
          throw new MiddlewareError(`Field ${type}.${field} exists in middleware but is missing in Schema.`);
        }
        if (!isMiddlewareFunction(middleware2[type][field])) {
          throw new MiddlewareError(`Expected ${type}.${field} to be a function but found ` + typeof middleware2[type][field]);
        }
      });
    }
  });
  return middleware2;
}
var MiddlewareError = class extends Error {
};

// node_modules/graphql-middleware/dist/fragments.mjs
var import_graphql55 = __toESM(require_graphql2(), 1);
function extractFragmentReplacements(resolvers2) {
  const allFragmentReplacements = [];
  for (const typeName in resolvers2) {
    const fieldResolvers = resolvers2[typeName];
    for (const fieldName in fieldResolvers) {
      const fieldResolver = fieldResolvers[fieldName];
      if (typeof fieldResolver === "object" && fieldResolver.fragment) {
        allFragmentReplacements.push({
          field: fieldName,
          fragment: fieldResolver.fragment
        });
      }
      if (typeof fieldResolver === "object" && fieldResolver.fragments) {
        for (const fragment of fieldResolver.fragments) {
          allFragmentReplacements.push({
            field: fieldName,
            fragment
          });
        }
      }
    }
  }
  const fragmentReplacements = allFragmentReplacements.filter((fragment) => Boolean(fragment)).map((fragmentReplacement) => {
    const fragment = parseFragmentToInlineFragment(fragmentReplacement.fragment);
    const newSelections = fragment.selectionSet.selections.filter((node) => {
      switch (node.kind) {
        case import_graphql55.Kind.FIELD: {
          return node.name.value !== fragmentReplacement.field;
        }
        default: {
          return true;
        }
      }
    });
    if (newSelections.length === 0) {
      return null;
    }
    const newFragment = {
      ...fragment,
      selectionSet: {
        kind: fragment.selectionSet.kind,
        loc: fragment.selectionSet.loc,
        selections: newSelections
      }
    };
    const parsedFragment = (0, import_graphql55.print)(newFragment);
    return {
      field: fragmentReplacement.field,
      fragment: parsedFragment
    };
  }).filter((fr2) => fr2 !== null);
  return fragmentReplacements;
  function parseFragmentToInlineFragment(definitions) {
    if (definitions.trim().startsWith("fragment")) {
      const document2 = (0, import_graphql55.parse)(definitions);
      for (const definition of document2.definitions) {
        if (definition.kind === import_graphql55.Kind.FRAGMENT_DEFINITION) {
          return {
            kind: import_graphql55.Kind.INLINE_FRAGMENT,
            typeCondition: definition.typeCondition,
            selectionSet: definition.selectionSet
          };
        }
      }
    }
    const query = (0, import_graphql55.parse)(`{${definitions}}`).definitions[0];
    for (const selection of query.selectionSet.selections) {
      if (selection.kind === import_graphql55.Kind.INLINE_FRAGMENT) {
        return selection;
      }
    }
    throw new Error("Could not parse fragment");
  }
}

// node_modules/graphql-middleware/dist/middleware.mjs
function addMiddlewareToSchema(schema2, options, middleware2) {
  const validMiddleware = validateMiddleware(schema2, middleware2);
  const resolvers2 = generateResolverFromSchemaAndMiddleware(schema2, options, validMiddleware);
  const fragmentReplacements = extractFragmentReplacements(resolvers2);
  const newSchema = addResolversToSchema2({
    schema: schema2,
    resolvers: resolvers2,
    updateResolversInPlace: false,
    resolverValidationOptions: {
      requireResolversForResolveType: "ignore"
    }
  });
  return { schema: newSchema, fragmentReplacements };
}
function applyMiddlewareWithOptions(schema2, options, ...middlewares) {
  const normalisedMiddlewares = middlewares.map((middleware2) => {
    if (isMiddlewareGenerator(middleware2)) {
      return middleware2.generate(schema2);
    } else {
      return middleware2;
    }
  });
  const schemaWithMiddlewareAndFragmentReplacements = normalisedMiddlewares.reduceRight(({
    schema: currentSchema,
    fragmentReplacements: currentFragmentReplacements
  }, middleware2) => {
    const {
      schema: newSchema,
      fragmentReplacements: newFragmentReplacements
    } = addMiddlewareToSchema(currentSchema, options, middleware2);
    return {
      schema: newSchema,
      fragmentReplacements: [
        ...currentFragmentReplacements,
        ...newFragmentReplacements
      ]
    };
  }, { schema: schema2, fragmentReplacements: [] });
  const schemaWithMiddleware = schemaWithMiddlewareAndFragmentReplacements.schema;
  schemaWithMiddleware.schema = schemaWithMiddlewareAndFragmentReplacements.schema;
  schemaWithMiddleware.fragmentReplacements = schemaWithMiddlewareAndFragmentReplacements.fragmentReplacements;
  return schemaWithMiddleware;
}
function applyMiddleware(schema2, ...middlewares) {
  return applyMiddlewareWithOptions(schema2, { onlyDeclaredResolvers: false }, ...middlewares);
}

// src/server.ts
var schema = createSchema({
  typeDefs,
  resolvers
});
var schemaWithMiddleWare = applyMiddleware(schema);
prisma_default.$connect().then(() => {
  console.log("  \u{1F941} prisma connected");
}).catch((err) => {
  console.log("  \u{1F53B} prisma error", err);
  process.exit(1);
  throw err;
});
var yoga = createYoga({
  graphqlEndpoint: "/graphql",
  schema: schemaWithMiddleWare,
  context: async (initialContext) => createContext(initialContext)
});
var server = (0, import_node_http.createServer)(yoga);
server.listen(4e3, () => {
  console.log(`
  \u{1F680} Server ready at: http://localhost:4000`);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  schema
});
/*! Bundled license information:

@prisma/client/runtime/library.js:
  (*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)

bcryptjs/dist/bcrypt.js:
  (**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   *)
*/
